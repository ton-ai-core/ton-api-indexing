{
  "code": "b5ee9c7201021e01000261000114ff00f4a413f4bcf2c80b010201200203020148040501f2f28308d71820d31fd31fd31f802403f823bb13f2f2f003802251a9ba1af2f4802351b7ba1bf2f4801f0bf9015410c5f9101af2f4f8005057f823f0065098f823f0062071289320d74a8e8bd30731d4511bdb3c12b001e8309229a0df72fb02069320d74a96d307d402fb00e8d103a4476814154330f004ed541d0202cd0607020120131402012008090201200f100201200a0b002d5ed44d0d31fd31fd3ffd3fff404fa00f404fa00f404d1803f7007434c0c05c6c2497c0f83e900c0871c02497c0f80074c7c87040a497c1383c00d46d3c00608420babe7114ac2f6c2497c338200a208420babe7106ee86bcbd20084ae0840ee6b2802fbcbd01e0c235c62008087e4055040dbe4404bcbd34c7e00a60840dceaa7d04ee84bcbd34c034c7cc0078c3c412040dd78ca00c0d0e00130875d27d2a1be95b0c60000c1039480af00500161037410af0050810575056001010244300f004ed540201201112004548e1e228020f4966fa520933023bb9131e2209835fa00d113a14013926c21e2b3e6308003502323287c5f287c572ffc4f2fffd00007e80bd00007e80bd00326000431448a814c4e0083d039be865be803444e800a44c38b21400fe809004e0083d10c06002012015160015bde9f780188242f847800c02012017180201481b1c002db5187e006d88868a82609e00c6207e00c63f04ede20b30020158191a0017adce76a268699f98eb85ffc00017ac78f6a268698f98eb858fc00011b325fb513435c2c7e00017b1d1be08e0804230fb50f620002801d0d3030178b0925b7fe0fa4031fa403001f001",
  "code_hash": "88fbf818e47d5f328f7dc34bad4323bb28a12ec6c75ce9ec25d77746c56e1ded",
  "methods": [
    {
      "id": 78748,
      "method": "get_public_key"
    },
    {
      "id": 87878,
      "method": "get_balances"
    },
    {
      "id": 85143,
      "method": "seqno"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "uni-lockup-wallet.fc",
        "content": ";; Restricted wallet initialized by a third party (a variant of restricted-wallet3-code.fc)\n;; Allows to add more locked budget after initialization\n\nint err:wrong_signature() asm \"31 PUSHINT\";\nint err:wrong_config_signature() asm \"32 PUSHINT\";\nint err:value_is_too_small() asm \"33 PUSHINT\";\nint err:wrong_seqno() asm \"34 PUSHINT\";\nint err:wrong_subwallet_id() asm \"35 PUSHINT\";\nint err:replay_protection() asm \"36 PUSHINT\";\nint err:unknown_op() asm \"40 PUSHINT\";\nint err:unknown_cmd() asm \"41 PUSHINT\";\n\nint op:rwallet_op() asm \"0x82eaf9c4 PUSHINT\";\nint cmd:restricted_transfer() asm \"0x373aa9f4 PUSHINT\";\n\n_ is_whitelisted?(addr, allowed_destinations) {\n  (_, _, _, int found) = allowed_destinations.pfxdict_get?(addr.slice_bits(), addr);\n  return found;\n}\n\n_ check_message_destination(msg, allowed_destinations) inline_ref {\n  var cs = msg.begin_parse();\n  var flags = cs~load_uint(4);\n  if (flags & 8) {\n    ;; external messages are always valid\n    return true;\n  }\n  var (s_addr, d_addr) = (cs~load_msg_addr(), cs~load_msg_addr());\n\n  return is_whitelisted?(d_addr, allowed_destinations);\n}\n\n_ unpack_data() {\n  var cs = get_data().begin_parse();\n  var res = (\n    cs~load_uint(32),\n    cs~load_uint(32),\n    cs~load_uint(256),\n    cs~load_uint(256),\n    cs~load_dict(),\n    cs~load_grams(),\n    cs~load_dict(),\n    cs~load_grams(),\n    cs~load_dict()\n  );\n  cs.end_parse();\n  return res;\n}\n\n_ pack_data(int seqno, int subwallet_id, int public_key, int config_public_key, cell allowed_destinations, int total_locked_value, cell\nlocked, int total_restricted_value, cell restricted) {\n  return begin_cell()\n    .store_int(seqno, 32)\n    .store_int(subwallet_id, 32)\n    .store_uint(public_key, 256)\n    .store_uint(config_public_key, 256)\n    .store_dict(allowed_destinations)\n    .store_grams(total_locked_value)\n    .store_dict(locked)\n    .store_grams(total_restricted_value)\n    .store_dict(restricted).end_cell();\n}\n\n(cell, int) lock_grams(cell locked, int total, int ts, int value) {\n  total += value;\n  (slice found_cs, var found) = locked.udict_get?(32, ts);\n  if (found) {\n    var found_value = found_cs~load_grams();\n    found_cs.end_parse();\n    value += found_value;\n  }\n  locked~udict_set_builder(32, ts, begin_cell().store_grams(value));\n  return (locked, total);\n}\n\n(cell, int) unlock_grams(cell locked, int total, int now_ts) {\n  do {\n    var (locked', ts, value_cs, f) = locked.udict_delete_get_min(32);\n    f~touch();\n    if (f) {\n      f = ts <= now_ts;\n    }\n    if (f) {\n      locked = locked';\n      int value = value_cs~load_grams();\n      value_cs.end_parse();\n      total -= value;\n    }\n  } until (~ f);\n  return (locked, total);\n}\n\n() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {\n  var cs = in_msg_cell.begin_parse();\n  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n  if (flags & 1) {\n    ;; ignore all bounced messages\n    return ();\n  }\n  var s_addr = cs~load_msg_addr();\n  if (in_msg.slice_empty?()) {\n    return();\n  }\n  int op = in_msg~load_uint(32);\n  if (op <= 1) {\n    ;; simple transfer with comment, return\n    return ();\n  }\n  var (stored_seqno, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n       total_restricted_value, restricted) = unpack_data();\n\n  if is_whitelisted?(s_addr, allowed_destinations) & (op != op:rwallet_op()) {\n    return ();\n  }\n\n  throw_unless(err:unknown_op(), op == op:rwallet_op());\n  throw_unless(err:value_is_too_small(), msg_value >= 1000000000);\n\n\n\n  var signature = in_msg~load_bits(512);\n  throw_unless(err:wrong_config_signature(), check_signature(slice_hash(in_msg), signature, config_public_key));\n  int cmd = in_msg~load_uint(32);\n  throw_unless(err:unknown_cmd(), cmd == cmd:restricted_transfer());\n  var (only_restrict, ts) = (in_msg~load_uint(1), in_msg~load_uint(32));\n  if (only_restrict) {\n    (restricted, total_restricted_value) = lock_grams(restricted, total_restricted_value, ts, msg_value);\n  } else {\n    (locked, total_locked_value) = lock_grams(locked, total_locked_value, ts, msg_value);\n  }\n\n  set_data(pack_data(stored_seqno, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n                     total_restricted_value, restricted));\n}\n\n() recv_external(slice in_msg) impure {\n  var signature = in_msg~load_bits(512);\n  var cs = in_msg;\n  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));\n  throw_if(err:replay_protection(), valid_until <= now());\n  var (stored_seqno, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n       total_restricted_value, restricted) = unpack_data();\n  throw_unless(err:wrong_seqno(), msg_seqno == stored_seqno);\n  throw_unless(err:wrong_subwallet_id(), subwallet_id == stored_subwallet);\n  throw_unless(err:wrong_signature(), check_signature(slice_hash(in_msg), signature, public_key));\n  accept_message();\n\n  (restricted, total_restricted_value) = unlock_grams(restricted, total_restricted_value, now());\n  (locked, total_locked_value) = unlock_grams(locked, total_locked_value, now());\n  int effectively_locked = total_locked_value;\n  int can_use_restricted = 1;\n  var cs_copy = cs;\n  while (cs_copy.slice_refs()) {\n    var mode = cs_copy~load_uint(8);\n    var msg = cs_copy~load_ref();\n    can_use_restricted &= check_message_destination(msg, allowed_destinations);\n  }\n\n  ifnot (can_use_restricted) {\n    effectively_locked += total_restricted_value;\n  }\n  raw_reserve(effectively_locked, 2);\n\n  cs~touch();\n  while (cs.slice_refs()) {\n    var mode = cs~load_uint(8);\n    var msg = cs~load_ref();\n    send_raw_message(msg, mode);\n  }\n  cs.end_parse();\n\n  set_data(pack_data(stored_seqno + 1, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n                     total_restricted_value, restricted));\n}\n\n;; Get methods\n\nint seqno() method_id {\n  return get_data().begin_parse().preload_uint(32);\n}\n\nint wallet_id() method_id {\n  var ds = get_data().begin_parse();\n  ds~load_uint(32);\n  return ds.preload_uint(32);\n}\n\nint get_public_key() method_id {\n  var ds = get_data().begin_parse();\n  ds~load_uint(32 + 32);\n  return ds.preload_uint(256);\n}\n\n;; the next three methods are mostly for testing\n\n(int, int, int) get_balances_at(int time) method_id {\n  var (stored_seqno, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n       total_restricted_value, restricted) = unpack_data();\n  (restricted, total_restricted_value) = unlock_grams(restricted, total_restricted_value, time);\n  (locked, total_locked_value) = unlock_grams(locked, total_locked_value, time);\n  int ton_balance = get_balance().pair_first();\n  return ( ton_balance,\n           total_restricted_value,\n           total_locked_value );\n}\n\n(int, int, int) get_balances() method_id {\n  return get_balances_at(now());\n}\n\nint check_destination(slice destination) method_id {\n  var (stored_seqno, stored_subwallet, public_key, config_public_key, allowed_destinations, total_locked_value, locked,\n       total_restricted_value, restricted) = unpack_data();\n  return is_whitelisted?(destination, allowed_destinations);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}