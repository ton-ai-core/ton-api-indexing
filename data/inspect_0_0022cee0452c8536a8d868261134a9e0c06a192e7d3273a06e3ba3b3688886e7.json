{
  "code": "b5ee9c720102140100021f000114ff00f4a413f4bcf2c80b0102016202030202cd04050201200e0f04e7d10638048adf000e8698180b8d848adf07d201800e98fe99ff6a2687d20699fea6a6a184108349e9ca829405d47141baf8280e8410854658056b84008646582a802e78b127d010a65b509e58fe59f80e78b64c0207d80701b28b9e382f970c892e000f18112e001718112e001f181181981e0024060708090201200a0b00603502d33f5313bbf2e1925313ba01fa00d43028103459f0068e1201a44343c85005cf1613cb3fccccccc9ed54925f05e200a6357003d4308e378040f4966fa5208e2906a4208100fabe93f2c18fde81019321a05325bbf2f402fa00d43022544b30f00623ba9302a402de04926c21e2b3e6303250444313c85005cf1613cb3fccccccc9ed54002c323401fa40304144c85005cf1613cb3fccccccc9ed54003c8e15d4d43010344130c85005cf1613cb3fccccccc9ed54e05f04840ff2f00201200c0d003d45af0047021f005778018c8cb0558cf165004fa0213cb6b12ccccc971fb008002d007232cffe0a33c5b25c083232c044fd003d0032c03260001b3e401d3232c084b281f2fff2742002012010110025bc82df6a2687d20699fea6a6a182de86a182c40043b8b5d31ed44d0fa40d33fd4d4d43010245f04d0d431d430d071c8cb0701cf16ccc980201201213002fb5dafda89a1f481a67fa9a9a860d883a1a61fa61ff480610002db4f47da89a1f481a67fa9a9a86028be09e008e003e00b0",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            DUP\n            SEMPTY\n            IFJMP:<{\n                  2DROP\n            }>\n            SWAP\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  2DROP\n            }>\n            LDMSGADDR\n            DROP\n            SWAP\n            32 LDU\n            64 LDU\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1765620048 PUSHINT\n            s8 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s7 POP\n                  5 BLKDROP\n                  SWAP\n                  CTOS\n                  2831876269 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s4 PUSH\n                  STGRAMS\n                  s1 s4 XCHG\n                  107 STU\n                  s1 s3 XCHG\n                  32 STU\n                  64 STU\n                  SWAP\n                  STSLICER\n                  ENDC\n                  64 PUSHINT\n                  SENDRAWMSG\n            }>\n            s6 POP\n            s7 s3 XCPU\n            SDEQ\n            401 THROWIFNOT\n            s5 PUSH\n            1 EQINT\n            IFJMP:<{\n                  s5 POP\n                  s0 s2 XCHG\n                  64 LDU\n                  s1 s3 PUSH2\n                  LEQ\n                  402 THROWIFNOT\n                  s1 s3 PUSH2\n                  EQUAL\n                  SWAP\n                  LDGRAMS\n                  LDREF\n                  DROP\n                  s8 PUSH\n                  s3 s4 XCHG\n                  ROTREV\n                  6 CALLDICT\n                  IF:<{\n                        SWAP\n                        INC\n                        s3 s4 s3 XCHG3\n                        NEWC\n                        s0 s5 XCHG2\n                        STSLICER\n                        s1 s3 XCHG\n                        64 STU\n                        STREF\n                        STREF\n                        STREF\n                        ENDC\n                        c4 POP\n                  }>ELSE<{\n                        5 BLKDROP\n                  }>\n            }>\n            s5 PUSH\n            2 EQINT\n            IFJMP:<{\n                  s5 POP\n                  0 PUSHINT\n                  s0 s3 XCHG\n                  LDREF\n                  DROP\n                  UNTIL:<{\n                        64 PUSHINT\n                        DICTUREMMIN\n                        NULLSWAPIFNOT2\n                        DUP\n                        IF:<{\n                              s0 s6 XCHG\n                              INC\n                              DUP\n                              250 PUSHINT\n                              GEQ\n                              IF:<{\n                                    399 THROW\n                              }>\n                              403 PUSHINT\n                              OVER\n                              ADD\n                              s2 s5 PUSH2\n                              LEQ\n                              THROWANYIFNOT\n                              s0 s2 XCHG\n                              LDGRAMS\n                              LDREF\n                              DROP\n                              s2 PUSH\n                              s11 s2 s(-1) PUXC2\n                              6 CALLDICT\n                              s3 PUSH\n                              EQUAL\n                              IF:<{\n                                    s0 s2 XCHG\n                                    INC\n                                    s0 s2 XCHG\n                              }>\n                              s0 s4 XCHG\n                        }>ELSE<{\n                              2 1 BLKDROP2\n                        }>\n                        NOT\n                  }>\n                  DROP\n                  s2 POP\n                  s4 s4 XCHG2\n                  s3 s1 s3 XCHG3\n                  NEWC\n                  s0 s5 XCHG2\n                  STSLICER\n                  s1 s3 XCHG\n                  64 STU\n                  STREF\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            s5 PUSH\n            3 EQINT\n            IFJMP:<{\n                  s2 POP\n                  s4 POP\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  s1 s4 s4 XCHG3\n                  NEWC\n                  s0 s5 XCHG2\n                  STSLICER\n                  s1 s3 XCHG\n                  64 STU\n                  STREF\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            DROP\n            s3 POP\n            s0 s3 XCHG\n            4 EQINT\n            IFJMP:<{\n                  LDREF\n                  LDREF\n                  DROP\n                  s3 s4 XCHG\n                  s1 s3 s0 XCHG3\n                  NEWC\n                  s0 s5 XCHG2\n                  STSLICER\n                  s1 s3 XCHG\n                  64 STU\n                  STREF\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            4 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      4 => <{\n            SWAP\n            NEWC\n            64 STU\n            MYADDR\n            STSLICER\n            ENDC\n            0 PUSHINT\n            DUP\n            NEWC\n            2 STU\n            s1 s3 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n      }>\n      5 => <{\n            HASHCU\n            4 PUSHINT\n            NEWC\n            3 STU\n            s1 s2 XCHG\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n      }>\n      6 => <{\n            2SWAP\n            4 CALLDICT\n            0 PUSHINT\n            OVER\n            5 CALLDICT\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            ROT\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s3 XCHG\n            108 STU\n            s1 s2 XCHG\n            STREF\n            STREF\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n      }>\n      68445 => <{\n            NIP\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            s2 s4 XCHG\n            4 BLKDROP\n            CTOS\n            LDREF\n            NIP\n            LDREF\n            DROP\n            CTOS\n            1 PUSHINT\n            NEWC\n            8 STU\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n      }>\n      85719 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            4 1 BLKDROP2\n            CTOS\n            16 LDU\n            16 LDU\n            LDMSGADDR\n            DROP\n      }>\n      92067 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            s1 s4 XCHG\n            4 BLKDROP\n            4 CALLDICT\n            0 PUSHINT\n            SWAP\n            5 CALLDICT\n      }>\n      102491 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            2DROP\n            CTOS\n            LDREF\n            DROP\n            ROT\n      }>\n}\n11 THROWARG",
  "code_hash": "64bb2d4661b5f2dc1a83bf5cbbe09e92ac0b460a1b879a5519386fca4c348bca",
  "methods": [
    {
      "id": 68445,
      "method": "get_nft_content"
    },
    {
      "id": 85719,
      "method": "royalty_params"
    },
    {
      "id": 92067,
      "method": "get_nft_address_by_index"
    },
    {
      "id": 102491,
      "method": "get_collection_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == workchain());\n}\n\nslice null_addr() asm \"b{00} PUSHSLICE\";\nint flag::regular() asm \"0x10 PUSHINT\";\nint flag::bounce() asm \"0x8 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "nft-collection-editable.fc",
        "content": ";; NFT collection smart contract\n\n;; storage scheme\n;; default#_ royalty_factor:uint16 royalty_base:uint16 royalty_address:MsgAddress = RoyaltyParams;\n;; storage#_ owner_address:MsgAddress next_item_index:uint64\n;;           ^[collection_content:^Cell common_content:^Cell]\n;;           nft_item_code:^Cell\n;;           royalty_params:^RoyaltyParams\n;;           = Storage;\n\n(slice, int, cell, cell, cell) load_data() inline {\n  var ds = get_data().begin_parse();\n  return\n    (ds~load_msg_addr(), ;; owner_address\n     ds~load_uint(64), ;; next_item_index\n     ds~load_ref(), ;; content\n     ds~load_ref(), ;; nft_item_code\n     ds~load_ref()  ;; royalty_params\n     );\n}\n\n() save_data(slice owner_address, int next_item_index, cell content, cell nft_item_code, cell royalty_params) impure inline {\n  set_data(begin_cell()\n    .store_slice(owner_address)\n    .store_uint(next_item_index, 64)\n    .store_ref(content)\n    .store_ref(nft_item_code)\n    .store_ref(royalty_params)\n    .end_cell());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n  cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n  return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(int wc, cell state_init) {\n  return begin_cell().store_uint(4, 3)\n                     .store_int(wc, 8)\n                     .store_uint(cell_hash(state_init), 256)\n                     .end_cell()\n                     .begin_parse();\n}\n\n() deploy_nft_item(int item_index, cell nft_item_code, int amount, cell nft_content) impure {\n  cell state_init = calculate_nft_item_state_init(item_index, nft_item_code);\n  slice nft_address = calculate_nft_item_address(workchain(), state_init);\n  var msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(nft_address)\n            .store_coins(amount)\n            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n            .store_ref(state_init)\n            .store_ref(nft_content);\n  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n  var msg = begin_cell()\n    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool packages:MsgAddress -> 011000\n    .store_slice(to_address)\n    .store_coins(0)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(op::report_royalty_params(), 32)\n    .store_uint(query_id, 64)\n    .store_slice(data);\n  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    var (owner_address, next_item_index, content, nft_item_code, royalty_params) = load_data();\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, royalty_params.begin_parse());\n        return ();\n    }\n\n    throw_unless(401, equal_slices(sender_address, owner_address));\n\n\n    if (op == 1) { ;; deploy new nft\n      int item_index = in_msg_body~load_uint(64);\n      throw_unless(402, item_index <= next_item_index);\n      var is_last = item_index == next_item_index;\n      deploy_nft_item(item_index, nft_item_code, in_msg_body~load_coins(), in_msg_body~load_ref());\n      if (is_last) {\n        next_item_index += 1;\n        save_data(owner_address, next_item_index, content, nft_item_code, royalty_params);\n      }\n      return ();\n    }\n    if (op == 2) { ;; batch deploy of new nfts\n      int counter = 0;\n      cell deploy_list = in_msg_body~load_ref();\n      do {\n        var (item_index, item, f?) = deploy_list~udict::delete_get_min(64);\n        if (f?) {\n          counter += 1;\n          if (counter >= 250) { ;; Limit due to limits of action list size\n            throw(399);\n          }\n\n          throw_unless(403 + counter, item_index <= next_item_index);\n          deploy_nft_item(item_index, nft_item_code, item~load_coins(), item~load_ref());\n          if (item_index == next_item_index) {\n            next_item_index += 1;\n          }\n        }\n      } until ( ~ f?);\n      save_data(owner_address, next_item_index, content, nft_item_code, royalty_params);\n      return ();\n    }\n    if (op == 3) { ;; change owner\n      slice new_owner = in_msg_body~load_msg_addr();\n      save_data(new_owner, next_item_index, content, nft_item_code, royalty_params);\n      return ();\n    }\n    if (op == 4) { ;; change content\n      save_data(owner_address, next_item_index, in_msg_body~load_ref(), nft_item_code, in_msg_body~load_ref());\n      return ();\n    }\n    throw(0xffff);\n}\n\n;; Get methods\n\n(int, cell, slice) get_collection_data() method_id {\n  var (owner_address, next_item_index, content, _, _) = load_data();\n  slice cs = content.begin_parse();\n  return (next_item_index, cs~load_ref(), owner_address);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    var (_, _, _, nft_item_code, _) = load_data();\n    cell state_init = calculate_nft_item_state_init(index, nft_item_code);\n    return calculate_nft_item_address(0, state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n     var (_, _, _, _, royalty) = load_data();\n     slice rs = royalty.begin_parse();\n     return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n  var (_, _, content, _, _) = load_data();\n  slice cs = content.begin_parse();\n  cs~load_ref();\n  slice common_content = cs~load_ref().begin_parse();\n  return (begin_cell()\n                      .store_uint(1, 8) ;; offchain tag\n                      .store_slice(common_content)\n                      .store_ref(individual_nft_content)\n          .end_cell());\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}