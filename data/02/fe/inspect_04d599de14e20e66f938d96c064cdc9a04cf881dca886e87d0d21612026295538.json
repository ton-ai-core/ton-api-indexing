{
  "code": "b5ee9c72010264010007cc000114ff00f4a413f4bcf2c80b0102016202030202cc04050201201a1b02012006070201200e0f020120242502012008090201200a0b0201200c0d00393e11fe11be117e10fe10be107232fff2c1f33e1133c5b33333327b5520000f343e90353e900c20002d007232cffe0a33c5b25c083232c044fd003d0032c03260001b3e401c1d3232c0b281f2fff274200201201011020120161702012012130201201415003d3e10c4fc01883c01dde0063232c15633c59400fe8084b2daf333325c7ec020002335ce7cb819f4c1c07000fcb81a3534ffcc200011007c02562ebcb81a6000372964c830bfe38480b414c4ab5c6c25350c750c24b50c3880a97a16e00201201819002d4d0d4d430f84112f00a01f009f8424330f00df861f0048003d3e107c02be1094883c02fc0160827270e032140133c584b30073c5b27c022000933b68bb7ec8b5d97000238888be4000be4004aea4d6f6cc780075ce7cb81ab4c3cc2040406ebcb81abc00bcb81aa38640b40074007500b5092950cc3c0340750c00750c00a944bc0378a00201201c1d0201482223002db8b5d31f003f845d0d431d430d071c8cb0701cf16ccc980201201e1f02014820210015b4f47e007f087e00de00f00017ae9ff801fc23e86983ea1840001daf6bf801fc23686987e987fd201840001bb60b7e007f08ba0fe03a861f0890000db50d9e007f083001f743322c700925f03e0d0d3030171b0925f03e0fa4030f00302d31fd33f2282093a3ca6ba8e12345b82100510ff40bef2e066d3ffd430f00ce03321820a3cd52cba8e2f31f8445230c705f2e06401d430f00e8210d53276db708018c8cb055004cf1623fa0213cb6a12cb1fcb3fc98040fb00e032208210cb03bfafba826020120272800d48e3230f8445220c705f2e064820afaf08070fb028210d53276db708018c8cb055004cf1623fa0213cb6a12cb1fcb3fc98306fb00e08210693d3950ba8e26f846d08210a8cb00ad708010c8cb055005cf1624fa0214cb6a13cb1fcb3f01cf16c98040fb00e05b840ff2f00119221e3d039be87cb81af5c2ffe02900473b513434ffc07e1874c1c07e18b5007e18fe90007e1935007e1975007e19b5007e19f4600201c72a2b0201202c2d0201204a4b0201202e2f0201203c3d020120303102012036370201203233020120343500410e1254b628016fc636df30b61c6fe19c7f8e8d19631954f5d218ce28106be18a2000413c92216fe16fce3d2afca7c3aca45d10e5e1d1903fe79dfd549b18600323b7c2a000412b04ac54adb5437b7db87fc2373d926ddb3455784e7d91f44d0c5983c1cc87b5a000410526d4e74a28305ad88dc6f5bafb655c54075306c564211dadb5654e7b9c92a86002012038390201203a3b00413e6f4348078f15e0fd3977e7c5f5d61d417a0b0007960c5682eea515f6eaf01fe00041139f226107c6bea682dc41b23360b2e736ae1f2ac9d33186ee539ca6c9a8c451a0004107cc387c90de5176110fcc8a63a99629b3d93f0b138795b2ec3f4df9bf756be7a000412dfbdcbddd8301f96afb72bc36dd2a57e1eb141b22eaf15e45d4d6040547c386600201203e3f0201204445020120404102012042430041163a81eada1caddedfb9cdb455e771080bb9e288b3efe5e8082050af0463d915a00041033ed2411b5fc91088caf7eb13da9d48842f0809bf1c37b83a7eff511ff19b0f2000412a0b55af8a33479ec565a21ba52c9c9139b3f6079b73a0e8de242fde239b9fab2000412b466b46039f7156683b6652fdadab78382b0d79bc1deb6cad3eb5a5350e5bb1a00201204647020120484900411a7026bef2a1f6578b692fa5e728a570e195a0b7f562e9ef54471f102ccf0c802000412bc9e953d5087aa25544752426d41f39547aa22c6073abd51261f8bb8d09c06160004136b354771fae9458b017731834835d5d2017763a07d8bb3d79851dd790725689a000410c9c73124c98bdef3465ecc20fd915aec03169e9796144f012a825c61bf7dac5600201204c4d0201205a5b0201204e4f02012054550201205051020120525300413ee8a745d3d291599269536c1630915e4daddb3d5acd3a97e400e3b7303569a760004107c5c013022e6c980851802f902c24e93a3e7e6b0f93e8c21cd14ef202e770efe0004137036394a4ad9fabf4098f700c1a2b26a2c6a4122225fbbd419a2d3d3f45206a2000410f2003946b7df8b0272279a045e9e916ae8fb0ca48f406684a3ba5611585756f200201205657020120585900412725bce396275113929e99995a04bfe8ed9f9910430632b636c98b6fbdae50b0e0004118f939b4855228f5a4b965fdd0c446e9204c533179d034d198eb60fd1ef77118e00041132b8507aa832e81f3af722b0786cd94fb5c3db44e0247a859f665ab754969b5a00041247cc2769bb44e9a2d04e2bc8166036cd9ae1875f3bea688c175fe950d232c6da00201205c5d02014862630201205e5f020120606100413319f3ec0c7df03ce75a18abec64f8c965250a7e8a193af9a051f4ebc2f64cad600041067999a06a7a50296ddd3845a4bb26ccafcfd50def3d413751a63cb54e0670cd200041117958c6c8e399b60950abd4e8c0012da388b971a3d5de2b9f512d58718a98e4e00041141ae9ccd6f0c29613d6fd6a779909e34d406b6fa0d422c2b1117f91f57165dee00041372c457f2b3c9896bb269fbf1f42e0966fb062dc8d85968ee9bc1d90ddbf5e5f6000412924e95a1b53a326c469c2934ef9d6d61276d45b26d175be95e0954d4ab45f8ca0",
  "code_hash": "bbac2f6d5904eb04d3d78f17de7a5e26a19dd8eef5fda44103c964e9e190f9f4",
  "methods": [
    {
      "id": 85719,
      "method": "royalty_params"
    },
    {
      "id": 92067,
      "method": "get_nft_address_by_index"
    },
    {
      "id": 83263,
      "method": "get_nft_api_info"
    },
    {
      "id": 102491,
      "method": "get_collection_data"
    },
    {
      "id": 68445,
      "method": "get_nft_content"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "collection.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n\nglobal int storage::merkle_root;\nglobal int storage::merkle_depth;\nglobal cell storage::nft_item_code;\nglobal slice storage::owner;\nglobal cell storage::content;\nglobal cell storage::royalty;\nglobal int storage::last_index;\nglobal cell storage::api_data;\n\nconst int node_dict_key_len = 32;\n\nconst int error::not_owner = 100;\nconst int error::bad_proof = 101;\nconst int error::index_too_high = 102;\nconst int error::tree_full = 103;\nconst int error::malformed_updates = 104;\n\nconst int op::claim = \"op::claim\"c;\nconst int op::update = \"op::update\"c;\n\nconst int item_init_value = 50000000;\n\n() load_data() impure {\n    slice ds = get_data().begin_parse();\n\n    storage::merkle_root = ds~load_uint(256);\n    storage::merkle_depth = ds~load_uint(8);\n    storage::nft_item_code = ds~load_ref();\n    storage::owner = ds~load_msg_addr();\n    storage::content = ds~load_ref();\n    storage::royalty = ds~load_ref();\n    storage::last_index = ds~load_uint(256);\n    storage::api_data = ds~load_ref();\n\n    ds.end_parse();\n}\n\n() save_data() impure {\n    set_data(begin_cell()\n        .store_uint(storage::merkle_root, 256)\n        .store_uint(storage::merkle_depth, 8)\n        .store_ref(storage::nft_item_code)\n        .store_slice(storage::owner)\n        .store_ref(storage::content)\n        .store_ref(storage::royalty)\n        .store_uint(storage::last_index, 256)\n        .store_ref(storage::api_data)\n        .end_cell());\n}\n\nint hash_nodes(int a, int b) {\n    return begin_cell().store_uint(a, 256).store_uint(b, 256).end_cell().cell_hash();\n}\n\nint get_node(cell p, int i) {\n    (slice v, int ok) = p.udict_get?(node_dict_key_len, i);\n    throw_unless(101, ok);\n    return v.preload_uint(256);\n}\n\n(cell, ()) set_node(cell p, int i, int v) {\n    p~udict_set_builder(node_dict_key_len, i, begin_cell().store_uint(v, 256));\n    return (p, ());\n}\n\nint check_proof(int root, cell proof, int leaf, int leaf_index, int depth) {\n    int i = 0;\n    int cur = leaf;\n    while (i < depth) {\n        int is_right = (leaf_index >> i) & 1;\n        if (is_right) {\n            cur = hash_nodes(proof.get_node(i), cur);\n        } else {\n            cur = hash_nodes(cur, proof.get_node(i));\n        }\n        i += 1;\n    }\n    return cur == root;\n}\n\n(slice, cell) parse_nft_data(cell nft_data) {\n    slice ds = nft_data.begin_parse();\n    return (ds~load_msg_addr(), ds~load_ref());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n    cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n    return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(cell state_init) {\n    return begin_cell()\n        .store_uint(4, 3)\n        .store_int(workchain, 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\n() deploy_nft_item(int item_index, int amount, cell nft_message) impure {\n    cell state_init = calculate_nft_item_state_init(item_index, storage::nft_item_code);\n    slice nft_address = calculate_nft_item_address(state_init);\n    var msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(nft_address)\n        .store_coins(amount)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init)\n        .store_ref(nft_message);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() claim(int nft_index, cell nft_data, cell proof) impure {\n    throw_if(error::index_too_high, nft_index > storage::last_index);\n\n    throw_unless(error::bad_proof, check_proof(storage::merkle_root, proof, nft_data.cell_hash(), nft_index, storage::merkle_depth));\n\n    (slice owner, cell content) = nft_data.parse_nft_data();\n\n    deploy_nft_item(nft_index, item_init_value, begin_cell().store_slice(owner).store_ref(content).end_cell()); ;; inline the nft_data?\n}\n\n() update(cell updates, int new_last_index, cell hashes) impure {\n    throw_if(error::tree_full, storage::last_index >= ((1 << storage::merkle_depth) - 1));\n    throw_unless(error::malformed_updates, new_last_index > storage::last_index);\n\n    int cur_left = (storage::last_index + 1) + (1 << storage::merkle_depth);\n    int i = storage::merkle_depth;\n    int last_node_hash = -1;\n    cell verification_hashes = hashes;\n    int zero_hash = 0;\n    while (i > 0) {\n        (slice v, int ok) = updates.udict_get?(node_dict_key_len, i);\n        if (ok) {\n            int node_index = v~load_uint(256);\n            int leaf_node_index = node_index << (storage::merkle_depth - i);\n            throw_unless(error::malformed_updates, leaf_node_index == cur_left); ;; does this verify that node_index belongs to depth\n            cur_left = leaf_node_index + (1 << (storage::merkle_depth - i));\n\n            int new_hash = v~load_uint(256);\n            last_node_hash = node_index >> 1;\n            hashes~set_node(last_node_hash, hash_nodes(hashes.get_node(node_index - 1), new_hash));\n            verification_hashes~set_node(last_node_hash, hash_nodes(verification_hashes.get_node(node_index - 1), zero_hash));\n        } elseif (last_node_hash != -1) {\n            int new_last_node_hash = last_node_hash >> 1;\n            hashes~set_node(new_last_node_hash, hash_nodes(hashes.get_node(last_node_hash - 1), hashes.get_node(last_node_hash)));\n            verification_hashes~set_node(new_last_node_hash, hash_nodes(verification_hashes.get_node(last_node_hash - 1), verification_hashes.get_node(last_node_hash)));\n            last_node_hash = new_last_node_hash;\n        }\n        zero_hash = hash_nodes(zero_hash, zero_hash);\n\n        i -= 1;\n    }\n\n    throw_unless(error::malformed_updates, cur_left == (1 << (storage::merkle_depth + 1)));\n    throw_unless(error::malformed_updates, verification_hashes.get_node(1) == storage::merkle_root);\n\n    storage::merkle_root = hashes.get_node(1);\n    storage::last_index = new_last_index;\n\n    save_data();\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(to_address)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::report_royalty_params(), 32)\n        .store_uint(query_id, 64)\n        .store_slice(data);\n    send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) {\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    load_data();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::claim) {\n        slice proof_data = in_msg_body~load_ref().begin_parse();\n        claim(proof_data~load_uint(256), proof_data~load_ref(), proof_data~load_ref());\n        return ();\n    }\n\n    if (op == op::update) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        slice update_data = in_msg_body~load_ref().begin_parse();\n        update(update_data~load_ref(), update_data~load_uint(256), update_data~load_ref());\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 64);\n        return ();\n    }\n\n    if (op == op::withdraw) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        \n        raw_reserve(50000000, 0);\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 128);\n        return ();\n    }\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, storage::royalty.begin_parse());\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, cell, slice) get_collection_data() method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    return (-1, cs~load_ref(), storage::owner);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    load_data();\n    cell state_init = calculate_nft_item_state_init(index, storage::nft_item_code);\n    return calculate_nft_item_address(state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n    load_data();\n    slice rs = storage::royalty.begin_parse();\n    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    cs~load_ref();\n    slice common_content = cs~load_ref().begin_parse();\n    return (begin_cell()\n            .store_uint(1, 8) ;; offchain tag\n            .store_slice(common_content)\n            .store_ref(individual_nft_content)\n            .end_cell());\n}\n\nint get_merkle_root() method_id {\n    load_data();\n    return storage::merkle_root;\n}\n\n(int, cell) get_nft_api_info() method_id {\n    load_data();\n    slice cs = storage::api_data.begin_parse();\n    int version = cs~load_uint(8);\n    cell link = cs~load_ref();\n    return (version, link);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "item.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n;;\n;;  TON NFT Item Smart Contract\n;;\n\n{-\n\n    NOTE that this tokens can be transferred within the same workchain.\n\n    This is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\n\n    1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\n\n    2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\n\n-}\n\nint min_tons_for_storage() asm \"50000000 PUSHINT\"; ;; 0.05 TON\n\n;;\n;;  Storage\n;;\n;;  uint64 index\n;;  MsgAddressInt collection_address\n;;  MsgAddressInt owner_address\n;;  cell content\n;;\n\n(int, int, slice, slice, cell) load_data() {\n    slice ds = get_data().begin_parse();\n    var (index, collection_address) = (ds~load_uint(64), ds~load_msg_addr());\n    if (ds.slice_bits() > 0) {\n        return (-1, index, collection_address, ds~load_msg_addr(), ds~load_ref());\n    } else {  \n        return (0, index, collection_address, null(), null()); ;; nft not initialized yet\n    }\n}\n\n() store_data(int index, slice collection_address, slice owner_address, cell content) impure {\n    set_data(\n        begin_cell()\n            .store_uint(index, 64)\n            .store_slice(collection_address)\n            .store_slice(owner_address)\n            .store_ref(content)\n            .end_cell()\n    );\n}\n\n() send_msg(slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000\n        .store_slice(to_address)\n        .store_coins(amount)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op, 32)\n        .store_uint(query_id, 64);\n\n    if (~ null?(payload)) {\n        msg = msg.store_builder(payload);\n    }\n\n    send_raw_message(msg.end_cell(), send_mode);\n}\n\n() transfer_ownership(int my_balance, int index, slice collection_address, slice owner_address, cell content, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {\n    throw_unless(401, equal_slices(sender_address, owner_address));\n\n    slice new_owner_address = in_msg_body~load_msg_addr();\n    force_chain(new_owner_address);\n    slice response_destination = in_msg_body~load_msg_addr();\n    in_msg_body~load_int(1); ;; this nft don't use custom_payload\n    int forward_amount = in_msg_body~load_coins();\n    throw_unless(708, slice_bits(in_msg_body) >= 1);\n\n    int rest_amount = my_balance - min_tons_for_storage();\n    if (forward_amount) {\n        rest_amount -= (forward_amount + fwd_fees);\n    }\n    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00\n    if (need_response) {\n        rest_amount -= fwd_fees;\n    }\n\n    throw_unless(402, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response\n\n    if (forward_amount) {\n        send_msg(new_owner_address, forward_amount, op::ownership_assigned(), query_id, begin_cell().store_slice(owner_address).store_slice(in_msg_body), 1);  ;; paying fees, revert on errors\n    }\n    if (need_response) {\n        force_chain(response_destination);\n        send_msg(response_destination, rest_amount, op::excesses(), query_id, null(), 1); ;; paying fees, revert on errors\n    }\n\n    store_data(index, collection_address, new_owner_address, content);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n\n    cs~load_msg_addr(); ;; skip dst\n    cs~load_coins(); ;; skip value\n    cs~skip_bits(1); ;; skip extracurrency collection\n    cs~load_coins(); ;; skip ihr_fee\n    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\n\n\n    (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();\n    if (~ init?) {\n        throw_unless(405, equal_slices(collection_address, sender_address));\n        store_data(index, collection_address, in_msg_body~load_msg_addr(), in_msg_body~load_ref());\n        return ();\n    }\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::transfer()) {\n        transfer_ownership(my_balance, index, collection_address, owner_address, content, sender_address, query_id, in_msg_body, fwd_fee);\n        return ();\n    }\n    if (op == op::get_static_data()) {\n        send_msg(sender_address, 0, op::report_static_data(), query_id, begin_cell().store_uint(index, 256).store_slice(collection_address), 64);  ;; carry all the remaining value of the inbound message\n        return ();\n    }\n    throw(0xffff);\n}\n\n;;\n;;  GET Methods\n;;\n\n(int, int, slice, slice, cell) get_nft_data() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();\n    return (init?, index, collection_address, owner_address, content);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "collection_exotic_sbt.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n\nglobal int storage::merkle_root;\nglobal int storage::merkle_depth;\nglobal cell storage::nft_item_code;\nglobal slice storage::owner;\nglobal cell storage::content;\nglobal cell storage::royalty;\nglobal cell storage::api_data;\n\nconst int error::not_owner = 100;\nconst int error::bad_proof = 101;\nconst int error::value_too_low = 102;\nconst int error::not_exotic = 103;\nconst int error::not_merkle_proof = 104;\nconst int error::wrong_hash = 105;\nconst int error::bad_update = 106;\nconst int error::invalid_zero_hashes = 107;\n\nconst int op::claim = \"op::claim\"c;\nconst int op::update = \"op::update\"c;\nconst int op::withdraw = \"op::withdraw\"c;\n\nconst int item_init_value = 30000000;\nconst int minimum_claim_value = 85000000;\n\nconst int cell_type::merkle_proof = 3;\n\n(slice, int) begin_parse_exotic(cell x) asm \"XCTOS\";\n\ncell zero_hashes_dict() asm \" B{b5ee9c7241023b010004ab000201c71c010201200d020201200603020148050400412924e95a1b53a326c469c2934ef9d6d61276d45b26d175be95e0954d4ab45f8ca00041372c457f2b3c9896bb269fbf1f42e0966fb062dc8d85968ee9bc1d90ddbf5e5f600201200a0702012009080041141ae9ccd6f0c29613d6fd6a779909e34d406b6fa0d422c2b1117f91f57165dee00041117958c6c8e399b60950abd4e8c0012da388b971a3d5de2b9f512d58718a98e4e00201200c0b0041067999a06a7a50296ddd3845a4bb26ccafcfd50def3d413751a63cb54e0670cd2000413319f3ec0c7df03ce75a18abec64f8c965250a7e8a193af9a051f4ebc2f64cad60020120150e020120120f02012011100041247cc2769bb44e9a2d04e2bc8166036cd9ae1875f3bea688c175fe950d232c6da00041132b8507aa832e81f3af722b0786cd94fb5c3db44e0247a859f665ab754969b5a00201201413004118f939b4855228f5a4b965fdd0c446e9204c533179d034d198eb60fd1ef77118e000412725bce396275113929e99995a04bfe8ed9f9910430632b636c98b6fbdae50b0e00201201916020120181700410f2003946b7df8b0272279a045e9e916ae8fb0ca48f406684a3ba5611585756f20004137036394a4ad9fabf4098f700c1a2b26a2c6a4122225fbbd419a2d3d3f45206a200201201b1a004107c5c013022e6c980851802f902c24e93a3e7e6b0f93e8c21cd14ef202e770efe000413ee8a745d3d291599269536c1630915e4daddb3d5acd3a97e400e3b7303569a7600201202c1d020120251e020120221f020120212000410c9c73124c98bdef3465ecc20fd915aec03169e9796144f012a825c61bf7dac560004136b354771fae9458b017731834835d5d2017763a07d8bb3d79851dd790725689a0020120242300412bc9e953d5087aa25544752426d41f39547aa22c6073abd51261f8bb8d09c0616000411a7026bef2a1f6578b692fa5e728a570e195a0b7f562e9ef54471f102ccf0c80200201202926020120282700412b466b46039f7156683b6652fdadab78382b0d79bc1deb6cad3eb5a5350e5bb1a000412a0b55af8a33479ec565a21ba52c9c9139b3f6079b73a0e8de242fde239b9fab200201202b2a0041033ed2411b5fc91088caf7eb13da9d48842f0809bf1c37b83a7eff511ff19b0f200041163a81eada1caddedfb9cdb455e771080bb9e288b3efe5e8082050af0463d915a0020120342d020120312e020120302f00412dfbdcbddd8301f96afb72bc36dd2a57e1eb141b22eaf15e45d4d6040547c38660004107cc387c90de5176110fcc8a63a99629b3d93f0b138795b2ec3f4df9bf756be7a002012033320041139f226107c6bea682dc41b23360b2e736ae1f2ac9d33186ee539ca6c9a8c451a000413e6f4348078f15e0fd3977e7c5f5d61d417a0b0007960c5682eea515f6eaf01fe00201203835020120373600410526d4e74a28305ad88dc6f5bafb655c54075306c564211dadb5654e7b9c92a86000412b04ac54adb5437b7db87fc2373d926ddb3455784e7d91f44d0c5983c1cc87b5a00201203a3900413c92216fe16fce3d2afca7c3aca45d10e5e1d1903fe79dfd549b18600323b7c2a000410e1254b628016fc636df30b61c6fe19c7f8e8d19631954f5d218ce28106be18a205639ff04} B>boc PUSHREF \";\n\nint zero_hash(int depth) {\n    (slice data, int found) = zero_hashes_dict().udict_get?(8, depth);\n    throw_unless(error::invalid_zero_hashes, found);\n    \n    return data.preload_uint(256);\n}\n\n() load_data() impure {\n    slice ds = get_data().begin_parse();\n\n    storage::merkle_root = ds~load_uint(256);\n    storage::merkle_depth = ds~load_uint(8);\n    storage::nft_item_code = ds~load_ref();\n    storage::owner = ds~load_msg_addr();\n    storage::content = ds~load_ref();\n    storage::royalty = ds~load_ref();\n    storage::api_data = ds~load_ref();\n\n    ds.end_parse();\n}\n\n() save_data() impure {\n    set_data(begin_cell()\n        .store_uint(storage::merkle_root, 256)\n        .store_uint(storage::merkle_depth, 8)\n        .store_ref(storage::nft_item_code)\n        .store_slice(storage::owner)\n        .store_ref(storage::content)\n        .store_ref(storage::royalty)\n        .store_ref(storage::api_data)\n        .end_cell());\n}\n\n(slice, cell, slice) parse_nft_data(cell nft_data) {\n    slice ds = nft_data.begin_parse();\n    return (ds~load_msg_addr(), ds~load_ref(), ds~load_msg_addr());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n    cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n    return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(cell state_init) {\n    return begin_cell()\n        .store_uint(4, 3)\n        .store_int(workchain, 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\n() deploy_nft_item(int item_index, int amount, cell nft_message) impure {\n    cell state_init = calculate_nft_item_state_init(item_index, storage::nft_item_code);\n    slice nft_address = calculate_nft_item_address(state_init);\n    var msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(nft_address)\n        .store_coins(amount)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init)\n        .store_ref(nft_message);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n(cell, int) extract_merkle_proof(cell proof) impure {\n    (slice s, int is_exotic) = proof.begin_parse_exotic();\n    throw_unless(error::not_exotic, is_exotic);\n\n    int ty = s~load_uint(8);\n    throw_unless(error::not_merkle_proof, ty == cell_type::merkle_proof);\n\n    return (s~load_ref(), s~load_uint(256));\n}\n\ncell check_merkle_proof(cell proof, int expected_hash) impure {\n    (cell inner, int hash) = proof.extract_merkle_proof();\n    throw_unless(error::wrong_hash, hash == expected_hash);\n\n    return inner;\n}\n\ncell retrieve_child(cell c, int index, int depth) {\n    depth -= 1;\n    while (depth >= 0) {\n        slice s = c.begin_parse();\n        if ((index >> depth) & 1) {\n            s~load_ref();\n            c = s~load_ref();\n        } else {\n            c = s~load_ref();\n        }\n        depth -= 1;\n    }\n    return c;\n}\n\n() claim(int nft_index, cell proof) impure {\n    cell struct = proof.check_merkle_proof(storage::merkle_root);\n    cell nft_data = struct.retrieve_child(nft_index, storage::merkle_depth);\n\n    (slice owner, cell content, slice authority) = nft_data.parse_nft_data();\n\n    deploy_nft_item(nft_index, item_init_value, begin_cell().store_slice(owner).store_ref(content).store_slice(authority).end_cell());\n}\n\n() check_update(cell old, cell new, int depth) impure {\n    if (old.cell_depth() == 0) {\n        if (old.cell_hash() == new.cell_hash()) {\n            return ();\n        }\n\n        (slice s, int is_exotic) = old.begin_parse_exotic();\n        throw_unless(error::bad_update, is_exotic);\n\n        int ty_lvl = s~load_uint(16);\n        throw_unless(error::bad_update, ty_lvl == 0x0101);\n\n        int old_hash = s~load_uint(256);\n        throw_unless(error::bad_update, old_hash = zero_hash(depth));\n    } else {\n        slice s_old = old.begin_parse();\n        slice s_new = new.begin_parse();\n        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);\n        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);\n    }\n}\n\n() update(cell update) impure {\n    slice s = update.begin_parse();\n    cell old_merkle = s~load_ref();\n    cell new_merkle = s~load_ref();\n\n    cell old = old_merkle.check_merkle_proof(storage::merkle_root);\n    (cell new, int new_hash) = new_merkle.extract_merkle_proof();\n\n    check_update(old, new, storage::merkle_depth);\n\n    storage::merkle_root = new_hash;\n\n\n    save_data();\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(to_address)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::report_royalty_params(), 32)\n        .store_uint(query_id, 64)\n        .store_slice(data);\n    send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) {\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    load_data();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::claim) {\n        throw_unless(error::value_too_low, msg_value >= minimum_claim_value);\n\n        claim(in_msg_body~load_uint(256), in_msg_body~load_ref());\n        return ();\n    }\n\n    if (op == op::update) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        update(in_msg_body~load_ref());\n        \n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 64);\n        return ();\n    }\n\n    if (op == op::withdraw) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        \n        raw_reserve(50000000, 0);\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 128);\n        return ();\n    }\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, storage::royalty.begin_parse());\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, cell, slice) get_collection_data() method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    return (-1, cs~load_ref(), storage::owner);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    load_data();\n    cell state_init = calculate_nft_item_state_init(index, storage::nft_item_code);\n    return calculate_nft_item_address(state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n    load_data();\n    slice rs = storage::royalty.begin_parse();\n    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    cs~load_ref();\n    slice common_content = cs~load_ref().begin_parse();\n    return (begin_cell()\n            .store_uint(1, 8) ;; offchain tag\n            .store_slice(common_content)\n            .store_ref(individual_nft_content)\n            .end_cell());\n}\n\nint get_merkle_root() method_id {\n    load_data();\n    return storage::merkle_root;\n}\n\n(int, cell) get_nft_api_info() method_id {\n    load_data();\n    slice cs = storage::api_data.begin_parse();\n    int version = cs~load_uint(8);\n    cell link = cs~load_ref();\n    return (version, link);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "collection_exotic.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n\nglobal int storage::merkle_root;\nglobal int storage::merkle_depth;\nglobal cell storage::nft_item_code;\nglobal slice storage::owner;\nglobal cell storage::content;\nglobal cell storage::royalty;\nglobal cell storage::api_data;\n\nconst int error::not_owner = 100;\nconst int error::bad_proof = 101;\nconst int error::value_too_low = 102;\nconst int error::not_exotic = 103;\nconst int error::not_merkle_proof = 104;\nconst int error::wrong_hash = 105;\nconst int error::bad_update = 106;\nconst int error::invalid_zero_hashes = 107;\n\nconst int op::claim = \"op::claim\"c;\nconst int op::update = \"op::update\"c;\n\nconst int item_init_value = 30000000;\nconst int minimum_claim_value = 85000000;\n\nconst int cell_type::merkle_proof = 3;\n\n(slice, int) begin_parse_exotic(cell x) asm \"XCTOS\";\n\ncell zero_hashes_dict() asm \" B{b5ee9c7241023b010004ab000201c71c010201200d020201200603020148050400412924e95a1b53a326c469c2934ef9d6d61276d45b26d175be95e0954d4ab45f8ca00041372c457f2b3c9896bb269fbf1f42e0966fb062dc8d85968ee9bc1d90ddbf5e5f600201200a0702012009080041141ae9ccd6f0c29613d6fd6a779909e34d406b6fa0d422c2b1117f91f57165dee00041117958c6c8e399b60950abd4e8c0012da388b971a3d5de2b9f512d58718a98e4e00201200c0b0041067999a06a7a50296ddd3845a4bb26ccafcfd50def3d413751a63cb54e0670cd2000413319f3ec0c7df03ce75a18abec64f8c965250a7e8a193af9a051f4ebc2f64cad60020120150e020120120f02012011100041247cc2769bb44e9a2d04e2bc8166036cd9ae1875f3bea688c175fe950d232c6da00041132b8507aa832e81f3af722b0786cd94fb5c3db44e0247a859f665ab754969b5a00201201413004118f939b4855228f5a4b965fdd0c446e9204c533179d034d198eb60fd1ef77118e000412725bce396275113929e99995a04bfe8ed9f9910430632b636c98b6fbdae50b0e00201201916020120181700410f2003946b7df8b0272279a045e9e916ae8fb0ca48f406684a3ba5611585756f20004137036394a4ad9fabf4098f700c1a2b26a2c6a4122225fbbd419a2d3d3f45206a200201201b1a004107c5c013022e6c980851802f902c24e93a3e7e6b0f93e8c21cd14ef202e770efe000413ee8a745d3d291599269536c1630915e4daddb3d5acd3a97e400e3b7303569a7600201202c1d020120251e020120221f020120212000410c9c73124c98bdef3465ecc20fd915aec03169e9796144f012a825c61bf7dac560004136b354771fae9458b017731834835d5d2017763a07d8bb3d79851dd790725689a0020120242300412bc9e953d5087aa25544752426d41f39547aa22c6073abd51261f8bb8d09c0616000411a7026bef2a1f6578b692fa5e728a570e195a0b7f562e9ef54471f102ccf0c80200201202926020120282700412b466b46039f7156683b6652fdadab78382b0d79bc1deb6cad3eb5a5350e5bb1a000412a0b55af8a33479ec565a21ba52c9c9139b3f6079b73a0e8de242fde239b9fab200201202b2a0041033ed2411b5fc91088caf7eb13da9d48842f0809bf1c37b83a7eff511ff19b0f200041163a81eada1caddedfb9cdb455e771080bb9e288b3efe5e8082050af0463d915a0020120342d020120312e020120302f00412dfbdcbddd8301f96afb72bc36dd2a57e1eb141b22eaf15e45d4d6040547c38660004107cc387c90de5176110fcc8a63a99629b3d93f0b138795b2ec3f4df9bf756be7a002012033320041139f226107c6bea682dc41b23360b2e736ae1f2ac9d33186ee539ca6c9a8c451a000413e6f4348078f15e0fd3977e7c5f5d61d417a0b0007960c5682eea515f6eaf01fe00201203835020120373600410526d4e74a28305ad88dc6f5bafb655c54075306c564211dadb5654e7b9c92a86000412b04ac54adb5437b7db87fc2373d926ddb3455784e7d91f44d0c5983c1cc87b5a00201203a3900413c92216fe16fce3d2afca7c3aca45d10e5e1d1903fe79dfd549b18600323b7c2a000410e1254b628016fc636df30b61c6fe19c7f8e8d19631954f5d218ce28106be18a205639ff04} B>boc PUSHREF \";\n\nint zero_hash(int depth) {\n    (slice data, int found) = zero_hashes_dict().udict_get?(8, depth);\n    throw_unless(error::invalid_zero_hashes, found);\n\n    return data.preload_uint(256);\n}\n\n() load_data() impure {\n    slice ds = get_data().begin_parse();\n\n    storage::merkle_root = ds~load_uint(256);\n    storage::merkle_depth = ds~load_uint(8);\n    storage::nft_item_code = ds~load_ref();\n    storage::owner = ds~load_msg_addr();\n    storage::content = ds~load_ref();\n    storage::royalty = ds~load_ref();\n    storage::api_data = ds~load_ref();\n\n    ds.end_parse();\n}\n\n() save_data() impure {\n    set_data(begin_cell()\n        .store_uint(storage::merkle_root, 256)\n        .store_uint(storage::merkle_depth, 8)\n        .store_ref(storage::nft_item_code)\n        .store_slice(storage::owner)\n        .store_ref(storage::content)\n        .store_ref(storage::royalty)\n        .store_ref(storage::api_data)\n        .end_cell());\n}\n\n(slice, cell) parse_nft_data(cell nft_data) {\n    slice ds = nft_data.begin_parse();\n    return (ds~load_msg_addr(), ds~load_ref());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n    cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n    return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(cell state_init) {\n    return begin_cell()\n        .store_uint(4, 3)\n        .store_int(workchain, 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\n() deploy_nft_item(int item_index, int amount, cell nft_message) impure {\n    cell state_init = calculate_nft_item_state_init(item_index, storage::nft_item_code);\n    slice nft_address = calculate_nft_item_address(state_init);\n    var msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(nft_address)\n        .store_coins(amount)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init)\n        .store_ref(nft_message);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n(cell, int) extract_merkle_proof(cell proof) impure {\n    (slice s, int is_exotic) = proof.begin_parse_exotic();\n    throw_unless(error::not_exotic, is_exotic);\n\n    int ty = s~load_uint(8);\n    throw_unless(error::not_merkle_proof, ty == cell_type::merkle_proof);\n\n    return (s~load_ref(), s~load_uint(256));\n}\n\ncell check_merkle_proof(cell proof, int expected_hash) impure {\n    (cell inner, int hash) = proof.extract_merkle_proof();\n    throw_unless(error::wrong_hash, hash == expected_hash);\n\n    return inner;\n}\n\ncell retrieve_child(cell c, int index, int depth) {\n    depth -= 1;\n    while (depth >= 0) {\n        slice s = c.begin_parse();\n        if ((index >> depth) & 1) {\n            s~load_ref();\n            c = s~load_ref();\n        } else {\n            c = s~load_ref();\n        }\n        depth -= 1;\n    }\n    return c;\n}\n\n() claim(int nft_index, cell proof) impure {\n    cell struct = proof.check_merkle_proof(storage::merkle_root);\n    cell nft_data = struct.retrieve_child(nft_index, storage::merkle_depth);\n\n    (slice owner, cell content) = nft_data.parse_nft_data();\n\n    deploy_nft_item(nft_index, item_init_value, begin_cell().store_slice(owner).store_ref(content).end_cell());\n}\n\n() check_update(cell old, cell new, int depth) impure {\n    if (old.cell_depth() == 0) {\n        if (old.cell_hash() == new.cell_hash()) {\n            return ();\n        }\n\n        (slice s, int is_exotic) = old.begin_parse_exotic();\n        throw_unless(error::bad_update, is_exotic);\n\n        int ty_lvl = s~load_uint(16);\n        throw_unless(error::bad_update, ty_lvl == 0x0101);\n\n        int old_hash = s~load_uint(256);\n        throw_unless(error::bad_update, old_hash = zero_hash(depth));\n    } else {\n        slice s_old = old.begin_parse();\n        slice s_new = new.begin_parse();\n        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);\n        check_update(s_old~load_ref(), s_new~load_ref(), depth - 1);\n    }\n}\n\n() update(cell update) impure {\n    slice s = update.begin_parse();\n    cell old_merkle = s~load_ref();\n    cell new_merkle = s~load_ref();\n\n    cell old = old_merkle.check_merkle_proof(storage::merkle_root);\n    (cell new, int new_hash) = new_merkle.extract_merkle_proof();\n\n    check_update(old, new, storage::merkle_depth);\n\n    storage::merkle_root = new_hash;\n\n    save_data();\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(to_address)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::report_royalty_params(), 32)\n        .store_uint(query_id, 64)\n        .store_slice(data);\n    send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) {\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    load_data();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::claim) {\n        throw_unless(error::value_too_low, msg_value >= minimum_claim_value);\n\n        claim(in_msg_body~load_uint(256), in_msg_body~load_ref());\n        return ();\n    }\n\n    if (op == op::update) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        update(in_msg_body~load_ref());\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 64);\n        return ();\n    }\n\n    if (op == op::withdraw) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        \n        raw_reserve(50000000, 0);\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 128);\n        return ();\n    }\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, storage::royalty.begin_parse());\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, cell, slice) get_collection_data() method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    return (-1, cs~load_ref(), storage::owner);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    load_data();\n    cell state_init = calculate_nft_item_state_init(index, storage::nft_item_code);\n    return calculate_nft_item_address(state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n    load_data();\n    slice rs = storage::royalty.begin_parse();\n    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    cs~load_ref();\n    slice common_content = cs~load_ref().begin_parse();\n    return (begin_cell()\n            .store_uint(1, 8) ;; offchain tag\n            .store_slice(common_content)\n            .store_ref(individual_nft_content)\n            .end_cell());\n}\n\nint get_merkle_root() method_id {\n    load_data();\n    return storage::merkle_root;\n}\n\n(int, cell) get_nft_api_info() method_id {\n    load_data();\n    slice cs = storage::api_data.begin_parse();\n    int version = cs~load_uint(8);\n    cell link = cs~load_ref();\n    return (version, link);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "imports/params.fc",
        "content": "#include \"stdlib.fc\";\n\nconst int workchain = 0;\n\n() force_chain(slice addr) impure {\n    (int wc, _) = parse_std_addr(addr);\n    throw_unless(333, wc == workchain);\n}\n\nslice null_addr() asm \"b{00} PUSHSLICE\";\nint flag::regular() asm \"0x10 PUSHINT\";\nint flag::bounce() asm \"0x8 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\n{-\n  # Tuple manipulation primitives\n  The names and the types are mostly self-explaining.\n  See [polymorhism with forall](https://ton.org/docs/#/func/functions?id=polymorphism-with-forall)\n  for more info on the polymorphic functions.\n\n  Note that currently values of atomic type `tuple` can't be cast to composite tuple type (e.g. `[int, cell]`)\n  and vise versa.\n-}\n\n{-\n  # Lisp-style lists\n\n  Lists can be represented as nested 2-elements tuples.\n  Empty list is conventionally represented as TVM `null` value (it can be obtained by calling [null()]).\n  For example, tuple `(1, (2, (3, null)))` represents list `[1, 2, 3]`. Elements of a list can be of different types.\n-}\n\n;;; Adds an element to the beginning of lisp-style list.\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\n\n;;; Extracts the head and the tail of lisp-style list.\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\n\n;;; Extracts the tail and the head of lisp-style list.\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\n\n;;; Returns the head of lisp-style list.\nforall X -> X car(tuple list) asm \"CAR\";\n\n;;; Returns the tail of lisp-style list.\ntuple cdr(tuple list) asm \"CDR\";\n\n;;; Creates tuple with zero elements.\ntuple empty_tuple() asm \"NIL\";\n\n;;; Appends a value `x` to a `Tuple t = (x1, ..., xn)`, but only if the resulting `Tuple t' = (x1, ..., xn, x)`\n;;; is of length at most 255. Otherwise throws a type check exception.\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\n\n;;; Creates a tuple of length one with given argument as element.\nforall X -> [X] single(X x) asm \"SINGLE\";\n\n;;; Unpacks a tuple of length one\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\n\n;;; Creates a tuple of length two with given arguments as elements.\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\n\n;;; Unpacks a tuple of length two\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\n\n;;; Creates a tuple of length three with given arguments as elements.\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\n\n;;; Unpacks a tuple of length three\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\n\n;;; Creates a tuple of length four with given arguments as elements.\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\n\n;;; Unpacks a tuple of length four\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\n\n;;; Returns the first element of a tuple (with unknown element types).\nforall X -> X first(tuple t) asm \"FIRST\";\n\n;;; Returns the second element of a tuple (with unknown element types).\nforall X -> X second(tuple t) asm \"SECOND\";\n\n;;; Returns the third element of a tuple (with unknown element types).\nforall X -> X third(tuple t) asm \"THIRD\";\n\n;;; Returns the fourth element of a tuple (with unknown element types).\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\n\n;;; Returns the first element of a pair tuple.\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\n\n;;; Returns the second element of a pair tuple.\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\n\n;;; Returns the first element of a triple tuple.\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\n\n;;; Returns the second element of a triple tuple.\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\n\n;;; Returns the third element of a triple tuple.\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\n\n\n;;; Push null element (casted to given type)\n;;; By the TVM type `Null` FunC represents absence of a value of some atomic type.\n;;; So `null` can actually have any atomic type.\nforall X -> X null() asm \"PUSHNULL\";\n\n;;; Moves a variable [x] to the top of the stack\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\n\n\n;;; Returns the current Unix time as an Integer\nint now() asm \"NOW\";\n\n;;; Returns the internal address of the current smart contract as a Slice with a `MsgAddressInt`.\n;;; If necessary, it can be parsed further using primitives such as [parse_std_addr].\nslice my_address() asm \"MYADDR\";\n\n;;; Returns the balance of the smart contract as a tuple consisting of an int\n;;; (balance in nanotoncoins) and a `cell`\n;;; (a dictionary with 32-bit keys representing the balance of \"extra currencies\")\n;;; at the start of Computation Phase.\n;;; Note that RAW primitives such as [send_raw_message] do not update this field.\n[int, cell] get_balance() asm \"BALANCE\";\n\n;;; Returns the logical time of the current transaction.\nint cur_lt() asm \"LTIME\";\n\n;;; Returns the starting logical time of the current block.\nint block_lt() asm \"BLOCKLT\";\n\n;;; Computes the representation hash of a `cell` [c] and returns it as a 256-bit unsigned integer `x`.\n;;; Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.\nint cell_hash(cell c) asm \"HASHCU\";\n\n;;; Computes the hash of a `slice s` and returns it as a 256-bit unsigned integer `x`.\n;;; The result is the same as if an ordinary cell containing only data and references from `s` had been created\n;;; and its hash computed by [cell_hash].\nint slice_hash(slice s) asm \"HASHSU\";\n\n;;; Computes sha256 of the data bits of `slice` [s]. If the bit length of `s` is not divisible by eight,\n;;; throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer `x`.\nint string_hash(slice s) asm \"SHA256U\";\n\n{-\n  # Signature checks\n-}\n\n;;; Checks the Ed25519-`signature` of a `hash` (a 256-bit unsigned integer, usually computed as the hash of some data)\n;;; using [public_key] (also represented by a 256-bit unsigned integer).\n;;; The signature must contain at least 512 data bits; only the first 512 bits are used.\n;;; The result is `−1` if the signature is valid, `0` otherwise.\n;;; Note that `CHKSIGNU` creates a 256-bit slice with the hash and calls `CHKSIGNS`.\n;;; That is, if [hash] is computed as the hash of some data, these data are hashed twice,\n;;; the second hashing occurring inside `CHKSIGNS`.\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\n\n;;; Checks whether [signature] is a valid Ed25519-signature of the data portion of `slice data` using `public_key`,\n;;; similarly to [check_signature].\n;;; If the bit length of [data] is not divisible by eight, throws a cell underflow exception.\n;;; The verification of Ed25519 signatures is the standard one,\n;;; with sha256 used to reduce [data] to the 256-bit number that is actually signed.\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n{---\n  # Computation of boc size\n  The primitives below may be useful for computing storage fees of user-provided data.\n-}\n\n;;; Returns `(x, y, z, -1)` or `(null, null, null, 0)`.\n;;; Recursively computes the count of distinct cells `x`, data bits `y`, and cell references `z`\n;;; in the DAG rooted at `cell` [c], effectively returning the total storage used by this DAG taking into account\n;;; the identification of equal cells.\n;;; The values of `x`, `y`, and `z` are computed by a depth-first traversal of this DAG,\n;;; with a hash table of visited cell hashes used to prevent visits of already-visited cells.\n;;; The total count of visited cells `x` cannot exceed non-negative [max_cells];\n;;; otherwise the computation is aborted before visiting the `(max_cells + 1)`-st cell and\n;;; a zero flag is returned to indicate failure. If [c] is `null`, returns `x = y = z = 0`.\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n\n;;; Similar to [compute_data_size?], but accepting a `slice` [s] instead of a `cell`.\n;;; The returned value of `x` does not take into account the cell that contains the `slice` [s] itself;\n;;; however, the data bits and the cell references of [s] are accounted for in `y` and `z`.\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n\n;;; A non-quiet version of [compute_data_size?] that throws a cell overflow exception (`8`) on failure.\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; A non-quiet version of [slice_compute_data_size?] that throws a cell overflow exception (8) on failure.\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; Throws an exception with exit_code excno if cond is not 0 (commented since implemented in compilator)\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n{--\n  # Debug primitives\n  Only works for local TVM execution with debug level verbosity\n-}\n;;; Dumps the stack (at most the top 255 values) and shows the total stack depth.\n() dump_stack() impure asm \"DUMPSTK\";\n\n{-\n  # Persistent storage save and load\n-}\n\n;;; Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.\ncell get_data() asm \"c4 PUSH\";\n\n;;; Sets `cell` [c] as persistent contract data. You can update persistent contract storage with this primitive.\n() set_data(cell c) impure asm \"c4 POP\";\n\n{-\n  # Continuation primitives\n-}\n;;; Usually `c3` has a continuation initialized by the whole code of the contract. It is used for function calls.\n;;; The primitive returns the current value of `c3`.\ncont get_c3() impure asm \"c3 PUSH\";\n\n;;; Updates the current value of `c3`. Usually, it is used for updating smart contract code in run-time.\n;;; Note that after execution of this primitive the current code\n;;; (and the stack of recursive function calls) won't change,\n;;; but any other function call will use a function from the new code.\n() set_c3(cont c) impure asm \"c3 POP\";\n\n;;; Transforms a `slice` [s] into a simple ordinary continuation `c`, with `c.code = s` and an empty stack and savelist.\ncont bless(slice s) impure asm \"BLESS\";\n\n{---\n  # Gas related primitives\n-}\n\n;;; Sets current gas limit `gl` to its maximal allowed value `gm`, and resets the gas credit `gc` to zero,\n;;; decreasing the value of `gr` by `gc` in the process.\n;;; In other words, the current smart contract agrees to buy some gas to finish the current transaction.\n;;; This action is required to process external messages, which bring no value (hence no gas) with themselves.\n;;;\n;;; For more details check [accept_message effects](https://ton.org/docs/#/smart-contracts/accept).\n() accept_message() impure asm \"ACCEPT\";\n\n;;; Sets current gas limit `gl` to the minimum of limit and `gm`, and resets the gas credit `gc` to zero.\n;;; If the gas consumed so far (including the present instruction) exceeds the resulting value of `gl`,\n;;; an (unhandled) out of gas exception is thrown before setting new gas limits.\n;;; Notice that [set_gas_limit] with an argument `limit ≥ 2^63 − 1` is equivalent to [accept_message].\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n\n;;; Commits the current state of registers `c4` (“persistent data”) and `c5` (“actions”)\n;;; so that the current execution is considered “successful” with the saved values even if an exception\n;;; in Computation Phase is thrown later.\n() commit() impure asm \"COMMIT\";\n\n;;; Not implemented\n;;() buy_gas(int gram) impure asm \"BUYGAS\";\n\n;;; Computes the amount of gas that can be bought for `amount` nanoTONs,\n;;; and sets `gl` accordingly in the same way as [set_gas_limit].\n() buy_gas(int amount) impure asm \"BUYGAS\";\n\n;;; Computes the minimum of two integers [x] and [y].\nint min(int x, int y) asm \"MIN\";\n\n;;; Computes the maximum of two integers [x] and [y].\nint max(int x, int y) asm \"MAX\";\n\n;;; Sorts two integers.\n(int, int) minmax(int x, int y) asm \"MINMAX\";\n\n;;; Computes the absolute value of an integer [x].\nint abs(int x) asm \"ABS\";\n\n{-\n  # Slice primitives\n\n  It is said that a primitive _loads_ some data,\n  if it returns the data and the remainder of the slice\n  (so it can also be used as [modifying method](https://ton.org/docs/#/func/statements?id=modifying-methods)).\n\n  It is said that a primitive _preloads_ some data, if it returns only the data\n  (it can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods)).\n\n  Unless otherwise stated, loading and preloading primitives read the data from a prefix of the slice.\n-}\n\n\n;;; Converts a `cell` [c] into a `slice`. Notice that [c] must be either an ordinary cell,\n;;; or an exotic cell (see [TVM.pdf](https://ton-blockchain.github.io/docs/tvm.pdf), 3.1.2)\n;;; which is automatically loaded to yield an ordinary cell `c'`, converted into a `slice` afterwards.\nslice begin_parse(cell c) asm \"CTOS\";\n\n;;; Checks if [s] is empty. If not, throws an exception.\n() end_parse(slice s) impure asm \"ENDS\";\n\n;;; Loads the first reference from the slice.\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\n\n;;; Preloads the first reference from the slice.\ncell preload_ref(slice s) asm \"PLDREF\";\n\n  {- Functions below are commented because are implemented on compilator level for optimisation -}\n\n;;; Loads a signed [len]-bit integer from a slice [s].\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n\n;;; Loads an unsigned [len]-bit integer from a slice [s].\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n\n;;; Preloads a signed [len]-bit integer from a slice [s].\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n\n;;; Preloads an unsigned [len]-bit integer from a slice [s].\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n\n;;; Loads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n\n;;; Preloads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n\n;;; Loads serialized amount of TonCoins (any unsigned integer up to `2^128 - 1`).\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDGRAMS\";\n\n;;; Returns all but the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n\n;;; Returns the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\n\n;;; Returns all but the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n\n;;; Returns the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n\n;;; Loads a dictionary `D` (HashMapE) from `slice` [s].\n;;; (returns `null` if `nothing` constructor is used).\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\n\n;;; Preloads a dictionary `D` from `slice` [s].\ncell preload_dict(slice s) asm \"PLDDICT\";\n\n;;; Loads a dictionary as [load_dict], but returns only the remainder of the slice.\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n;;; Loads (Maybe ^Cell) from `slice` [s].\n;;; In other words loads 1 bit and if it is true\n;;; loads first ref and return it with slice remainder\n;;; otherwise returns `null` and slice remainder\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\n\n;;; Preloads (Maybe ^Cell) from `slice` [s].\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\n\n\n;;; Returns the depth of `cell` [c].\n;;; If [c] has no references, then return `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [c].\n;;; If [c] is a `null` instead of a cell, returns zero.\nint cell_depth(cell c) asm \"CDEPTH\";\n\n\n{-\n  # Slice size primitives\n-}\n\n;;; Returns the number of references in `slice` [s].\nint slice_refs(slice s) asm \"SREFS\";\n\n;;; Returns the number of data bits in `slice` [s].\nint slice_bits(slice s) asm \"SBITS\";\n\n;;; Returns both the number of data bits and the number of references in `slice` [s].\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\n\n;;; Checks whether a `slice` [s] is empty (i.e., contains no bits of data and no cell references).\nint slice_empty?(slice s) asm \"SEMPTY\";\n\n;;; Checks whether `slice` [s] has no bits of data.\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\n\n;;; Checks whether `slice` [s] has no references.\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\n\n;;; Returns the depth of `slice` [s].\n;;; If [s] has no references, then returns `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [s].\nint slice_depth(slice s) asm \"SDEPTH\";\n\n{-\n  # Builder size primitives\n-}\n\n;;; Returns the number of cell references already stored in `builder` [b]\nint builder_refs(builder b) asm \"BREFS\";\n\n;;; Returns the number of data bits already stored in `builder` [b].\nint builder_bits(builder b) asm \"BBITS\";\n\n;;; Returns the depth of `builder` [b].\n;;; If no cell references are stored in [b], then returns 0;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [b].\nint builder_depth(builder b) asm \"BDEPTH\";\n\n{-\n  # Builder primitives\n  It is said that a primitive _stores_ a value `x` into a builder `b`\n  if it returns a modified version of the builder `b'` with the value `x` stored at the end of it.\n  It can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods).\n\n  All the primitives below first check whether there is enough space in the `builder`,\n  and only then check the range of the value being serialized.\n-}\n\n;;; Creates a new empty `builder`.\nbuilder begin_cell() asm \"NEWC\";\n\n;;; Converts a `builder` into an ordinary `cell`.\ncell end_cell(builder b) asm \"ENDC\";\n\n;;; Stores a reference to `cell` [c] into `builder` [b].\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n\n;;; Stores an unsigned [len]-bit integer `x` into `b` for `0 ≤ len ≤ 256`.\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n\n;;; Stores a signed [len]-bit integer `x` into `b` for` 0 ≤ len ≤ 257`.\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\n\n\n;;; Stores `slice` [s] into `builder` [b]\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\n\n;;; Stores (serializes) an integer [x] in the range `0..2^128 − 1` into `builder` [b].\n;;; The serialization of [x] consists of a 4-bit unsigned big-endian integer `l`,\n;;; which is the smallest integer `l ≥ 0`, such that `x < 2^8l`,\n;;; followed by an `8l`-bit unsigned big-endian representation of [x].\n;;; If [x] does not belong to the supported range, a range check exception is thrown.\n;;;\n;;; Store amounts of TonCoins to the builder as VarUInteger 16\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_coins(builder b, int x) asm \"STGRAMS\";\n\n;;; Stores dictionary `D` represented by `cell` [c] or `null` into `builder` [b].\n;;; In other words, stores a `1`-bit and a reference to [c] if [c] is not `null` and `0`-bit otherwise.\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n;;; Stores (Maybe ^Cell) to builder:\n;;; if cell is null store 1 zero bit\n;;; otherwise store 1 true bit and ref to cell\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\n\n{-\n  # Address manipulation primitives\n  The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme:\n  ```TL-B\n  addr_none$00 = MsgAddressExt;\n  addr_extern$01 len:(## 8) external_address:(bits len)\n               = MsgAddressExt;\n  anycast_info$_ depth:(#<= 30) { depth >= 1 }\n    rewrite_pfx:(bits depth) = Anycast;\n  addr_std$10 anycast:(Maybe Anycast)\n    workchain_id:int8 address:bits256 = MsgAddressInt;\n  addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)\n    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;\n  _ _:MsgAddressInt = MsgAddress;\n  _ _:MsgAddressExt = MsgAddress;\n\n  int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n    src:MsgAddress dest:MsgAddressInt\n    value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ```\n  A deserialized `MsgAddress` is represented by a tuple `t` as follows:\n\n  - `addr_none` is represented by `t = (0)`,\n    i.e., a tuple containing exactly one integer equal to zero.\n  - `addr_extern` is represented by `t = (1, s)`,\n    where slice `s` contains the field `external_address`. In other words, `\n    t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`.\n  - `addr_std` is represented by `t = (2, u, x, s)`,\n    where `u` is either a `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if anycast is present).\n    Next, integer `x` is the `workchain_id`, and slice `s` contains the address.\n  - `addr_var` is represented by `t = (3, u, x, s)`,\n    where `u`, `x`, and `s` have the same meaning as for `addr_std`.\n-}\n\n;;; Loads from slice [s] the only prefix that is a valid `MsgAddress`,\n;;; and returns both this prefix `s'` and the remainder `s''` of [s] as slices.\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\n\n;;; Decomposes slice [s] containing a valid `MsgAddress` into a `tuple t` with separate fields of this `MsgAddress`.\n;;; If [s] is not a valid `MsgAddress`, a cell deserialization exception is thrown.\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n\n;;; Parses slice [s] containing a valid `MsgAddressInt` (usually a `msg_addr_std`),\n;;; applies rewriting from the anycast (if present) to the same-length prefix of the address,\n;;; and returns both the workchain and the 256-bit address as integers.\n;;; If the address is not 256-bit, or if [s] is not a valid serialization of `MsgAddressInt`,\n;;; throws a cell deserialization exception.\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n\n;;; A variant of [parse_std_addr] that returns the (rewritten) address as a slice [s],\n;;; even if it is not exactly 256 bit long (represented by a `msg_addr_var`).\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\n{-\n  # Dictionary primitives\n-}\n\n\n;;; Sets the value associated with [key_len]-bit key signed index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n\n;;; Sets the value associated with [key_len]-bit key unsigned index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\n\n;;; Creates an empty dictionary, which is actually a null value. Equivalent to PUSHNULL\ncell new_dict() asm \"NEWDICT\";\n;;; Checks whether a dictionary is empty. Equivalent to cell_null?.\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n\n{- Prefix dictionary primitives -}\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\n;;; Returns the value of the global configuration parameter with integer index `i` as a `cell` or `null` value.\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\n;;; Checks whether c is a null. Note, that FunC also has polymorphic null? built-in.\nint cell_null?(cell c) asm \"ISNULL\";\n\n;;; Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if mode = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b − amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means `amount <- -amount` before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently, amount must be a non-negative integer, and mode must be in the range 0..15.\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n;;; Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n;;; Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smart contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n;;; Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract\n() set_code(cell new_code) impure asm \"SETCODE\";\n\n;;; Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.\nint random() impure asm \"RANDU256\";\n;;; Generates a new pseudo-random integer z in the range 0..range−1 (or range..−1, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.\nint rand(int range) impure asm \"RAND\";\n;;; Returns the current random seed as an unsigned 256-bit Integer.\nint get_seed() impure asm \"RANDSEED\";\n;;; Sets the random seed to unsigned 256-bit seed.\n() set_seed(int x) impure asm \"SETRAND\";\n;;; Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.\n() randomize(int x) impure asm \"ADDRAND\";\n;;; Equivalent to randomize(cur_lt());.\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n;;; Checks whether the data parts of two slices coinside\nint equal_slice_bits(slice a, slice b) asm \"SDEQ\";\nint equal_slices(slice a, slice b) asm \"SDEQ\";\n\n;;; Concatenates two builders\nbuilder store_builder(builder to, builder from) asm \"STBR\";\nint builder_null?(builder b) asm \"ISNULL\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "sbt_item.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n;;\n;;  TON SBT Item Smart Contract\n;;\n\nint min_tons_for_storage() asm \"50000000 PUSHINT\"; ;; 0.05 TON\n\n;;\n;;  Storage\n;;\n;;  uint64 index\n;;  MsgAddressInt collection_address\n;;  MsgAddressInt owner_address\n;;  cell content\n;;  MsgAddressInt authority_address\n;;  uint64 revoked_at\n;;\n\nglobal int storage::index;\nglobal int init?;\nglobal slice storage::collection_address;\nglobal slice storage::owner_address;\nglobal slice storage::authority_address;\nglobal cell storage::content;\nglobal int storage::revoked_at;\n\n() load_data() impure {\n    slice ds = get_data().begin_parse();\n\n    storage::index              = ds~load_uint(64);\n    storage::collection_address = ds~load_msg_addr();\n    init?                       = false;\n\n    if (ds.slice_bits() > 0) {\n        init?                      = true;\n        storage::owner_address     = ds~load_msg_addr();\n        storage::content           = ds~load_ref();\n        storage::authority_address = ds~load_msg_addr();\n        storage::revoked_at        = ds~load_uint(64);\n    }\n}\n\n() store_data() impure {\n    set_data(\n            begin_cell()\n                    .store_uint(storage::index, 64)\n                    .store_slice(storage::collection_address)\n                    .store_slice(storage::owner_address)\n                    .store_ref(storage::content)\n                    .store_slice(storage::authority_address)\n                    .store_uint(storage::revoked_at, 64)\n                    .end_cell()\n    );\n}\n\n() send_msg(int flag, slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {\n    var body = begin_cell().store_uint(op, 32).store_uint(query_id, 64);\n    if (~ builder_null?(payload)) {\n        body = body.store_builder(payload);\n    }\n\n    var msg = begin_cell()\n            .store_uint(flag, 6)\n            .store_slice(to_address)\n            .store_coins(amount)\n            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_ref(body.end_cell());\n\n    send_raw_message(msg.end_cell(), send_mode);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    slice sender_address = cs~load_msg_addr();\n\n    load_data();\n\n    if (~ init?) {\n        throw_unless(405, equal_slices(storage::collection_address, sender_address));\n\n        storage::owner_address     = in_msg_body~load_msg_addr();\n        storage::content           = in_msg_body~load_ref();\n        storage::authority_address = in_msg_body~load_msg_addr();\n        storage::revoked_at        = 0;\n\n        store_data();\n        return ();\n    }\n\n    int op = in_msg_body~load_uint(32);\n\n    if (flags & 1) { ;; route all prove_ownership bounced messages to owner\n        ;; first op was 0xffffffff, because of bounced, now we need to read real one\n        op = in_msg_body~load_uint(32);\n\n        if (op == op::ownership_proof()) {\n            int query_id = in_msg_body~load_uint(64);\n            ;; mode 64 = carry all the remaining value of the inbound message\n            send_msg(flag::regular(), storage::owner_address, 0, op::ownership_proof_bounced(), query_id, null(), 64);\n        }\n        return ();\n    }\n\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::request_owner()) {\n        slice dest = in_msg_body~load_msg_addr();\n        cell body = in_msg_body~load_ref();\n        int with_content = in_msg_body~load_uint(1);\n\n        var msg = begin_cell()\n                .store_uint(storage::index, 256)\n                .store_slice(sender_address)\n                .store_slice(storage::owner_address)\n                .store_ref(body)\n                .store_uint(storage::revoked_at, 64)\n                .store_uint(with_content, 1);\n\n        if (with_content != 0) {\n            msg = msg.store_ref(storage::content);\n        }\n\n        ;; mode 64 = carry all the remaining value of the inbound message\n        send_msg(flag::regular() | flag::bounce(), dest, 0, op::owner_info(), query_id, msg, 64);\n        return ();\n    }\n    if (op == op::prove_ownership()) {\n        throw_unless(401, equal_slices(storage::owner_address, sender_address));\n\n        slice dest = in_msg_body~load_msg_addr();\n        cell body = in_msg_body~load_ref();\n        int with_content = in_msg_body~load_uint(1);\n\n        var msg = begin_cell()\n                .store_uint(storage::index, 256)\n                .store_slice(storage::owner_address)\n                .store_ref(body)\n                .store_uint(storage::revoked_at, 64)\n                .store_uint(with_content, 1);\n\n        if (with_content != 0) {\n            msg = msg.store_ref(storage::content);\n        }\n\n        ;; mode 64 = carry all the remaining value of the inbound message\n        send_msg(flag::regular() | flag::bounce(), dest, 0, op::ownership_proof(), query_id, msg, 64);\n        return ();\n    }\n    if (op == op::get_static_data()) {\n        var msg = begin_cell().store_uint(storage::index, 256).store_slice(storage::collection_address);\n\n        ;; mode 64 = carry all the remaining value of the inbound message\n        send_msg(flag::regular(), sender_address, 0, op::report_static_data(), query_id, msg, 64);\n        return ();\n    }\n    if (op == op::destroy()) {\n        throw_unless(401, equal_slices(storage::owner_address, sender_address));\n\n        send_msg(flag::regular(), sender_address, 0, op::excesses(), query_id, null(), 128);\n\n        storage::owner_address = null_addr();\n        storage::authority_address = null_addr();\n        store_data();\n        return ();\n    }\n    if (op == op::revoke()) {\n        throw_unless(401, equal_slices(storage::authority_address, sender_address));\n        throw_unless(403, storage::revoked_at == 0);\n\n        storage::revoked_at = now();\n        store_data();\n        return ();\n    }\n    if (op == op::take_excess()) {\n        throw_unless(401, equal_slices(storage::owner_address, sender_address));\n\n        ;; reserve amount for storage\n        raw_reserve(min_tons_for_storage(), 0);\n\n        send_msg(flag::regular(), sender_address, 0, op::excesses(), query_id, null(), 128);\n        return ();\n    }\n    if (op == op::transfer()) {\n        throw(413);\n    }\n    throw(0xffff);\n}\n\n;;\n;;  GET Methods\n;;\n\n(int, int, slice, slice, cell) get_nft_data() method_id {\n    load_data();\n    return (init?, storage::index, storage::collection_address, storage::owner_address, storage::content);\n}\n\nslice get_authority_address() method_id {\n    load_data();\n    return storage::authority_address;\n}\n\nint get_revoked_time() method_id {\n    load_data();\n    return storage::revoked_at;\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "collection_new.fc",
        "content": "#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/op-codes.fc\";\n\n\nglobal int storage::merkle_root;\nglobal int storage::merkle_depth;\nglobal cell storage::nft_item_code;\nglobal slice storage::owner;\nglobal cell storage::content;\nglobal cell storage::royalty;\nglobal cell storage::api_data;\n\nconst int error::not_owner = 100;\nconst int error::bad_proof = 101;\nconst int error::value_too_low = 102;\n\nconst int op::claim = \"op::claim\"c;\nconst int op::update = \"op::update\"c;\n\nconst int item_init_value = 30000000;\nconst int minimum_claim_value = 85000000;\n\n() load_data() impure {\n    slice ds = get_data().begin_parse();\n\n    storage::merkle_root = ds~load_uint(256);\n    storage::merkle_depth = ds~load_uint(8);\n    storage::nft_item_code = ds~load_ref();\n    storage::owner = ds~load_msg_addr();\n    storage::content = ds~load_ref();\n    storage::royalty = ds~load_ref();\n    storage::api_data = ds~load_ref();\n\n    ds.end_parse();\n}\n\n() save_data() impure {\n    set_data(begin_cell()\n        .store_uint(storage::merkle_root, 256)\n        .store_uint(storage::merkle_depth, 8)\n        .store_ref(storage::nft_item_code)\n        .store_slice(storage::owner)\n        .store_ref(storage::content)\n        .store_ref(storage::royalty)\n        .store_ref(storage::api_data)\n        .end_cell());\n}\n\nint hash_nodes(int a, int b) {\n    return begin_cell().store_uint(a, 256).store_uint(b, 256).end_cell().cell_hash();\n}\n\nint check_proof(int root, cell proof, int leaf, int leaf_index, int depth) {\n    int i = 0;\n    int cur = leaf;\n    slice ps = proof.begin_parse();\n    while (i < depth) {\n        int is_right = (leaf_index >> i) & 1;\n        if (is_right) {\n            cur = hash_nodes(ps.preload_uint(256), cur);\n        } else {\n            cur = hash_nodes(cur, ps.preload_uint(256));\n        }\n        ps = ps.preload_ref().begin_parse();\n        i += 1;\n    }\n    return cur == root;\n}\n\n(slice, cell) parse_nft_data(cell nft_data) {\n    slice ds = nft_data.begin_parse();\n    return (ds~load_msg_addr(), ds~load_ref());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n    cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n    return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(cell state_init) {\n    return begin_cell()\n        .store_uint(4, 3)\n        .store_int(workchain, 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\n() deploy_nft_item(int item_index, int amount, cell nft_message) impure {\n    cell state_init = calculate_nft_item_state_init(item_index, storage::nft_item_code);\n    slice nft_address = calculate_nft_item_address(state_init);\n    var msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(nft_address)\n        .store_coins(amount)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init)\n        .store_ref(nft_message);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() claim(int nft_index, cell nft_data, cell proof) impure {\n    throw_unless(error::bad_proof, check_proof(storage::merkle_root, proof, nft_data.cell_hash(), nft_index, storage::merkle_depth));\n\n    (slice owner, cell content) = nft_data.parse_nft_data();\n\n    deploy_nft_item(nft_index, item_init_value, begin_cell().store_slice(owner).store_ref(content).end_cell());\n}\n\n(int, int) process_update(cell update, tuple zh, int depth) {\n    slice cs = update.begin_parse();\n    int leaf = cs~load_int(1);\n    if (leaf) {\n        int proof = cs~load_int(1);\n        int hash = cs~load_uint(256);\n        if (proof) {\n            return (hash, hash);\n        } else { ;; update\n            return (zh.at(depth), hash);\n        }\n    } else {\n        (int old_left, int new_left) = process_update(cs~load_ref(), zh, depth - 1);\n        (int old_right, int new_right) = process_update(cs~load_ref(), zh, depth - 1);\n        return (hash_nodes(old_left, old_right), hash_nodes(new_left, new_right));\n    }\n}\n\n() update(cell update) impure {\n    tuple zh = empty_tuple();\n    zh~tpush(0);\n    int i = 0;\n    while (i < storage::merkle_depth - 1) {\n        int prev = zh.at(i);\n        zh~tpush(hash_nodes(prev, prev));\n        i += 1;\n    }\n\n    (int old_hash, int new_hash) = process_update(update, zh, storage::merkle_depth);\n\n    throw_unless(error::bad_proof, old_hash == storage::merkle_root);\n\n    storage::merkle_root = new_hash;\n\n    save_data();\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(to_address)\n        .store_coins(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::report_royalty_params(), 32)\n        .store_uint(query_id, 64)\n        .store_slice(data);\n    send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) {\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    load_data();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    if (op == op::claim) {\n        throw_unless(error::value_too_low, msg_value >= minimum_claim_value);\n\n        slice proof_data = in_msg_body~load_ref().begin_parse();\n        claim(in_msg_body~load_uint(256), proof_data~load_ref(), proof_data~load_ref());\n        return ();\n    }\n\n    if (op == op::update) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        update(in_msg_body~load_ref());\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 64);\n        return ();\n    }\n\n    if (op == op::withdraw) {\n        throw_unless(error::not_owner, equal_slices(sender_address, storage::owner));\n        \n        raw_reserve(50000000, 0);\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6) \n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 128);\n        return ();\n    }\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, storage::royalty.begin_parse());\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, cell, slice) get_collection_data() method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    return (-1, cs~load_ref(), storage::owner);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    load_data();\n    cell state_init = calculate_nft_item_state_init(index, storage::nft_item_code);\n    return calculate_nft_item_address(state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n    load_data();\n    slice rs = storage::royalty.begin_parse();\n    return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n    load_data();\n    slice cs = storage::content.begin_parse();\n    cs~load_ref();\n    slice common_content = cs~load_ref().begin_parse();\n    return (begin_cell()\n            .store_uint(1, 8) ;; offchain tag\n            .store_slice(common_content)\n            .store_ref(individual_nft_content)\n            .end_cell());\n}\n\nint get_merkle_root() method_id {\n    load_data();\n    return storage::merkle_root;\n}\n\n(int, cell) get_nft_api_info() method_id {\n    load_data();\n    slice cs = storage::api_data.begin_parse();\n    int version = cs~load_uint(8);\n    cell link = cs~load_ref();\n    return (version, link);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}