{
  "code": "b5ee9c7201021201000328000114ff00f4a413f4bcf2c80b0102016202030202cc0405001ba0f605da89a1f401f481f481a8610201d40607020148080900bb0831c02497c138007434c0c05c6c2544d7c0fc02f83e903e900c7e800c5c75c87e800c7e800c00b4c7e08403e29fa954882ea54c4d167c0238208405e3514654882ea58c511100fc02780d60841657c1ef2ea4d67c02b817c12103fcbc2000113e910c1c2ebcb853600201200a0b020120101101f500f4cffe803e90087c007b51343e803e903e90350c144da8548ab1c17cb8b04a30bffcb8b0950d109c150804d50500f214013e809633c58073c5b33248b232c044bd003d0032c032483e401c1d3232c0b281f2fff274013e903d010c7e801de0063232c1540233c59c3e8085f2dac4f3208405e351467232c7c6600c03f73b51343e803e903e90350c0234cffe80145468017e903e9014d6f1c1551cdb5c150804d50500f214013e809633c58073c5b33248b232c044bd003d0032c0327e401c1d3232c0b281f2fff274140371c1472c7cb8b0c2be80146a2860822625a020822625a004ad822860822625a028062849f8c3c975c2c070c008e00d0e0f009acb3f5007fa0222cf165006cf1625fa025003cf16c95005cc2391729171e25008a813a08208989680aa008208989680a0a014bcf2e2c504c98040fb001023c85004fa0258cf1601cf16ccc9ed5400705279a018a182107362d09cc8cb1f5230cb3f58fa025007cf165007cf16c9718018c8cb0524cf165006fa0215cb6a14ccc971fb0010241023000e10491038375f040076c200b08e218210d53276db708010c8cb055008cf165004fa0216cb6a12cb1f12cb3fc972fb0093356c21e203c85004fa0258cf1601cf16ccc9ed5400db3b51343e803e903e90350c01f4cffe803e900c145468549271c17cb8b049f0bffcb8b0a0822625a02a8005a805af3cb8b0e0841ef765f7b232c7c572cfd400fe8088b3c58073c5b25c60063232c14933c59c3e80b2dab33260103ec01004f214013e809633c58073c5b3327b55200083200835c87b51343e803e903e90350c0134c7e08405e3514654882ea0841ef765f784ee84ac7cb8b174cfcc7e800c04e81408f214013e809633c58073c5b3327b5520",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            DUP\n            SEMPTY\n            IFJMP:<{\n                  4 BLKDROP\n            }>\n            SWAP\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  s1 s3 XCHG\n                  3 BLKDROP\n                  11 CALLDICT\n            }>\n            LDMSGADDR\n            LDMSGADDR\n            NIP\n            LDGRAMS\n            NIP\n            1 PUSHINT\n            SDSKIPFIRST\n            LDGRAMS\n            NIP\n            LDGRAMS\n            DROP\n            s0 s2 XCHG\n            32 LDU\n            260734629 PUSHINT\n            s2 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  NIP\n                  s4 POP\n                  ROTREV\n                  8 CALLDICT\n            }>\n            395134233 PUSHINT\n            s2 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  NIP\n                  s4 s4 s4 XCHG3\n                  s0 s3 XCHG\n                  9 CALLDICT\n            }>\n            s5 POP\n            1499400124 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  ROTREV\n                  10 CALLDICT\n            }>\n            4 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      1 => <{\n            REWRITESTDADDR\n            DROP\n            0 PUSHINT\n            EQUAL\n            333 THROWIFNOT\n      }>\n      8 => <{\n            s0 s3 XCHG\n            64 LDU\n            LDGRAMS\n            LDMSGADDR\n            OVER\n            1 CALLDICT\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDMSGADDR\n            LDREF\n            DROP\n            s3 s6 XCPU\n            SUB\n            s2 s9 PUXC\n            SDEQ\n            705 THROWIFNOT\n            s8 PUSH\n            -1 GTINT\n            706 THROWIFNOT\n            s4 s4 s2 XCPU2\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            DUP\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            s0 s4 XCHG\n            LDMSGADDR\n            LDDICT\n            NIP\n            LDGRAMS\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            s0 s8 XCHG2\n            STSLICER\n            0 PUSHINT\n            STGRAMS\n            s1 s7 XCHG\n            108 STU\n            s1 s3 XCHG\n            STREF\n            395134233 PUSHINT\n            NEWC\n            32 STU\n            s1 s9 XCHG\n            64 STU\n            s0 s7 XCHG2\n            STGRAMS\n            s2 PUSH\n            STSLICER\n            s0 s6 XCHG2\n            STSLICER\n            s5 PUSH\n            STGRAMS\n            s0 s3 XCHG2\n            STSLICER\n            ENDC\n            s0 s5 XCHG2\n            STREF\n            s3 PUSH\n            IF:<{\n                  2 PUSHINT\n            }>ELSE<{\n                  1 PUSHINT\n            }>\n            s0 s8 XCHG2\n            MUL\n            s1 s3 XCHG\n            ADD\n            10000000 PUSHINT\n            1 LSHIFT#\n            10000000 PUSHINT\n            ADD\n            ADD\n            s1 s4 XCHG\n            GREATER\n            709 THROWIFNOT\n            s0 s4 XCHG\n            ENDC\n            64 PUSHINT\n            SENDRAWMSG\n            s2 s3 XCHG\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            c4 POP\n      }>\n      9 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDMSGADDR\n            LDREF\n            DROP\n            s0 s8 XCHG\n            64 LDU\n            LDGRAMS\n            s5 s1 XCPU\n            ADD\n            s0 s5 XCHG\n            LDMSGADDR\n            LDMSGADDR\n            s5 s11 PUSH2\n            SDEQ\n            s3 s6 s13 PUSH3\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            s0 s13 XCHG2\n            SDEQ\n            s1 s12 XCHG\n            OR\n            707 THROWIFNOT\n            s0 s10 XCHG\n            LDGRAMS\n            s10 s8 XCPU\n            SUB\n            10000000 PUSHINT\n            10000000 PUSHINT\n            s1 s2 XCHG\n            MIN\n            SUB\n            10000000 PUSHINT\n            ADD\n            s1 s8 XCHG\n            SUB\n            s7 PUSH\n            IF:<{\n                  s7 s8 PUXC\n                  ADD\n                  s1 s8 XCHG\n                  SUB\n                  1935855772 PUSHINT\n                  NEWC\n                  32 STU\n                  s3 s(-1) PUXC\n                  64 STU\n                  ROT\n                  STGRAMS\n                  s0 s7 XCHG2\n                  STSLICER\n                  s0 s7 XCHG2\n                  STSLICER\n                  ENDC\n                  1 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  s4 PUSH\n                  STSLICER\n                  s0 s6 XCHG2\n                  STGRAMS\n                  s1 s5 XCHG\n                  107 STU\n                  s1 s4 XCHG\n                  STREF\n                  ENDC\n                  1 PUSHINT\n                  SENDRAWMSG\n                  s2 s4 XCHG\n                  s2 s3 XCHG\n            }>ELSE<{\n                  s4 s9 XCHG\n                  s3 s8 XCHG\n                  s7 POP\n                  4 BLKDROP\n            }>\n            s5 PUSH\n            2 PLDU\n            0 NEQINT\n            s3 PUSH\n            0 GTINT\n            AND\n            IF:<{\n                  3576854235 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s8 XCHG2\n                  STSLICER\n                  s0 s4 XCHG2\n                  STGRAMS\n                  s1 s6 XCHG\n                  107 STU\n                  s1 s2 XCHG\n                  32 STU\n                  s1 s2 XCHG\n                  64 STU\n                  ENDC\n                  2 PUSHINT\n                  SENDRAWMSG\n            }>ELSE<{\n                  s5 POP\n                  2 1 BLKDROP2\n            }>\n            s0 s3 XCHG\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            c4 POP\n      }>\n      10 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDMSGADDR\n            LDREF\n            DROP\n            s0 s7 XCHG\n            64 LDU\n            LDGRAMS\n            LDMSGADDR\n            DROP\n            s5 s1 XCPU\n            SUB\n            s4 s8 PUXC\n            SDEQ\n            705 THROWIFNOT\n            s7 PUSH\n            -1 GTINT\n            706 THROWIFNOT\n            10000000 PUSHINT\n            1 LSHIFT#\n            s1 s6 XCHG\n            ADD\n            s1 s6 XCHG\n            GREATER\n            707 THROWIFNOT\n            2078119902 PUSHINT\n            NEWC\n            32 STU\n            s1 s5 XCHG\n            64 STU\n            s0 s3 XCHG2\n            STGRAMS\n            s2 PUSH\n            STSLICER\n            SWAP\n            STSLICER\n            ENDC\n            1 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            s4 PUSH\n            STSLICER\n            0 PUSHINT\n            STGRAMS\n            107 STU\n            STREF\n            ENDC\n            64 PUSHINT\n            SENDRAWMSG\n            s0 s1 s3 XCHG3\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            c4 POP\n      }>\n      11 => <{\n            32 PUSHINT\n            SDSKIPFIRST\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDMSGADDR\n            LDREF\n            DROP\n            s0 s4 XCHG\n            32 LDU\n            395134233 PUSHINT\n            s2 s(-1) PUXC\n            EQUAL\n            2078119902 PUSHINT\n            s1 s3 XCHG\n            EQUAL\n            s1 s2 XCHG\n            OR\n            709 THROWIFNOT\n            64 LDU\n            NIP\n            LDGRAMS\n            DROP\n            s1 s3 XCHG\n            ADD\n            s2 s3 XCHG2\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            c4 POP\n      }>\n      97026 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDMSGADDR\n            LDREF\n            DROP\n      }>\n}\n11 THROWARG",
  "code_hash": "4adf48135cb575adbaed476799c87ff2904269b1f949ada4d0479e9104b6f217",
  "methods": [
    {
      "id": 97026,
      "method": "get_wallet_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "jetton-utils/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "imports/params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == workchain());\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "jetton-wallet.fc",
        "content": ";; Jetton Wallet Smart Contract\n\n{-\n\nNOTE that this tokens can be transferred within the same workchain.\n\nThis is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\n\n1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\n\n2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\n\n-}\n\nint min_tons_for_storage() asm \"10000000 PUSHINT\"; ;; 0.01 TON\nint gas_consumption() asm \"10000000 PUSHINT\"; ;; 0.01 TON\n\n{-\n  Storage\n  storage#_ balance:Coins owner_address:MsgAddressInt jetton_master_address:MsgAddressInt jetton_wallet_code:^Cell = Storage;\n-}\n\n(int, slice, slice, cell) load_data() inline {\n  slice ds = get_data().begin_parse();\n  return (ds~load_coins(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref());\n}\n\n() save_data (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) impure inline {\n  set_data(pack_jetton_wallet_data(balance, owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n{-\n  transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\n           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\n           = InternalMsgBody;\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell) \n                     = InternalMsgBody;\n-}\n\n() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {\n  int query_id = in_msg_body~load_uint(64);\n  int jetton_amount = in_msg_body~load_coins();\n  slice to_owner_address = in_msg_body~load_msg_addr();\n  force_chain(to_owner_address);\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  balance -= jetton_amount;\n\n  throw_unless(705, equal_slices(owner_address, sender_address));\n  throw_unless(706, balance >= 0);\n\n  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);\n  slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n  slice response_address = in_msg_body~load_msg_addr();\n  cell custom_payload = in_msg_body~load_dict();\n  int forward_ton_amount = in_msg_body~load_coins();\n  slice either_forward_payload = in_msg_body;\n  var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(to_wallet_address)\n    .store_coins(0)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init);\n  var msg_body = begin_cell()\n    .store_uint(op::internal_transfer(), 32)\n    .store_uint(query_id, 64)\n    .store_coins(jetton_amount)\n    .store_slice(owner_address)\n    .store_slice(response_address)\n    .store_coins(forward_ton_amount)\n    .store_slice(either_forward_payload)\n    .end_cell();\n\n  msg = msg.store_ref(msg_body);\n  int fwd_count = forward_ton_amount ? 2 : 1;\n  throw_unless(709, msg_value >\n                     forward_ton_amount +\n                     ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response\n                     ;; but last one is optional (it is ok if it fails)\n                     fwd_count * fwd_fee +\n                     (2 * gas_consumption() + min_tons_for_storage()));\n                     ;; universal message send fee calculation may be activated here\n                     ;; by using this instead of fwd_fee\n                     ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)\n\n  send_raw_message(msg.end_cell(), 64); ;; revert on errors\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n{-\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell) \n                     = InternalMsgBody;\n-}\n\n() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_uint(64);\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  slice from_address = in_msg_body~load_msg_addr();\n  slice response_address = in_msg_body~load_msg_addr();\n  throw_unless(707,\n      equal_slices(jetton_master_address, sender_address)\n      |\n      equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)\n  );\n  int forward_ton_amount = in_msg_body~load_coins();\n\n  int ton_balance_before_msg = my_ton_balance - msg_value;\n  int storage_fee = min_tons_for_storage() - min(ton_balance_before_msg, min_tons_for_storage());\n  msg_value -= (storage_fee + gas_consumption());\n  if(forward_ton_amount) {\n    msg_value -= (forward_ton_amount + fwd_fee);\n    slice either_forward_payload = in_msg_body;\n\n    var msg_body = begin_cell()\n        .store_uint(op::transfer_notification(), 32)\n        .store_uint(query_id, 64)\n        .store_coins(jetton_amount)\n        .store_slice(from_address)\n        .store_slice(either_forward_payload)\n        .end_cell();\n\n    var msg = begin_cell()\n      .store_uint(0x18, 6)\n      .store_slice(owner_address)\n      .store_coins(forward_ton_amount)\n      .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_ref(msg_body);\n\n    send_raw_message(msg.end_cell(), 1);\n  }\n\n  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {\n    var msg = begin_cell()\n      .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n      .store_slice(response_address)\n      .store_coins(msg_value)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(op::excesses(), 32)\n      .store_uint(query_id, 64);\n    send_raw_message(msg.end_cell(), 2);\n  }\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() burn_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_uint(64);\n  int jetton_amount = in_msg_body~load_coins();\n  slice response_address = in_msg_body~load_msg_addr();\n  ;; ignore custom payload\n  ;; slice custom_payload = in_msg_body~load_dict();\n  balance -= jetton_amount;\n  throw_unless(705, equal_slices(owner_address, sender_address));\n  throw_unless(706, balance >= 0);\n  throw_unless(707, msg_value > fwd_fee + 2 * gas_consumption());\n\n  var msg_body = begin_cell()\n      .store_uint(op::burn_notification(), 32)\n      .store_uint(query_id, 64)\n      .store_coins(jetton_amount)\n      .store_slice(owner_address)\n      .store_slice(response_address)\n      .end_cell();\n\n  var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(jetton_master_address)\n    .store_coins(0)\n    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_ref(msg_body);\n\n  send_raw_message(msg.end_cell(), 64);\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() on_bounce (slice in_msg_body) impure {\n  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int op = in_msg_body~load_uint(32);\n  throw_unless(709, (op == op::internal_transfer()) | (op == op::burn_notification()));\n  int query_id = in_msg_body~load_uint(64);\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n    return ();\n  }\n\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  if (flags & 1) {\n    on_bounce(in_msg_body);\n    return ();\n  }\n  slice sender_address = cs~load_msg_addr();\n  cs~load_msg_addr(); ;; skip dst\n  cs~load_coins(); ;; skip value\n  cs~skip_bits(1); ;; skip extracurrency collection\n  cs~load_coins(); ;; skip ihr_fee\n  int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs\n\n  int op = in_msg_body~load_uint(32);\n\n  if (op == op::transfer()) { ;; outgoing transfer\n    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);\n    return ();\n  }\n\n  if (op == op::internal_transfer()) { ;; incoming transfer\n    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);\n    return ();\n  }\n\n  if (op == op::burn()) { ;; burn\n    burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);\n    return ();\n  }\n\n  throw(0xffff);\n}\n\n(int, slice, slice, cell) get_wallet_data() method_id {\n  return load_data();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/op-codes.fc",
        "content": "int op::transfer() asm \"0xf8a7ea5 PUSHINT\";\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\nint op::internal_transfer() asm \"0x178d4519 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::burn() asm \"0x595f07bc PUSHINT\";\nint op::burn_notification() asm \"0x7bdd97de PUSHINT\";\n\n;; Minter\nint op::mint() asm \"21 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "imports/jetton-utils.fc",
        "content": "cell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n   return  begin_cell()\n            .store_coins(balance)\n            .store_slice(owner_address)\n            .store_slice(jetton_master_address)\n            .store_ref(jetton_wallet_code)\n           .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n  return begin_cell()\n          .store_uint(0, 2)\n          .store_dict(jetton_wallet_code)\n          .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\n          .store_uint(0, 1)\n         .end_cell();\n}\n\nslice calculate_jetton_wallet_address(cell state_init) inline {\n  return begin_cell().store_uint(4, 3)\n                     .store_int(workchain(), 8)\n                     .store_uint(cell_hash(state_init), 256)\n                     .end_cell()\n                     .begin_parse();\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n  return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}