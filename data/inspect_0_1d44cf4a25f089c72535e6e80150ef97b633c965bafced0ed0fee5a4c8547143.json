{
  "code": "b5ee9c7201021301000385000114ff00f4a413f4bcf2c80b0102016202030202cb0405001ba0f605da89a1f401f481f481a9a30201ce06070201580a0b02f70831c02497c138007434c0c05c6c2544d7c0fc07783e903e900c7e800c5c75c87e800c7e800c1cea6d0000b4c7c076cf16cc8d0d0d09208403e29fa96ea68c1b088d978c4408fc06b809208405e351466ea6cc1b08978c840910c03c06f80dd6cda0841657c1ef2ea7c09c6c3cb4b01408eebcb8b1807c073817c160080900113e910c30003cb85360005c804ff833206e953080b1f833de206ef2d29ad0d30731d3ffd3fff404d307d430d0fa00fa00fa00fa00fa00fa00300008840ff2f00201580c0d020148111201f70174cfc0407e803e90087c007b51343e803e903e903534544da8548b31c17cb8b04ab0bffcb8b0950d109c150804d50500f214013e809633c58073c5b33248b232c044bd003d0032c032481c007e401d3232c084b281f2fff274013e903d010c7e800835d270803cb8b13220060072c15401f3c59c3e809dc072dae00e02f33b51343e803e903e90353442b4cfc0407e80145468017e903e9014d771c1551cdbdc150804d50500f214013e809633c58073c5b33248b232c044bd003d0032c0325c007e401d3232c084b281f2fff2741403f1c147ac7cb8b0c33e801472a84a6d8206685401e8062849a49b1578c34975c2c070c00870802c200f1000aa13ccc88210178d4519580a02cb1fcb3f5007fa0222cf165006cf1625fa025003cf16c95005cc2391729171e25007a813a008aa005004a017a014bcf2e2c501c98040fb004300c85004fa0258cf1601cf16ccc9ed5400725269a018a1c882107362d09c2902cb1fcb3f5007fa025004cf165007cf16c9c8801001cb0527cf165004fa027101cb6a13ccc971fb0050421300748e23c8801001cb055006cf165005fa027001cb6a8210d53276db580502cb1fcb3fc972fb00925b33e24003c85004fa0258cf1601cf16ccc9ed5400eb3b51343e803e903e9035344174cfc0407e800870803cb8b0be903d01007434e7f440745458a8549631c17cb8b049b0bffcb8b0b220841ef765f7960100b2c7f2cfc07e8088f3c58073c584f2e7f27220060072c148f3c59c3e809c4072dab33260103ec01004f214013e809633c58073c5b3327b55200087200835c87b51343e803e903e9035344134c7c06103c8608405e351466e80a0841ef765f7ae84ac7cbd34cfc04c3e800c04e81408f214013e809633c58073c5b3327b5520",
  "code_hash": "9e06ca30e508a6d9fb21167cbb8f66399edd1190b0b01e0bbd14c546cc97a72b",
  "methods": [
    {
      "id": 97026,
      "method": "get_wallet_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "jetton-wallet.fc",
        "content": ";; Jetton Wallet Smart Contract\n\n#include \"stdlib.fc\";\n#include \"params.fc\";\n#include \"op-codes.fc\";\n#include \"messages.fc\";\n#include \"utils.fc\";\n#include \"errors.fc\";\n#include \"config.fc\";\n\n\n{-\n\nNOTE that this tokens can be transferred within the same workchain.\n\nThis is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\n\n1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\n\n2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\n\n-}\n\n{-\n  Storage\n  storage#_ balance:Coins owner_address:MsgAddressInt jetton_master_address:MsgAddressInt jetton_wallet_code:^Cell = Storage;\n-}\n\n(int, slice, slice, cell) load_data() inline {\n  slice ds = get_data().begin_parse();\n\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = (ds~load_coins(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref());\n  ds.end_parse();\n\n  return (balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() save_data (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) impure inline {\n  set_data(pack_jetton_wallet_data(balance, owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n{-\n  transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\n           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\n           = InternalMsgBody;\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell)\n                     = InternalMsgBody;\n-}\n\n() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee, int wallet_min_tons_for_storage, int wallet_gas_consumption) impure {\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  slice to_owner_address = in_msg_body~load_msg_addr();\n  force_chain(to_owner_address);\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  balance -= jetton_amount;\n\n  throw_unless(error::unauthorized_transfer, equal_slices(owner_address, sender_address));\n  throw_unless(error::not_enough_funds, balance >= 0);\n\n  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);\n  slice to_wallet_address = calculate_address_by_state_init(state_init);\n  slice response_address = in_msg_body~load_msg_addr();\n  cell custom_payload = in_msg_body~load_dict();\n  int forward_ton_amount = in_msg_body~load_coins();\n  throw_unless(error::malformed_forward_payload, slice_bits(in_msg_body) >= 1);\n  slice either_forward_payload = in_msg_body;\n  var msg = begin_cell()\n          .store_msg_flags(BOUNCEABLE)\n          .store_slice(to_wallet_address)\n          .store_coins(0)\n          .store_msgbody_prefix_stateinit()\n          .store_ref(state_init);\n  var msg_body = begin_cell()\n          .store_body_header(op::internal_transfer, query_id)\n          .store_coins(jetton_amount)\n          .store_slice(owner_address)\n          .store_slice(response_address)\n          .store_coins(forward_ton_amount)\n          .store_slice(either_forward_payload)\n          .end_cell();\n\n  msg = msg.store_ref(msg_body);\n  int fwd_count = forward_ton_amount ? 2 : 1;\n  throw_unless(error::not_enough_tons, msg_value >\n          forward_ton_amount +\n                  ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response\n                  ;; but last one is optional (it is ok if it fails)\n                  fwd_count * fwd_fee +\n                  (2 * wallet_gas_consumption + wallet_min_tons_for_storage));\n  ;; universal message send fee calculation may be activated here\n  ;; by using this instead of fwd_fee\n  ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)\n\n  send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE); ;; revert on errors\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n{-\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell)\n                     = InternalMsgBody;\n-}\n\n() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value, int wallet_min_tons_for_storage, int wallet_gas_consumption) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  slice from_address = in_msg_body~load_msg_addr();\n  slice response_address = in_msg_body~load_msg_addr();\n  throw_unless(error::unauthorized_incoming_transfer,\n          equal_slices(jetton_master_address, sender_address)\n                  |\n                  equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)\n  );\n  int forward_ton_amount = in_msg_body~load_coins();\n\n  int ton_balance_before_msg = my_ton_balance - msg_value;\n  int storage_fee = wallet_min_tons_for_storage - min(ton_balance_before_msg, wallet_min_tons_for_storage);\n  msg_value -= (storage_fee + wallet_gas_consumption);\n  if(forward_ton_amount) {\n    msg_value -= (forward_ton_amount + fwd_fee);\n    slice either_forward_payload = in_msg_body;\n\n    var msg_body = begin_cell()\n            .store_body_header(op::transfer_notification, query_id)\n            .store_coins(jetton_amount)\n            .store_slice(from_address)\n            .store_slice(either_forward_payload)\n            .end_cell();\n\n    var msg = begin_cell()\n            .store_msg_flags(NON_BOUNCEABLE) ;; we should not bounce here cause receiver can have uninitialized contract\n            .store_slice(owner_address)\n            .store_coins(forward_ton_amount)\n            .store_msgbody_prefix_ref()\n            .store_ref(msg_body);\n\n    send_raw_message(msg.end_cell(), SEND_MODE_PAY_FEES_SEPARETELY);\n  }\n\n  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {\n    var msg = begin_cell()\n            .store_msg_flags(NON_BOUNCEABLE)\n            .store_slice(response_address)\n            .store_coins(msg_value)\n            .store_msgbody_prefix_slice()\n            .store_body_header(op::excesses, query_id);\n    send_raw_message(msg.end_cell(), SEND_MODE_IGNORE_ERRORS);\n  }\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() burn_tokens (slice in_msg_body, slice sender_address) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  throw_unless(error::not_enough_funds, jetton_amount > 0);\n  slice response_address = in_msg_body~load_msg_addr();\n  cell custom_payload = in_msg_body~load_dict();\n  slice custom_payload_slice = custom_payload.begin_parse();\n  int destination_address = custom_payload_slice~load_uint(160); ;; destination address in other network\n  custom_payload_slice.end_parse();\n  in_msg_body.end_parse();\n\n  balance -= jetton_amount;\n  throw_unless(error::unauthorized_transfer, equal_slices(owner_address, sender_address));\n  throw_unless(error::not_enough_funds, balance >= 0);\n\n  var msg_body = begin_cell()\n          .store_body_header(op::burn_notification, query_id) ;; 32 + 64 = 96 bit\n          .store_coins(jetton_amount) ;; max 124 bit\n          .store_slice(owner_address) ;; 3 + 8 + 256 = 267 bit\n          .store_slice(response_address) ;; 3 + 8 + 256 = 267 bit\n          .store_uint(destination_address, 160) ;; 160 bit\n          .end_cell();\n\n  var msg = begin_cell()\n          .store_msg_flags(BOUNCEABLE)\n          .store_slice(jetton_master_address)\n          .store_coins(0)\n          .store_msgbody_prefix_ref()\n          .store_ref(msg_body);\n\n  send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() on_bounce (slice in_msg_body) impure {\n  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int op = in_msg_body~load_op();\n  throw_unless(error::unknown_op, (op == op::internal_transfer) | (op == op::burn_notification));\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n    return ();\n  }\n\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  if (flags & 1) {\n    on_bounce(in_msg_body);\n    return ();\n  }\n  slice sender_address = cs~load_msg_addr();\n  cs~load_msg_addr(); ;; skip dst\n  cs~load_coins(); ;; skip value\n  cs~skip_bits(1); ;; skip extracurrency collection\n  cs~load_coins(); ;; skip ihr_fee\n  int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\n\n  int op = in_msg_body~load_op();\n\n  (_, _, _, int state_flags, int bridge_burn_fee, int bridge_mint_fee, int wallet_min_tons_for_storage, int wallet_gas_consumption, _, _) = get_jetton_bridge_config();\n\n  if (op == op::transfer) { ;; outgoing transfer\n    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee, wallet_min_tons_for_storage, wallet_gas_consumption);\n    return ();\n  }\n\n  if (op == op::internal_transfer) { ;; incoming transfer\n    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value, wallet_min_tons_for_storage, wallet_gas_consumption);\n    return ();\n  }\n\n  if (op == op::burn) { ;; burn\n    throw_if( error::operation_suspended, state_flags & STATE_BURN_SUSPENDED);\n    throw_unless(error::burn_fee_not_matched, msg_value == bridge_burn_fee);\n    burn_tokens(in_msg_body, sender_address);\n    return ();\n  }\n\n  throw(error::unknown_op);\n}\n\n(int, slice, slice, cell) get_wallet_data() method_id {\n  return load_data();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "errors.fc",
        "content": ";; global errors\nconst int error::inbound_message_has_empty_body = 200;\nconst int error::unknown_op = 0xffff;\nconst int error::unknown_execute_voting_op = 211;\n\n;; data errors\nconst int error::incorrect_voting_data = 320;\nconst int error::decimals_out_of_range = 330;\n\n;; wrong sender errors\nconst int error::oracles_sender = 400;\nconst int error::oracles_not_sender = 401;\nconst int error::minter_not_sender = 402;\nconst int error::bridge_not_sender = 403;\nconst int error::owner_not_sender = 404;\nconst int error::operation_suspended = 704;\n\n;; jetton wallet errors\nconst int error::unauthorized_transfer = 705;\nconst int error::not_enough_funds = 706;\nconst int error::unauthorized_incoming_transfer = 707;\nconst int error::malformed_forward_payload = 708;\nconst int error::not_enough_tons = 709;\nconst int error::burn_fee_not_matched = 710;\n\n;; jetton minter errors\nconst int error::discovery_fee_not_matched = 75;\n\n;; jetton bridge errors\nconst int error::wrong_external_chain_id = 410;\nconst int error::wrong_sender_workchain = 413;\nconst int error::mint_fee_not_matched = 407;\nconst int error::mint_fee_less_forward = 399;\n\nconst int error::no_bridge_config = 666;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "params.fc",
        "content": "const int CONFIG_PARAM_ID = 79;\nconst int MY_CHAIN_ID = 1;\nconst int LOG_BURN = 0xc0470ccf;\nconst int LOG_SWAP_PAID = 0xc0550ccf;\nconst int LOG_MINT_ON_MINTER = 0xc0660ccf;\nconst int LOG_BURN_ON_MINTER = 0xc0770ccf;\n\nconst int WORKCHAIN = 0;\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == WORKCHAIN);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils.fc",
        "content": "#include \"messages.fc\";\n#include \"op-codes.fc\";\n\ncell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return  begin_cell()\n            .store_coins(balance)\n            .store_slice(owner_address)\n            .store_slice(jetton_master_address)\n            .store_ref(jetton_wallet_code)\n            .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return begin_cell()\n            .store_uint(0, 2)\n            .store_dict(jetton_wallet_code)\n            .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\n            .store_uint(0, 1)\n            .end_cell();\n}\n\nslice create_address(int wc, int address_hash) inline {\n    return begin_cell().store_uint(4, 3)\n            .store_int(wc, 8)\n            .store_uint(address_hash, 256)\n            .end_cell()\n            .begin_parse();\n}\n\nslice calculate_address_by_state_init(cell state_init) inline {\n    return create_address(WORKCHAIN, cell_hash(state_init));\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return calculate_address_by_state_init(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n() send_receipt_message(addr, ans_tag, query_id, body, grams, mode) impure inline_ref {\n    var msg = begin_cell()\n            .store_uint(NON_BOUNCEABLE, 6)\n            .store_slice(addr)\n            .store_grams(grams)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(ans_tag, 32)\n            .store_uint(query_id, 64);\n    if (body >= 0) {\n        msg~store_uint(body, 256);\n    }\n    send_raw_message(msg.end_cell(), mode);\n}\n\n;; LIMITS:\n;; chainId: uint32 (it seems EVM chainId is uint256, but for our cases 32 bits is enough https://chainlist.org/)\n;; token address in EVM network: 160 bit (an Ethereum address is a 42-character hexadecimal address derived from the last 20 bytes of the public key controlling the account with 0x appended in front. e.g., 0x71C7656EC7ab88b098defB751B7401B5f6d8976F - https://info.etherscan.com/what-is-an-ethereum-address)\n;; decimals: uint8 (ERC-20 has uint8 decimals - https://eips.ethereum.org/EIPS/eip-20)\n(int, int, int) unpack_wrapped_token_data(cell data) inline {\n    slice slice_data = data.begin_parse();\n\n    (\n        int chain_id,\n        int token_address,\n        int token_decimals\n    ) = (\n        slice_data~load_uint(32),\n        slice_data~load_uint(160),\n        slice_data~load_uint(8)\n    );\n    slice_data.end_parse();\n\n    return (\n        chain_id,\n        token_address,\n        token_decimals\n    );\n}\n\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#data-serialization\ncell pack_metadata_value(slice a) inline {\n    return begin_cell().store_uint(0, 8).store_slice(a).end_cell();\n}\n\nslice encode_number_to_text(int decimals, int radix) {\n    builder str = begin_cell();\n    int ctr  = 0;\n    tuple chars =  empty_tuple();\n\n    do {\n        (decimals, int rem) = decimals /% radix;\n\n        chars~tpush( rem >= 10 ? 87 + rem : 48 + rem);\n        ctr += 1;\n    } until (decimals == 0);\n\n    repeat( ctr ) {\n        str     = str.store_uint(chars.at(ctr - 1), 8);\n        ctr    -= 1;\n    }\n\n    return str.end_cell().begin_parse();\n}\n\n() emit_log_simple (int event_id, cell data, int need_separate_cell) impure inline {\n    ;; 1023 - (4+2+9+256+64+32+2) = 654 bit free\n\n    var msg = begin_cell()\n            .store_uint (12, 4)         ;; ext_out_msg_info$11 src:MsgAddressInt ()\n            .store_uint (1, 2)          ;; addr_extern$01\n            .store_uint (256, 9)        ;; len:(## 9)\n            .store_uint(event_id, 256); ;; external_address:(bits len)\n\n    if (need_separate_cell) {\n        msg = msg.store_uint(1, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n                .store_ref(data);\n    } else {\n        msg = msg.store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n                .store_slice(data.begin_parse());\n    }\n\n    send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "config.fc",
        "content": "const int STATE_BURN_SUSPENDED = 1; ;; state_flags & 1 - burn (TON->EVM transfer) suspended\nconst int STATE_SWAPS_SUSPENDED = 2; ;; state_flags & 2 - swaps (EVM->TON transfer) suspended\nconst int STATE_GOVERNANCE_SUSPENDED = 4; ;; state_flags & 4 - all governance actions suspended\nconst int STATE_COLLECTOR_SIGNATURE_REMOVAL_SUSPENDED = 8; ;; state_flags & 8 - collector signature removal suspended\n\n(int, int, cell, int, int, int, int, int, int, int) get_jetton_bridge_config() impure inline_ref {\n    cell bridge_config = config_param(CONFIG_PARAM_ID);\n    if (bridge_config.cell_null?()) {\n        bridge_config = config_param(- CONFIG_PARAM_ID);\n    }\n    throw_if(error::no_bridge_config, bridge_config.cell_null?());\n\n    slice slice_config = bridge_config.begin_parse();\n\n    int prefix = slice_config~load_uint(8);\n\n    int bridge_address_hash = slice_config~load_uint(256);\n\n    int oracles_address_hash = slice_config~load_uint(256);\n\n    ;; key: uint256 (public key) value: uint256 (eth address)\n    cell oracles = slice_config~load_dict();\n\n    int state_flags = slice_config~load_uint(8);\n\n    slice prices = slice_config~load_ref().begin_parse();\n\n    int bridge_burn_fee = prices~load_coins(); ;; ATTENTION: burn_fee must include burn network fees (at least 2 * fwd_fee + 3 * gas_consumption + minter_min_tons_for_storage)\n\n    int bridge_mint_fee = prices~load_coins(); ;; ATTENTION: mint_fee must include mint network fees (at least 2 * fwd_fee + 3 * gas_consumption + minter_min_tons_for_storage + wallet_min_tons_for_storage) and forward_coins_amount\n\n    int wallet_min_tons_for_storage = prices~load_coins();\n\n    int wallet_gas_consumption = prices~load_coins();\n\n    int minter_min_tons_for_storage = prices~load_coins();\n\n    int discover_gas_consumption = prices~load_coins();\n\n    return (bridge_address_hash, oracles_address_hash, oracles, state_flags, bridge_burn_fee, bridge_mint_fee, wallet_min_tons_for_storage, wallet_gas_consumption, minter_min_tons_for_storage, discover_gas_consumption);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\n() set_seed(int) impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": ";; Jettons\n\nconst int op::transfer = 0xf8a7ea5;\nconst int op::transfer_notification = 0x7362d09c;\nconst int op::internal_transfer = 0x178d4519;\nconst int op::excesses = 0xd53276db;\nconst int op::burn = 0x595f07bc;\nconst int op::burn_notification = 0x7bdd97de;\n\n;; Minter\nconst int op::mint = 21;\n\n;; Bridge\n\nconst int op::execute_voting = 4;\nconst int op::execute_voting::swap = 0;\nconst int op::execute_voting::get_reward = 5;\nconst int op::execute_voting::change_collector = 7;\n\nconst int op::pay_swap = 8;\n\n(slice, int) ~load_op(slice s) inline { return s.load_uint(32); }\n(slice, int) ~load_query_id(slice s) inline { return s.load_uint(64); }\n(slice, (int, int)) ~load_body_header(slice s) inline {\n  int op = s~load_uint(32);\n  int query_id = s~load_uint(64);\n  return (s, (op, query_id));\n}\nbuilder store_op(builder b, int op) inline { return b.store_uint(op, 32); }\nbuilder store_query_id(builder b, int query_id) inline { return b.store_uint(query_id, 64); }\nbuilder store_body_header(builder b, int op, int query_id) inline {\n  return b.store_uint(op, 32)\n          .store_uint(query_id, 64);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "messages.fc",
        "content": "const int BOUNCEABLE = 0x18;\nconst int NON_BOUNCEABLE = 0x10;\n\nconst int SEND_MODE_REGULAR = 0;\nconst int SEND_MODE_PAY_FEES_SEPARETELY = 1;\nconst int SEND_MODE_IGNORE_ERRORS = 2;\nconst int SEND_MODE_DESTROY = 32;\nconst int SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;\nconst int SEND_MODE_CARRY_ALL_BALANCE = 128;\n\nbuilder store_msg_flags(builder b, int msg_flag) inline { return b.store_uint(msg_flag, 6); }\n\n{-\n  Helpers below fill in default/overwritten values of message layout:\n  Relevant part of TL-B schema:\n  ... other:ExtraCurrencyCollection ihr_fee:Grams fwd_fee:Grams created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  bits      1                               4             4                64                32                            \n  ... init:(Maybe (Either StateInit ^StateInit))  body:(Either X ^X) = Message X;\n  bits      1      1(if prev is true)                   1\n\n-}\n\nbuilder store_msgbody_prefix_stateinit(builder b) inline { \n  return b.store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1);\n}\nbuilder store_msgbody_prefix_slice(builder b) inline { \n  return b.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n}\nbuilder store_msgbody_prefix_ref(builder b) inline { \n  return b.store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n}\n\n{-\n\naddr_std$10 anycast:(Maybe Anycast) \n   workchain_id:int8 address:bits256  = MsgAddressInt;\n-}\n\nbuilder store_masterchain_address(builder b, int address_hash) inline {\n  return b.store_uint(4, 3).store_int(-1, 8).store_uint(address_hash, 256);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}