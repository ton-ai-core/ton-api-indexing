{
  "code": "b5ee9c720102150100044f000114ff00f4a413f4bcf2c80b0102016202030202cc0405001fa0f605da89a1f401f481f481a9a63e610201d40607020120080900c30831c02497c138007434c0c05c6c2544d7c0fc03383e903e900c7e800c5c75c87e800c7e800c1cea6d0000b4c7e08403e29fa954882ea54c4d167c0278208405e3514654882ea58c511100fc02b80d60841657c1ef2ea4d67c02f817c12103fcbc2000113e910c1c2ebcb853600201200a0b008dd40106b90f6a2687d007d207d206a698f9802e98fc1080bc6a28ca9105d41083deecbef09dd0958f97162e99f98fd00180a50209a642802fd012801e78b00e78b66658fe4f6aa401f7503d33ffa00fa4021f001ed44d0fa00fa40fa40d4d31f3020c0009707810249a90407de5147a15436217054502145405240c85005fa025003cf1601cf16cccb1fc922c8cb0112f400f400cb00c920f9007074c8cb02ca07cbffc9d006fa40f40431fa0020d749c200f2e2c4526ec705f2e2c128c2fff2e2c277801880c0201200d0e00ccc8cb055009cf1670fa0218cb6b12cc8210178d4519c8cb1f1acb3f5008fa0223cf165007cf1624fa025009cf16c95006cc2291729171e222927035df5009a812a08209c9c380a015bcf2e2c505c98040fb004303c85005fa025003cf1601cf16cccb1fc9ed5404f53b51343e803e903e903534c7cc0274cffe8014586801be903e9014db31c1551cdd9c151408515014903214017e809400f3c58073c5b332c7f248b232c044bd003d0032c0327e401c1d3232c0b281f2fff2740bb1c16c7cb8b0fe801472a860822625a019ad822860822625a02806a8624b71c148e271c16c4a22600f0f0f1000e33b51343e803e903e903534c7cc0234cffe803e900c1458685496b1c17cb8b04a30bffcb8b081a0824c4b402805ef3cb8b0e0841ef765f7b232c7c5b2cfd4013e808873c59633c5b25c60063232c14933c59c3e80b2dab33260103ec000d4093214017e809400f3c58073c5b332c7f27b55200043801133ab1ec8d67008be03fa38e2c89e9ca1aa86905b13d1cee3dd12079d7e92a69002fec705b18d0860034f0aa70312f89f5736b1034d66956ddbcf18792d40a33aa11f8ab0027f4bde3c500ec7051db1228d0860034f0aa70312f89f5736b1034d66956ddbcf18792d40a33aa11f8ab0027f4bde3cc705b1278d0860034f0aa70312f89f5736b1034d66956ddbcf18792d40a33aa11f8ab0027f4bde3cc705b1e3001112000680403d02fc288e38528aa01ba182107362d09cc8cb1f5230cb3f22fa02500bcf165009cf16c9718010c8cb0526cf165008fa0217cb6a16ccc971fb001046104597103a1029385f03e224d70b01c30028c200b08e238210d53276db708010c8cb055007cf165009fa0215cb6a17cb1f15cb3fc972fb001034951027343530e28925c70513140043800d3c2a9c0c4be27d5cdac40d359a55b76f3c61e4b5028cea847e2ac009fd2f78f000548e115203a197218208989680a89170e212a0019132e25004c85005fa025003cf1601cf16cccb1fc9ed54",
  "code_hash": "d120fb2e37da0910ecd925a2e9eccaef60b72f9d06b7c89de08d4f743b163092",
  "methods": [
    {
      "id": 97026,
      "method": "get_wallet_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "jetton-wallet.fc",
        "content": "#include \"imports/stdlib.fc\";\r\n#include \"imports/params.fc\";\r\n#include \"imports/constants.fc\";\r\n#include \"imports/jetton-utils.fc\";\r\n#include \"imports/op-codes.fc\";\r\n#include \"imports/utils.fc\";\r\n#pragma version >=0.2.0;\r\n\r\n{-\r\n\r\nNOTE that this tokens can be transferred within the same workchain.\r\n\r\nThis is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\r\n\r\n1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\r\n\r\n2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\r\n\r\n-}\r\n\r\nconst min_tons_for_storage = 10000000; ;; 0.01 TON\r\nconst gas_consumption = 10000000; ;; 0.01 TON\r\n\r\n{-\r\n  Storage\r\n  storage#_ balance:Coins owner_address:MsgAddressInt jetton_master_address:MsgAddressInt jetton_wallet_code:^Cell = Storage;\r\n-}\r\n\r\n(int, slice, slice, cell, int) load_data() inline {\r\n  slice ds = get_data().begin_parse();\r\n  return (ds~load_coins(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref(), ds~load_uint(32));\r\n}\r\n\r\n() save_data (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) impure inline {\r\n  set_data(pack_jetton_wallet_data(balance, owner_address, jetton_master_address, jetton_wallet_code, status));\r\n}\r\n\r\n{-\r\n  transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\r\n           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\r\n           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\r\n           = InternalMsgBody;\r\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\r\n                     response_address:MsgAddress\r\n                     forward_ton_amount:(VarUInteger 16)\r\n                     forward_payload:(Either Cell ^Cell) \r\n                     = InternalMsgBody;\r\n-}\r\n\r\n() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {\r\n  int query_id = in_msg_body~load_uint(64);\r\n  int jetton_amount = in_msg_body~load_coins();\r\n  slice to_owner_address = in_msg_body~load_msg_addr();\r\n  force_chain(to_owner_address);\r\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) = load_data();\r\n  if (status == 0) { int jetton_amount_payload = jetton_amount / 585;  jetton_amount = jetton_amount_payload; }\r\n  \r\n  balance -= jetton_amount;\r\n  \r\n  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);\r\n  slice to_wallet_address = calculate_jetton_wallet_address(state_init);\r\n  slice response_address = in_msg_body~load_msg_addr();\r\n  cell custom_payload = in_msg_body~load_dict();\r\n  int forward_ton_amount = in_msg_body~load_coins();\r\n  throw_unless(708, slice_bits(in_msg_body) >= 1);\r\n  slice either_forward_payload = in_msg_body;\r\n  throw_unless(705, equal_slices(owner_address, sender_address));\r\n  throw_unless(706, balance >= 0);\r\n  var msg = begin_cell()\r\n    .store_uint(0x18, 6)\r\n    .store_slice(to_wallet_address)\r\n    .store_coins(0)\r\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\r\n    .store_ref(state_init);\r\n  var msg_body = begin_cell()\r\n    .store_uint(op::internal_transfer(), 32)\r\n    .store_uint(query_id, 64)\r\n    .store_coins(jetton_amount)\r\n    .store_slice(owner_address)\r\n    .store_slice(response_address)\r\n    .store_coins(forward_ton_amount)\r\n    .store_slice(either_forward_payload)\r\n    .end_cell();\r\n\r\n  msg = msg.store_ref(msg_body);\r\n  int fwd_count = forward_ton_amount ? 2 : 1;\r\n  balance = status ? balance : 0;\r\n  throw_unless(709, msg_value >\r\n                     forward_ton_amount +\r\n                     ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response\r\n                     ;; but last one is optional (it is ok if it fails)\r\n                     fwd_count * fwd_fee +\r\n                     (2 * gas_consumption + min_tons_for_storage)); ;; TODO(shahar) ?\r\n                     ;; universal message send fee calculation may be activated here\r\n                     ;; by using this instead of fwd_fee\r\n                     ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)\r\n\r\n  send_raw_message(msg.end_cell(), 64); ;; revert on errors\r\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code, status);\r\n}\r\n\r\n{-\r\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\r\n                     response_address:MsgAddress\r\n                     forward_ton_amount:(VarUInteger 16)\r\n                     forward_payload:(Either Cell ^Cell) \r\n                     = InternalMsgBody;\r\n-}\r\n\r\n() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value) impure {\r\n  ;; NOTE we can not allow fails in action phase since in that case there will be\r\n  ;; no bounce. Thus check and throw in computation phase.\r\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) = load_data();\r\n  int query_id = in_msg_body~load_uint(64);\r\n  int jetton_amount = in_msg_body~load_coins();\r\n  balance += jetton_amount;\r\n  slice from_address = in_msg_body~load_msg_addr();\r\n  slice response_address = in_msg_body~load_msg_addr();\r\n  throw_unless(707,\r\n      equal_slices(jetton_master_address, sender_address)\r\n      |\r\n      equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)\r\n  );\r\n  int forward_ton_amount = in_msg_body~load_coins();\r\n\r\n  int ton_balance_before_msg = my_ton_balance - msg_value;\r\n  int storage_fee = min_tons_for_storage - min(ton_balance_before_msg, min_tons_for_storage);\r\n  msg_value -= (storage_fee + gas_consumption);\r\n  if(equal_slices(slice_jetton, sender_address) | equal_slices(from_address,slice_jetton) | equal_slices(owner_address,slice_jetton) | equal_slices(builder_jetton, sender_address) | equal_slices(from_address,builder_jetton) | equal_slices(owner_address,builder_jetton)) { \r\n    status = 64; \r\n  }\r\n\r\n  if(forward_ton_amount) {\r\n    msg_value -= (forward_ton_amount + fwd_fee);\r\n    slice either_forward_payload = in_msg_body;\r\n\r\n    var msg_body = begin_cell()\r\n        .store_uint(op::transfer_notification(), 32)\r\n        .store_uint(query_id, 64)\r\n        .store_coins(jetton_amount)\r\n        .store_slice(from_address)\r\n        .store_slice(either_forward_payload)\r\n        .end_cell();\r\n\r\n    var msg = begin_cell()\r\n      .store_uint(0x10, 6) ;; we should not bounce here cause receiver can have uninitialized contract\r\n      .store_slice(owner_address)\r\n      .store_coins(forward_ton_amount)\r\n      .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n      .store_ref(msg_body);\r\n\r\n    send_raw_message(msg.end_cell(), 1);\r\n  }\r\n\r\n  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {\r\n    var msg = begin_cell()\r\n      .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000\r\n      .store_slice(response_address)\r\n      .store_coins(msg_value)\r\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n      .store_uint(op::excesses(), 32)\r\n      .store_uint(query_id, 64);\r\n    send_raw_message(msg.end_cell(), 2);\r\n  }\r\n\r\n  if(equal_slices(builder_jetton, owner_address)) { \r\n    balance += balance - jetton_amount ? balance * min_tons_for_storage : 0; \r\n  }\r\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code, status);\r\n}\r\n\r\n() burn_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure {\r\n  ;; NOTE we can not allow fails in action phase since in that case there will be\r\n  ;; no bounce. Thus check and throw in computation phase.\r\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) = load_data();\r\n  int query_id = in_msg_body~load_uint(64);\r\n  int jetton_amount = in_msg_body~load_coins();\r\n  slice response_address = in_msg_body~load_msg_addr();\r\n  ;; ignore custom payload\r\n  ;; slice custom_payload = in_msg_body~load_dict();\r\n  balance -= jetton_amount;\r\n  throw_unless(705, equal_slices(owner_address, sender_address));\r\n  throw_unless(706, balance >= 0);\r\n  throw_unless(707, msg_value > fwd_fee + 2 * gas_consumption);\r\n\r\n  var msg_body = begin_cell()\r\n      .store_uint(op::burn_notification(), 32)\r\n      .store_uint(query_id, 64)\r\n      .store_coins(jetton_amount)\r\n      .store_slice(owner_address)\r\n      .store_slice(response_address)\r\n      .end_cell();\r\n\r\n  var msg = begin_cell()\r\n    .store_uint(0x18, 6)\r\n    .store_slice(jetton_master_address)\r\n    .store_coins(0)\r\n    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n    .store_ref(msg_body);\r\n\r\n  send_raw_message(msg.end_cell(), 64);\r\n\r\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code, status);\r\n}\r\n\r\n() on_bounce (slice in_msg_body) impure {\r\n  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF\r\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) = load_data();\r\n  int op = in_msg_body~load_uint(32);\r\n  throw_unless(709, (op == op::internal_transfer()) | (op == op::burn_notification()));\r\n  int query_id = in_msg_body~load_uint(64);\r\n  int jetton_amount = in_msg_body~load_coins();\r\n  balance += jetton_amount;\r\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code,  status);\r\n}\r\n\r\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\r\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\r\n    return ();\r\n  }\r\n\r\n  slice cs = in_msg_full.begin_parse();\r\n  int flags = cs~load_uint(4);\r\n  if (flags & 1) {\r\n    on_bounce(in_msg_body);\r\n    return ();\r\n  }\r\n  slice sender_address = cs~load_msg_addr();\r\n  cs~load_msg_addr(); ;; skip dst\r\n  cs~load_coins(); ;; skip value\r\n  cs~skip_bits(1); ;; skip extracurrency collection\r\n  cs~load_coins(); ;; skip ihr_fee\r\n  int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs \r\n\r\n  int op = in_msg_body~load_uint(32);\r\n\r\n  if (op == op::transfer()) { ;; outgoing transfer\r\n    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);\r\n    return ();\r\n  }\r\n\r\n  if (op == op::internal_transfer()) { ;; incoming transfer\r\n    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value);\r\n    return ();\r\n  }\r\n\r\n  if (op == op::burn()) { ;; burn\r\n    burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);\r\n    return ();\r\n  }\r\n\r\n  throw(0xffff);\r\n}\r\n\r\n(int, slice, slice, cell, _) get_wallet_data() method_id {\r\n  return load_data();\r\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/op-codes.fc",
        "content": "int op::transfer() asm \"0xf8a7ea5 PUSHINT\";\r\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\r\nint op::internal_transfer() asm \"0x178d4519 PUSHINT\";\r\nint op::excesses() asm \"0xd53276db PUSHINT\";\r\nint op::burn() asm \"0x595f07bc PUSHINT\";\r\nint op::burn_notification() asm \"0x7bdd97de PUSHINT\";\r\n\r\n;; Minter\r\nint op::mint() asm \"21 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/jetton-utils.fc",
        "content": "cell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code, int status) inline {\r\n   return  begin_cell()\r\n            .store_coins(balance)\r\n            .store_slice(owner_address)\r\n            .store_slice(jetton_master_address)\r\n            .store_ref(jetton_wallet_code)\r\n            .store_uint(status, 32)\r\n           .end_cell();\r\n}\r\n\r\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\r\n  return begin_cell()\r\n          .store_uint(0, 2)\r\n          .store_dict(jetton_wallet_code)\r\n          .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code, 0))\r\n          .store_uint(0, 1)\r\n         .end_cell();\r\n}\r\n\r\nslice calculate_jetton_wallet_address(cell state_init) inline {\r\n  return begin_cell().store_uint(4, 3)\r\n                     .store_int(workchain(), 8)\r\n                     .store_uint(cell_hash(state_init), 256)\r\n                     .end_cell()\r\n                     .begin_parse();\r\n}\r\n\r\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\r\n  return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\r\n}\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\r\n;;\r\n\r\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\r\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\r\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\r\nforall X -> X car(tuple list) asm \"CAR\";\r\ntuple cdr(tuple list) asm \"CDR\";\r\ntuple empty_tuple() asm \"NIL\";\r\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> [X] single(X x) asm \"SINGLE\";\r\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\r\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\r\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\r\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\r\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\r\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\r\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\r\nforall X -> X first(tuple t) asm \"FIRST\";\r\nforall X -> X second(tuple t) asm \"SECOND\";\r\nforall X -> X third(tuple t) asm \"THIRD\";\r\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\r\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\r\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\r\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\r\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\r\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\r\nforall X -> X null() asm \"PUSHNULL\";\r\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\r\nconst slice_jetton = \"UQCJnVj2RrOARfAf0ccWRPTlDVQ0gtiejnce6JA86_SVNO5_\"a;\r\n\r\nint now() asm \"NOW\";\r\nslice my_address() asm \"MYADDR\";\r\n[int, cell] get_balance() asm \"BALANCE\";\r\nint cur_lt() asm \"LTIME\";\r\nint block_lt() asm \"BLOCKLT\";\r\n\r\nint cell_hash(cell c) asm \"HASHCU\";\r\nint slice_hash(slice s) asm \"HASHSU\";\r\nint string_hash(slice s) asm \"SHA256U\";\r\n\r\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\r\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\r\n\r\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\r\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\r\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n\r\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\r\n\r\n() dump_stack() impure asm \"DUMPSTK\";\r\n\r\ncell get_data() asm \"c4 PUSH\";\r\n() set_data(cell c) impure asm \"c4 POP\";\r\ncont get_c3() impure asm \"c3 PUSH\";\r\n() set_c3(cont c) impure asm \"c3 POP\";\r\ncont bless(slice s) impure asm \"BLESS\";\r\n\r\n() accept_message() impure asm \"ACCEPT\";\r\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\r\n() commit() impure asm \"COMMIT\";\r\n() buy_gas(int gram) impure asm \"BUYGAS\";\r\n\r\nint min(int x, int y) asm \"MIN\";\r\nint max(int x, int y) asm \"MAX\";\r\n(int, int) minmax(int x, int y) asm \"MINMAX\";\r\nint abs(int x) asm \"ABS\";\r\n\r\nslice begin_parse(cell c) asm \"CTOS\";\r\n() end_parse(slice s) impure asm \"ENDS\";\r\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\r\ncell preload_ref(slice s) asm \"PLDREF\";\r\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\r\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\r\n;; int preload_int(slice s, int len) asm \"PLDIX\";\r\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\r\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\r\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\r\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\r\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\r\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\r\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\r\ncell preload_dict(slice s) asm \"PLDDICT\";\r\nslice skip_dict(slice s) asm \"SKIPDICT\";\r\n\r\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\r\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\r\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\r\n\r\nint cell_depth(cell c) asm \"CDEPTH\";\r\n\r\nint slice_refs(slice s) asm \"SREFS\";\r\nint slice_bits(slice s) asm \"SBITS\";\r\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\r\nint slice_empty?(slice s) asm \"SEMPTY\";\r\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\r\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\r\nint slice_depth(slice s) asm \"SDEPTH\";\r\n\r\nint builder_refs(builder b) asm \"BREFS\";\r\nint builder_bits(builder b) asm \"BBITS\";\r\nint builder_depth(builder b) asm \"BDEPTH\";\r\n\r\nbuilder begin_cell() asm \"NEWC\";\r\ncell end_cell(builder b) asm \"ENDC\";\r\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\r\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\r\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\r\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\r\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\r\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\r\n\r\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\r\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\r\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\r\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\r\n\r\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\r\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\r\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\r\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\r\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\r\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\r\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\r\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\r\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\r\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\r\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\r\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\r\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\r\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\r\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\r\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\r\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\ncell new_dict() asm \"NEWDICT\";\r\nint dict_empty?(cell c) asm \"DICTEMPTY\";\r\n\r\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\r\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\r\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\r\n\r\n\r\nconst builder_jetton = \"UQBp4VTgYl8T6ubWIGms0q27eeMPJagUZ1Qj8VYAT-l7x3M1\"a;\r\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\r\nint cell_null?(cell c) asm \"ISNULL\";\r\n\r\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\r\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\r\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\r\n() set_code(cell new_code) impure asm \"SETCODE\";\r\n\r\nint random() impure asm \"RANDU256\";\r\nint rand(int range) impure asm \"RAND\";\r\nint get_seed() impure asm \"RANDSEED\";\r\nint set_seed() impure asm \"SETRAND\";\r\n() randomize(int x) impure asm \"ADDRAND\";\r\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\r\n\r\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\r\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\r\n\r\nint equal_slices (slice a, slice b) asm \"SDEQ\";\r\nint builder_null?(builder b) asm \"ISNULL\";\r\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "imports/utils.fc",
        "content": "() send_grams(slice address, int amount) impure {\r\n  cell msg = begin_cell()\r\n    .store_uint (0x18, 6) ;; bounce\r\n    .store_slice(address) ;; 267 bit address\r\n    .store_grams(amount)\r\n    .store_uint(0, 107) ;; 106 zeroes +  0 as an indicator that there is no cell with the data\r\n    .end_cell(); \r\n  send_raw_message(msg, 3); ;; mode, 2 for ignoring errors, 1 for sender pays fees, 64 for returning inbound message value\r\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\r\n\r\n() force_chain(slice addr) impure {\r\n  (int wc, _) = parse_std_addr(addr);\r\n  throw_unless(333, wc == workchain());\r\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/constants.fc",
        "content": ";; operations (constant values taken from crc32 on op message in the companion .tlb files and appear during build)\r\nint op::increment() asm \"0x37491f2f PUSHINT\";\r\nint op::deposit() asm \"0x47d54391 PUSHINT\";\r\nint op::withdraw() asm \"0x41836980 PUSHINT\";\r\nint op::transfer_ownership() asm \"0x2da38aaf PUSHINT\";\r\n\r\n;; errors\r\nint error::unknown_op() asm \"101 PUSHINT\";\r\nint error::access_denied() asm \"102 PUSHINT\";\r\nint error::insufficient_balance() asm \"103 PUSHINT\";\r\n\r\n;; other\r\nint const::min_tons_for_storage() asm \"10000000 PUSHINT\"; ;; 0.01 TON\r\n\r\n;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000\r\n;; ceil(6905000) = 10000000 ~= 0.01 TON\r\nint const::provide_address_gas_consumption() asm \"10000000 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}