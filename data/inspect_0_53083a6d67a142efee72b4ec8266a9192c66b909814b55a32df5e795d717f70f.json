{
  "code": "b5ee9c7201020e010001dc000114ff00f4a413f4bcf2c80b0102016202030202cd04050009a11f9fe00b02cfd1910e380492f81f068698180b8d8492f81f07d207d2018fd0018b8eb90fd0018fd001839d4da0078028259c70a1836111a29196382f970ca80fd206a180811f8037003698fe99fc1082fe61e8a29185d7181181a1a1a9ac10817e59351095d71812f824207f978406070201200a0b02ac3210375e3240135135c705f2e191fa4021f004fa40d20031fa0020d749c200f2e2c4820afaf0801ba121945315a0a1de22d70b01c300209206a19136e220c2fff2e1922194102a375be30d0293303234e30d5502f006080900727082108b77173505c8cbff5004cf1610248040708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00007c821005138d91c85009cf16500bcf16712449145446a0708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb001047006a26f0048210d53276db103744006d71708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb000201200c0d001d403c8cb3f58cf1601cf16ccc9ed54800113e910c1c2ebcb85360003b3b513434cffe900835d27080269fc07e90350c04090408f80c1c165b5b60",
  "code_hash": "d512ae8d795c61d19ba99c145cc801f9ad06de428f7529d5bc8805281e70f429",
  "methods": [
    {
      "id": 102351,
      "method": "get_nft_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "utils.fc",
        "content": "int nft_collection::heroes_size() asm \"99 PUSHINT\";\r\nint nft_collection::size() asm \"2595 PUSHINT\";\r\n\r\nint nft_collection::deploy_value() asm \"70000000 PUSHINT\";\r\n\r\nbuilder store_uint_as_dec_string (builder b, int x) asm \"\"\r\n  \"ZERO\"                                                        ;; b x i=0\r\n  \"SWAP\" \"TRUE\"                                                 ;; b i=0 x f=-1\r\n  \"WHILE:<{\"\r\n  \"}>DO<{\"                                                      ;; b i x\r\n    \"10 PUSHINT\" \"DIVMOD\"                                       ;; b i x r\r\n    \"48 ADDCONST\"                                               ;; b i x r\r\n    \"s0 s3 XCHG\"                                                   ;; r i x b\r\n    \"s0 s2 XCHG\"                                                   ;; r b x i\r\n    \"INC\"                                                       ;; r b x i\r\n    \"SWAP\"                                                      ;; r b i x\r\n    \"DUP\" \"0 NEQINT\"                                            ;; r b i x f\r\n  \"}>\"\r\n  \"DROP\"                          \r\n  \"REPEAT:<{\" \r\n    \"8 STU\"                                                     ;; ..rrr.. b i\r\n  \"}>\"  \r\n;\r\n\r\n(slice, (int)) ~nft_undeployed_pool::get_impl (slice bits, int index) inline {\r\n  builder bb = begin_cell();\r\n  int result = -1;\r\n  int i = 0;\r\n\r\n  while ( ~ slice_empty? (bits)) {\r\n    int bit = bits~load_uint(1);\r\n    result += bit;\r\n    if (result == index) {\r\n      bb~store_uint(0, 1);\r\n      bb = bb.store_slice(bits);\r\n      return ( bb.end_cell().begin_parse(), (i));\r\n    }\r\n    bb~store_uint(bit, 1);\r\n    i += 1;\r\n  }\r\n\r\n  throw(502);\r\n  return (null(), (-1));\r\n}\r\n\r\n(cell, (int)) ~nft_undeployed_pool::get (cell nft_undeployed_pool, int index) inline {\r\n  slice ps = nft_undeployed_pool.begin_parse();\r\n  cell dict = ps~load_ref();\r\n  int size = ps~load_uint(16);\r\n  int block_size = ps~load_uint(16);\r\n\r\n  builder pb = begin_cell();\r\n  pb~store_uint(size - 1, 16);\r\n  pb~store_uint(block_size, 16);\r\n\r\n  int prev_parts_size = 0;\r\n  int i = 0;\r\n\r\n  while ( ~ slice_empty?(ps)) {\r\n    int part_size = ps~load_uint(10);\r\n    prev_parts_size += part_size;\r\n    if (index < prev_parts_size) {\r\n      pb~store_uint(part_size - 1, 10);\r\n      pb = pb.store_slice(ps);\r\n\r\n      dump_stack();\r\n      (slice bits, int f) = dict.udict_get?(8, i);\r\n      throw_unless(502, f);\r\n\r\n      int result = i * block_size + bits~nft_undeployed_pool::get_impl(prev_parts_size - index - 1);\r\n      dict~udict_set(8, i, bits);\r\n      pb = pb.store_ref(dict);\r\n\r\n      return (pb.end_cell(), (result));\r\n    } else {\r\n      pb~store_uint(part_size, 10);\r\n    }\r\n    i += 1;\r\n  }\r\n\r\n  throw(502);\r\n  return (null(), (-1));\r\n}\r\n\r\nint nft_undeployed_pool::size(cell nft_undeployed_pool) inline {\r\n  return nft_undeployed_pool.begin_parse().preload_uint(16);\r\n} \r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "nft-item.fc",
        "content": ";;\r\n;;  TON NFT Item Smart Contract\r\n;;\r\n\r\n{-\r\n\r\n    NOTE that this tokens can be transferred within the same workchain.\r\n\r\n    This is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\r\n\r\n    1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\r\n\r\n    2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\r\n\r\n-}\r\n\r\nint min_tons_for_storage() asm \"50000000 PUSHINT\"; ;; 0.05 TON\r\n\r\n;;\r\n;;  Storage\r\n;;\r\n;;  uint64 index\r\n;;  MsgAddressInt collection_address\r\n;;  MsgAddressInt owner_address\r\n;;  cell content\r\n;;\r\n\r\n(int, int, slice, slice, cell) load_data() {\r\n    slice ds = get_data().begin_parse();\r\n    var (index, collection_address) = (ds~load_uint(64), ds~load_msg_addr());\r\n    if (ds.slice_bits() > 0) {\r\n      return (-1, index, collection_address, ds~load_msg_addr(), ds~load_ref());\r\n    } else {  \r\n      return (0, index, collection_address, null(), null()); ;; nft not initialized yet\r\n    }\r\n}\r\n\r\n() store_data(int index, slice collection_address, slice owner_address, cell content) impure {\r\n    set_data(\r\n        begin_cell()\r\n            .store_uint(index, 64)\r\n            .store_slice(collection_address)\r\n            .store_slice(owner_address)\r\n            .store_ref(content)\r\n            .end_cell()\r\n    );\r\n}\r\n\r\n() send_msg(slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {\r\n  var msg = begin_cell()\r\n    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000\r\n    .store_slice(to_address)\r\n    .store_coins(amount)\r\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n    .store_uint(op, 32)\r\n    .store_uint(query_id, 64);\r\n\r\n  if (~ builder_null?(payload)) {\r\n    msg = msg.store_builder(payload);\r\n  }\r\n\r\n  send_raw_message(msg.end_cell(), send_mode);\r\n}\r\n\r\n() transfer_ownership(int my_balance, int index, slice collection_address, slice owner_address, cell content, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {\r\n    throw_unless(401, equal_slices(sender_address, owner_address));\r\n\r\n    slice new_owner_address = in_msg_body~load_msg_addr();\r\n    force_chain(new_owner_address);\r\n    slice response_destination = in_msg_body~load_msg_addr();\r\n    in_msg_body~load_int(1); ;; this nft don't use custom_payload\r\n    int forward_amount = in_msg_body~load_coins();\r\n    throw_unless(708, slice_bits(in_msg_body) >= 1);\r\n\r\n    int rest_amount = my_balance - min_tons_for_storage();\r\n    if (forward_amount) {\r\n      rest_amount -= (forward_amount + fwd_fees);\r\n    }\r\n    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00\r\n    if (need_response) {\r\n      rest_amount -= fwd_fees;\r\n    }\r\n\r\n    throw_unless(402, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response\r\n\r\n    if (forward_amount) {\r\n      send_msg(new_owner_address, forward_amount, op::ownership_assigned(), query_id, begin_cell().store_slice(owner_address).store_slice(in_msg_body), 1);  ;; paying fees, revert on errors\r\n    }\r\n    if (need_response) {\r\n      force_chain(response_destination);\r\n      send_msg(response_destination, rest_amount, op::excesses(), query_id, null(), 1); ;; paying fees, revert on errors\r\n    }\r\n\r\n    store_data(index, collection_address, new_owner_address, content);\r\n}\r\n\r\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\r\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\r\n        return ();\r\n    }\r\n\r\n    slice cs = in_msg_full.begin_parse();\r\n    int flags = cs~load_uint(4);\r\n\r\n    if (flags & 1) { ;; ignore all bounced messages\r\n        return ();\r\n    }\r\n    slice sender_address = cs~load_msg_addr();\r\n\r\n    cs~load_msg_addr(); ;; skip dst\r\n    cs~load_coins(); ;; skip value\r\n    cs~skip_bits(1); ;; skip extracurrency collection\r\n    cs~load_coins(); ;; skip ihr_fee\r\n    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\r\n\r\n\r\n    (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();\r\n    if (~ init?) {\r\n      throw_unless(405, equal_slices(collection_address, sender_address));\r\n      store_data(index, collection_address, in_msg_body~load_msg_addr(), in_msg_body~load_ref());\r\n      return ();\r\n    }\r\n\r\n    int op = in_msg_body~load_uint(32);\r\n    int query_id = in_msg_body~load_uint(64);\r\n\r\n    if (op == op::transfer()) {\r\n      transfer_ownership(my_balance, index, collection_address, owner_address, content, sender_address, query_id, in_msg_body, fwd_fee);\r\n      return ();\r\n    }\r\n    if (op == op::get_static_data()) {\r\n      send_msg(sender_address, 0, op::report_static_data(), query_id, begin_cell().store_uint(index, 256).store_slice(collection_address), 64);  ;; carry all the remaining value of the inbound message\r\n      return ();\r\n    }\r\n    throw(0xffff);\r\n}\r\n\r\n;;\r\n;;  GET Methods\r\n;;\r\n\r\n(int, int, slice, slice, cell) get_nft_data() method_id {\r\n  (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();\r\n  return (init?, index, collection_address, owner_address, content);\r\n}\r\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\r\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\r\nint op::excesses() asm \"0xd53276db PUSHINT\";\r\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\r\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\r\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\r\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\r\n\r\n;; NFTEditable\r\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\r\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\r\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\r\n;;\r\n\r\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\r\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\r\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\r\nforall X -> X car(tuple list) asm \"CAR\";\r\ntuple cdr(tuple list) asm \"CDR\";\r\ntuple empty_tuple() asm \"NIL\";\r\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> [X] single(X x) asm \"SINGLE\";\r\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\r\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\r\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\r\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\r\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\r\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\r\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\r\nforall X -> X first(tuple t) asm \"FIRST\";\r\nforall X -> X second(tuple t) asm \"SECOND\";\r\nforall X -> X third(tuple t) asm \"THIRD\";\r\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\r\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\r\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\r\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\r\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\r\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\r\nforall X -> X null() asm \"PUSHNULL\";\r\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\r\n\r\nint now() asm \"NOW\";\r\nslice my_address() asm \"MYADDR\";\r\n[int, cell] get_balance() asm \"BALANCE\";\r\nint cur_lt() asm \"LTIME\";\r\nint block_lt() asm \"BLOCKLT\";\r\n\r\nint cell_hash(cell c) asm \"HASHCU\";\r\nint slice_hash(slice s) asm \"HASHSU\";\r\nint string_hash(slice s) asm \"SHA256U\";\r\n\r\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\r\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\r\n\r\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\r\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\r\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n\r\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\r\n\r\n() dump_stack() impure asm \"DUMPSTK\";\r\n\r\ncell get_data() asm \"c4 PUSH\";\r\n() set_data(cell c) impure asm \"c4 POP\";\r\ncont get_c3() impure asm \"c3 PUSH\";\r\n() set_c3(cont c) impure asm \"c3 POP\";\r\ncont bless(slice s) impure asm \"BLESS\";\r\n\r\n() accept_message() impure asm \"ACCEPT\";\r\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\r\n() commit() impure asm \"COMMIT\";\r\n() buy_gas(int gram) impure asm \"BUYGAS\";\r\n\r\nint min(int x, int y) asm \"MIN\";\r\nint max(int x, int y) asm \"MAX\";\r\n(int, int) minmax(int x, int y) asm \"MINMAX\";\r\nint abs(int x) asm \"ABS\";\r\n\r\nslice begin_parse(cell c) asm \"CTOS\";\r\n() end_parse(slice s) impure asm \"ENDS\";\r\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\r\ncell preload_ref(slice s) asm \"PLDREF\";\r\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\r\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\r\n;; int preload_int(slice s, int len) asm \"PLDIX\";\r\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\r\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\r\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\r\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\r\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\r\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\r\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\r\ncell preload_dict(slice s) asm \"PLDDICT\";\r\nslice skip_dict(slice s) asm \"SKIPDICT\";\r\n\r\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\r\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\r\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\r\n\r\nint cell_depth(cell c) asm \"CDEPTH\";\r\n\r\nint slice_refs(slice s) asm \"SREFS\";\r\nint slice_bits(slice s) asm \"SBITS\";\r\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\r\nint slice_empty?(slice s) asm \"SEMPTY\";\r\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\r\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\r\nint slice_depth(slice s) asm \"SDEPTH\";\r\n\r\nint builder_refs(builder b) asm \"BREFS\";\r\nint builder_bits(builder b) asm \"BBITS\";\r\nint builder_depth(builder b) asm \"BDEPTH\";\r\n\r\nbuilder begin_cell() asm \"NEWC\";\r\ncell end_cell(builder b) asm \"ENDC\";\r\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\r\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\r\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\r\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\r\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\r\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\r\n\r\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\r\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\r\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\r\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\r\n\r\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\r\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\r\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\r\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\r\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\r\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\r\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\r\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\r\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\r\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\r\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\r\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\r\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\r\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\r\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\r\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\r\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\ncell new_dict() asm \"NEWDICT\";\r\nint dict_empty?(cell c) asm \"DICTEMPTY\";\r\n\r\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\r\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\r\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\r\n\r\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\r\nint cell_null?(cell c) asm \"ISNULL\";\r\n\r\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\r\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\r\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\r\n() set_code(cell new_code) impure asm \"SETCODE\";\r\n\r\nint random() impure asm \"RANDU256\";\r\nint rand(int range) impure asm \"RAND\";\r\nint get_seed() impure asm \"RANDSEED\";\r\nint set_seed() impure asm \"SETRAND\";\r\n() randomize(int x) impure asm \"ADDRAND\";\r\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\r\n\r\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\r\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\r\n\r\nint equal_slices (slice a, slice b) asm \"SDEQ\";\r\nint builder_null?(builder b) asm \"ISNULL\";\r\nbuilder store_builder(builder to, builder from) asm \"STBR\";\r\n\r\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\r\n\r\n() force_chain(slice addr) impure {\r\n  (int wc, _) = parse_std_addr(addr);\r\n  throw_unless(333, wc == workchain());\r\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}