{
  "code": "b5ee9c7201021601000328000114ff00f4a413f4bcf2c80b0102016202030202cd04050201200e0f02f7d10638048adf000e8698180b8d848adf07d201800e98fe99ff6a2687d20699fa9906380e0004a187d2000ef00ea6a6a182a814108349e9ca829485d47148b2f83360968410854658056b84008646582a802e78b127d010a65b509e58fe59f80e78b64c0207d807029cae382a9d0e382d8f970c8946000f181146001406070201200a0b007037373703d33f5312bbf2e1925312ba01fa00d43029103459f0068e18a45044451503c85006cf1614cb3f12cccccc01cf16c9ed54925f06e202fc8e753737377004d45350c701c0009430d201309131e28e45018040f4966fa524c0ff25c001b193315250de208e2908a4208100fabe93f2c18fde81019321a05327bbf2f402fa00d43022544d30f00625ba9304a404de06926c21e2b312e65b335044451503c85006cf1614cb3f12cccccc01cf16c9ed54e028c003e302280809005030363606810fa103c70512f2f401fa40305423055033c85006cf1614cb3f12cccccc01cf16c9ed5400eec0048e20313235353501d4d4301025440302c85006cf1614cb3f12cccccc01cf16c9ed54e03027c0058e235f06708018c8cb055004cf1623fa0213cb6acb1fcb3f820afaf08070fb02c98306fb00e0363705c0068e1a02fa403045501413c85006cf1614cb3f12cccccc01cf16c9ed54e05f06840ff2f00201200c0d003d45af0047021f005778018c8cb0558cf165004fa0213cb6b12ccccc971fb008002d007232cffe0a33c5b25c083232c044fd003d0032c03260001b3e401d3232c084b281f2fff2742002012010110045bc82df6a2687d20699fa9906380e0004a187d2000ef00ea6a6a182a812f81e86a182c40061b8b5d31ed44d0fa40d33f5320c701c0009430fa4001de01d4d4d430550210355f05d0d431d430d071c8cb0701cf16ccc9802012012130201661415004db4f47da89a1f481a67ea6418e0380012861f48003bc03a9a9a860aa04204abe0be008e003e00b0003caa15ed44d0fa40d33f5320c701c0009430fa4001de01d4d4d43055026c51004eaad7ed44d0fa40d33f5320c701c0009430fa4001de01d4d4d4305502155f05d0d30fd30ffa4030",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            DUP\n            SEMPTY\n            IFJMP:<{\n                  2DROP\n            }>\n            SWAP\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  2DROP\n            }>\n            LDMSGADDR\n            DROP\n            SWAP\n            32 LDU\n            64 LDU\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            1765620048 PUSHINT\n            s9 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s1 s6 XCHG\n                  6 BLKDROP\n                  1 2 BLKDROP2\n                  CTOS\n                  2831876269 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s4 PUSH\n                  STGRAMS\n                  s1 s4 XCHG\n                  107 STU\n                  s1 s3 XCHG\n                  32 STU\n                  64 STU\n                  SWAP\n                  STSLICER\n                  ENDC\n                  64 PUSHINT\n                  SENDRAWMSG\n            }>\n            s9 s5 PUSH2\n            SDEQ\n            s10 s1 PUSH2\n            SDEQ\n            OR\n            401 THROWIFNOT\n            s8 PUSH\n            1 EQINT\n            IFJMP:<{\n                  s7 POP\n                  s7 POP\n                  s7 POP\n                  s0 s3 XCHG\n                  64 LDU\n                  s1 s2 PUSH2\n                  LEQ\n                  402 THROWIFNOT\n                  s1 s2 PUSH2\n                  EQUAL\n                  SWAP\n                  LDGRAMS\n                  LDREF\n                  DROP\n                  s9 PUSH\n                  s3 s4 XCHG\n                  ROTREV\n                  6 CALLDICT\n                  IF:<{\n                        INC\n                        s4 s4 XCHG2\n                        s5 s1 s5 XCHG3\n                        s0 s3 XCHG\n                        NEWC\n                        s0 s6 XCHG2\n                        STSLICER\n                        s1 s4 XCHG\n                        64 STU\n                        s1 s2 XCHG\n                        STREF\n                        STREF\n                        STREF\n                        SWAP\n                        STSLICER\n                        ENDC\n                        c4 POP\n                  }>ELSE<{\n                        6 BLKDROP\n                  }>\n            }>\n            s8 PUSH\n            2 EQINT\n            IFJMP:<{\n                  s7 POP\n                  s7 POP\n                  s7 POP\n                  0 PUSHINT\n                  s0 s4 XCHG\n                  LDREF\n                  s5 s0 PUSH2\n                  SDEMPTY\n                  0 EQINT\n                  IF:<{\n                        DROP\n                        2 LDI\n                        DROP\n                  }>ELSE<{\n                        NIP\n                  }>\n                  UNTIL:<{\n                        SWAP\n                        64 PUSHINT\n                        DICTUREMMIN\n                        NULLSWAPIFNOT2\n                        s4 PUSH\n                        -1 EQINT\n                        s5 PUSH\n                        1 EQINT\n                        OR\n                        IF:<{\n                              NIP\n                              s5 s(-1) PUXC\n                        }>\n                        DUP\n                        IF:<{\n                              s0 s8 XCHG\n                              INC\n                              DUP\n                              250 PUSHINT\n                              GEQ\n                              IF:<{\n                                    399 THROW\n                              }>\n                              403 PUSHINT\n                              OVER\n                              ADD\n                              s2 s7 PUSH2\n                              LEQ\n                              THROWANYIFNOT\n                              s0 s2 XCHG\n                              LDGRAMS\n                              LDREF\n                              DROP\n                              s2 PUSH\n                              s13 s2 s(-1) PUXC2\n                              6 CALLDICT\n                              s5 PUSH\n                              EQUAL\n                              IF:<{\n                                    s0 s4 XCHG\n                                    INC\n                                    s0 s4 XCHG\n                              }>\n                              s0 s6 XCHG\n                        }>ELSE<{\n                              2 1 BLKDROP2\n                        }>\n                        NOT\n                        s1 s2 XCHG\n                  }>\n                  2DROP\n                  s3 POP\n                  s4 s4 XCHG2\n                  s5 s1 s5 XCHG3\n                  s0 s3 XCHG\n                  NEWC\n                  s0 s6 XCHG2\n                  STSLICER\n                  s1 s4 XCHG\n                  64 STU\n                  s1 s2 XCHG\n                  STREF\n                  STREF\n                  STREF\n                  SWAP\n                  STSLICER\n                  ENDC\n                  c4 POP\n            }>\n            s8 PUSH\n            3 EQINT\n            IFJMP:<{\n                  DROP\n                  s6 POP\n                  s6 POP\n                  s0 s6 XCHG\n                  4001 PUSHINT\n                  s0 s3 XCHG\n                  SDEQ\n                  s1 s2 XCHG\n                  THROWANYIFNOT\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  s3 s0 s4 XCPUXC\n                  s3 s3 XCHG2\n                  NEWC\n                  s0 s6 XCHG2\n                  STSLICER\n                  s1 s4 XCHG\n                  64 STU\n                  s1 s2 XCHG\n                  STREF\n                  STREF\n                  STREF\n                  SWAP\n                  STSLICER\n                  ENDC\n                  c4 POP\n            }>\n            s8 PUSH\n            4 EQINT\n            IFJMP:<{\n                  NIP\n                  s2 POP\n                  s5 POP\n                  s5 POP\n                  s5 POP\n                  SWAP\n                  LDREF\n                  LDREF\n                  DROP\n                  s2 s5 XCHG\n                  s4 s0 s3 XCHG3\n                  s0 s2 XCHG\n                  NEWC\n                  s0 s6 XCHG2\n                  STSLICER\n                  s1 s4 XCHG\n                  64 STU\n                  s1 s2 XCHG\n                  STREF\n                  STREF\n                  STREF\n                  SWAP\n                  STSLICER\n                  ENDC\n                  c4 POP\n            }>\n            DROP\n            s7 PUSH\n            5 EQINT\n            IFJMP:<{\n                  6 BLKDROP\n                  0 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s4 XCHG2\n                  STSLICER\n                  s3 PUSH\n                  STGRAMS\n                  s1 s3 XCHG\n                  107 STU\n                  32 STU\n                  64 STU\n                  50000000 PUSHINT\n                  0 PUSHINT\n                  RAWRESERVE\n                  ENDC\n                  7 PUSHPOW2\n                  SENDRAWMSG\n            }>\n            s6 POP\n            s7 POP\n            s0 s5 XCHG\n            6 EQINT\n            IFJMP:<{\n                  s0 s2 XCHG\n                  LDMSGADDR\n                  DROP\n                  s5 s5 s0 XCHG3\n                  s1 s4 XCHG\n                  s1 s3 XCHG\n                  NEWC\n                  s0 s6 XCHG2\n                  STSLICER\n                  s1 s4 XCHG\n                  64 STU\n                  s1 s2 XCHG\n                  STREF\n                  STREF\n                  STREF\n                  SWAP\n                  STSLICER\n                  ENDC\n                  c4 POP\n            }>\n            6 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      4 => <{\n            SWAP\n            NEWC\n            64 STU\n            MYADDR\n            STSLICER\n            ENDC\n            0 PUSHINT\n            DUP\n            NEWC\n            2 STU\n            s1 s3 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n      }>\n      5 => <{\n            HASHCU\n            4 PUSHINT\n            NEWC\n            3 STU\n            s1 s2 XCHG\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n      }>\n      6 => <{\n            2SWAP\n            4 CALLDICT\n            0 PUSHINT\n            OVER\n            5 CALLDICT\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            ROT\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s3 XCHG\n            108 STU\n            s1 s2 XCHG\n            STREF\n            STREF\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n      }>\n      68445 => <{\n            NIP\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            s3 s5 XCHG\n            5 BLKDROP\n            CTOS\n            LDREF\n            NIP\n            LDREF\n            DROP\n            CTOS\n            1 PUSHINT\n            NEWC\n            8 STU\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n      }>\n      84501 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            5 1 BLKDROP2\n      }>\n      85719 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            s1 s5 XCHG\n            5 BLKDROP\n            CTOS\n            16 LDU\n            16 LDU\n            LDMSGADDR\n            DROP\n      }>\n      92067 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            s2 s5 XCHG\n            5 BLKDROP\n            4 CALLDICT\n            0 PUSHINT\n            SWAP\n            5 CALLDICT\n      }>\n      102491 => <{\n            c4 PUSH\n            CTOS\n            LDMSGADDR\n            64 LDU\n            s2 s0 PUSH2\n            SDEMPTY\n            0 EQINT\n            IF:<{\n                  DROP\n                  LDMSGADDR\n                  SWAP\n            }>\n            SWAP\n            LDREF\n            LDREF\n            LDREF\n            DROP\n            1 3 BLKSWAP\n            3 BLKDROP\n            CTOS\n            LDREF\n            DROP\n            ROT\n      }>\n}\n11 THROWARG",
  "code_hash": "0b84497ccefe297d00beebb08a544cc6ef6230eab762692ca053fa9811399836",
  "methods": [
    {
      "id": 92067,
      "method": "get_nft_address_by_index"
    },
    {
      "id": 102491,
      "method": "get_collection_data"
    },
    {
      "id": 68445,
      "method": "get_nft_content"
    },
    {
      "id": 85719,
      "method": "royalty_params"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == workchain());\n}\n\nslice null_addr() asm \"b{00} PUSHSLICE\";\nint flag::regular() asm \"0x10 PUSHINT\";\nint flag::bounce() asm \"0x8 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "nft-collection-editable-v2.fc",
        "content": ";; NFT collection smart contract v2\n;; + return collection balance (op = 5)\n;; + support mint nft with next_item_id (op = 2 + int flag after query_id)\n;; + second owner and change of it (op = 6)\n\n(slice, int, cell, cell, cell, slice) load_data() inline {\n  var ds = get_data().begin_parse();\n  var owner = ds~load_msg_addr();\n  var next_id = ds~load_uint(64);\n  var second_owner = owner;\n  if (ds.slice_data_empty?() == false) {\n    second_owner = ds~load_msg_addr();\n  }\n  return\n    (owner, ;; owner_address\n     next_id, ;; next_item_index\n     ds~load_ref(), ;; content\n     ds~load_ref(), ;; nft_item_code\n     ds~load_ref(),  ;; royalty_params\n     second_owner\n     );\n}\n\n() save_data(slice owner_address, int next_item_index, cell content, cell nft_item_code, cell royalty_params, slice second_owner) impure inline {\n  set_data(begin_cell()\n    .store_slice(owner_address)\n    .store_uint(next_item_index, 64)\n    .store_ref(content)\n    .store_ref(nft_item_code)\n    .store_ref(royalty_params)\n    .store_slice(second_owner)\n    .end_cell());\n}\n\ncell calculate_nft_item_state_init(int item_index, cell nft_item_code) {\n  cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();\n  return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();\n}\n\nslice calculate_nft_item_address(int wc, cell state_init) {\n  return begin_cell().store_uint(4, 3)\n                     .store_int(wc, 8)\n                     .store_uint(cell_hash(state_init), 256)\n                     .end_cell()\n                     .begin_parse();\n}\n\n() deploy_nft_item(int item_index, cell nft_item_code, int amount, cell nft_content) impure {\n  cell state_init = calculate_nft_item_state_init(item_index, nft_item_code);\n  slice nft_address = calculate_nft_item_address(workchain(), state_init);\n  var msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(nft_address)\n            .store_coins(amount)\n            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n            .store_ref(state_init)\n            .store_ref(nft_content);\n  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() send_royalty_params(slice to_address, int query_id, slice data) impure inline {\n  var msg = begin_cell()\n    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n    .store_slice(to_address)\n    .store_coins(0)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(op::report_royalty_params(), 32)\n    .store_uint(query_id, 64)\n    .store_slice(data);\n  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message\n}\n\n() recv_internal(cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    var (owner_address, next_item_index, content, nft_item_code, royalty_params, second_owner_address) = load_data();\n\n    if (op == op::get_royalty_params()) {\n        send_royalty_params(sender_address, query_id, royalty_params.begin_parse());\n        return ();\n    }\n\n    throw_unless(401, (equal_slices(sender_address, owner_address) | equal_slices(sender_address, second_owner_address)));\n\n\n    if (op == 1) { ;; deploy new nft\n      int item_index = in_msg_body~load_uint(64);\n      throw_unless(402, item_index <= next_item_index);\n      var is_last = item_index == next_item_index;\n      deploy_nft_item(item_index, nft_item_code, in_msg_body~load_coins(), in_msg_body~load_ref());\n      if (is_last) {\n        next_item_index += 1;\n        save_data(owner_address, next_item_index, content, nft_item_code, royalty_params, second_owner_address);\n      }\n      return ();\n    }\n    if (op == 2) { ;; batch deploy of new nfts\n      int counter = 0;\n      cell deploy_list = in_msg_body~load_ref();\n      int use_next_item_index = 0;\n      if (in_msg_body.slice_data_empty?() == false) {\n        use_next_item_index = in_msg_body~load_int(2);\n      }\n      do {\n        var (item_index, item, f?) = deploy_list~udict::delete_get_min(64);\n        if ((use_next_item_index == true) | (use_next_item_index == 1)) {\n          item_index = next_item_index;\n        }\n        if (f?) {\n          counter += 1;\n          if (counter >= 250) { ;; Limit due to limits of action list size\n            throw(399);\n          }\n\n          throw_unless(403 + counter, item_index <= next_item_index);\n          deploy_nft_item(item_index, nft_item_code, item~load_coins(), item~load_ref());\n          if (item_index == next_item_index) {\n            next_item_index += 1;\n          }\n        }\n      } until ( ~ f?);\n      save_data(owner_address, next_item_index, content, nft_item_code, royalty_params, second_owner_address);\n      return ();\n    }\n    if (op == 3) { ;; change owner\n      ;; second owner address cant change \"primary address\"\n      throw_unless(4001, equal_slices(sender_address, owner_address));\n      slice new_owner = in_msg_body~load_msg_addr();\n      ;; also change second owner address if owner change\n      save_data(new_owner, next_item_index, content, nft_item_code, royalty_params, new_owner);\n      return ();\n    }\n    if (op == 4) { ;; change content\n      save_data(owner_address, next_item_index, in_msg_body~load_ref(), nft_item_code, in_msg_body~load_ref(), second_owner_address);\n      return ();\n    }\n    if (op == 5) { ;; return collection balance\n      var msg = begin_cell()\n              .store_uint(0x18, 6)\n              .store_slice(sender_address)\n              .store_coins(0)\n              .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n              .store_uint(op, 32)\n              .store_uint(query_id, 64);\n      raw_reserve(50000000, 0); ;; 0.05 TON\n      send_raw_message(msg.end_cell(), 128); ;; return all non reserve balance\n      return ();\n    }\n    if (op == 6) { ;; change owner\n      slice new_second_owner = in_msg_body~load_msg_addr();\n      save_data(owner_address, next_item_index, content, nft_item_code, royalty_params, new_second_owner);\n      return ();\n    }\n    throw(0xffff);\n}\n\n;; Get methods\n\n(int, cell, slice) get_collection_data() method_id {\n  var (owner_address, next_item_index, content, _, _, _) = load_data();\n  slice cs = content.begin_parse();\n  return (next_item_index, cs~load_ref(), owner_address);\n}\n\nslice get_nft_address_by_index(int index) method_id {\n    var (_, _, _, nft_item_code, _, _) = load_data();\n    cell state_init = calculate_nft_item_state_init(index, nft_item_code);\n    return calculate_nft_item_address(0, state_init);\n}\n\n(int, int, slice) royalty_params() method_id {\n     var (_, _, _, _, royalty, _) = load_data();\n     slice rs = royalty.begin_parse();\n     return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());\n}\n\ncell get_nft_content(int index, cell individual_nft_content) method_id {\n  var (_, _, content, _, _, _) = load_data();\n  slice cs = content.begin_parse();\n  cs~load_ref();\n  slice common_content = cs~load_ref().begin_parse();\n  return (begin_cell()\n                      .store_uint(1, 8) ;; offchain tag\n                      .store_slice(common_content)\n                      .store_ref(individual_nft_content)\n          .end_cell());\n}\n\n(slice) get_second_owner_address() method_id {\n  var (_, _, _, _, _, second_owner_address) = load_data();\n  return (second_owner_address);\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}