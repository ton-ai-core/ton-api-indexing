{
  "code": "b5ee9c7201020f01000262000114ff00f4a413f4bcf2c80b0102012002030201480405036af230db3c5335a127a904f82327a128a90401bc5135a0f823b913b0f29ef800725210be945387f0078e855386db3ca4e2f82302db3c0b0c0d0202cd06070121a0d0c9b67813f488de0411f488de0410130b048fd6d9e05e8698198fd201829846382c74e2f841999e98f9841083239ba395d497803f018b841083ab735bbed9e702984e382d9c74688462f863841083ab735bbed9e70156ba4e09040b0a0a080269f10fd22184093886d9e7c12c1083239ba39384008646582a803678b2801fd010a65b5658f89659fe4b9fd803fc1083239ba396d9e40e0a04f08e8d108c5f0c708210756e6b77db3ce00ad31f308210706c7567831eb15210ba8f48305324a126a904f82326a127a904bef27109fa4430a619f833d078d721d70b3f5260a11bbe8e923036f82370708210737562732759db3c5077de106910581047103645135042db3ce0395f076c2232821064737472ba0a0a0d09011a8e897f821064737472db3ce0300a006821b39982100400000072fb02de70f8276f118010c8cb055005cf1621fa0214f40013cb6912cb1f830602948100a032dec901fb000030ed44d0fa40fa40fa00d31fd31fd31fd31fd31fd307d31f30018021fa443020813a98db3c01a619f833d078d721d70b3fa070f8258210706c7567228018c8cb055007cf165004fa0215cb6a12cb1f13cb3f01fa02cb00c973fb000e0040c8500acf165008cf165006fa0214cb1f12cb1fcb1fcb1fcb1fcb07cb1fc9ed54005801a615f833d020d70b078100d1ba95810088d721ded307218100ddba028100deba12b1f2e047d33f30a8ab0f",
  "code_hash": "52161446bb3e6f811f3ceb163c8be33710fe41086c3a047ee928c2d94743fc2d",
  "methods": [
    {
      "id": 92260,
      "method": "get_subscription_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "simple-subscription-plugin.fc",
        "content": "#pragma version =0.2.0;\n;; Simple subscription plugin for wallet-v4\n;; anyone can ask to send a subscription payment\n\n(int) slice_data_equal?(slice s1, slice s2) asm \"SDEQ\";\n\nint op:destruct() asm \"0x64737472 PUSHINT\";\nint op:payment_request() asm \"0x706c7567 PUSHINT\";\nint op:fallback() asm \"0x756e6b77 PUSHINT\";\nint op:subscription() asm \"0x73756273 PUSHINT\";\nint max_failed_attempts() asm \"2 PUSHINT\";\nint max_reserved_funds() asm \"67108864 PUSHINT\"; ;; 0.0671 TON\n\nint short_msg_fwd_fee(int workchain) inline {\n  int config_index = 25 + workchain;\n  int lump_price = config_param(config_index).begin_parse().skip_bits(8).preload_uint(64);\n  return lump_price;\n}\n\nint gas_to_coins(int workchain, int gas) inline_ref {\n  int config_index = 21 + workchain;\n  var cs = config_param(config_index).begin_parse();\n  if (cs.preload_uint(8) == 0xd1) { ;; gas_flat_pfx\n    cs~skip_bits(8 + 64 + 64);\n  }\n  int tag = cs~load_uint(8);\n  throw_unless(71, (tag == 0xdd) | (tag == 0xde)); ;; gas_prices or gas_prices_ext\n  int gas_price = cs~load_uint(64);\n  return (gas * gas_price) >> 16;\n}\n\n;; storage$_ wallet:MsgAddressInt\n;;           beneficiary:MsgAddressInt\n;;           amount:Grams\n;;           period:uint32 start_time:uint32 timeout:uint32\n;;           last_payment_time:uint32\n;;           last_request_time:uint32\n;;           failed_attempts:uint8\n;;           subscription_id:uint32 = Storage;\n\n(slice, slice, int, int, int, int, int, int, int, int) load_storage() impure inline_ref {\n  var ds = get_data().begin_parse();\n  return (ds~load_msg_addr(), ds~load_msg_addr(), ds~load_grams(),\n          ds~load_uint(32), ds~load_uint(32), ds~load_uint(32),\n          ds~load_uint(32), ds~load_uint(32), ds~load_uint(8), ds~load_uint(32));\n}\n\n() save_storage(slice wallet, slice beneficiary, int amount,\n                int period, int start_time, int timeout, int last_payment_time,\n                int last_request_time, int failed_attempts, int subscription_id) impure inline_ref {\n  set_data(begin_cell()\n    .store_slice(wallet)\n    .store_slice(beneficiary)\n    .store_grams(amount)\n    .store_uint(period, 32)\n    .store_uint(start_time, 32)\n    .store_uint(timeout, 32)\n    .store_uint(last_payment_time, 32)\n    .store_uint(last_request_time, 32)\n    .store_uint(failed_attempts, 8)\n    .store_uint(subscription_id, 32) ;; to differ subscriptions to the same beneficiary (acts as a nonce)\n  .end_cell());\n}\n\n() forward_funds(slice beneficiary, int self_destruct?, int op) impure inline_ref {\n  if ~(self_destruct?) {\n    raw_reserve(max_reserved_funds(), 2); ;; reserve at most `max_reserved_funds` nanocoins\n  }\n  var msg = begin_cell()\n      .store_uint(0x10, 6) ;; non-bounce message\n      .store_slice(beneficiary)\n      .store_grams(0)\n      .store_dict(pair_second(get_balance()))\n      .store_uint(0, 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(op, 32);\n  int mode = 128; ;; carry all the remaining balance of the current smart contract\n  if (self_destruct?) {\n    mode += 32; ;; must be destroyed if its resulting balance is zero\n  }\n  send_raw_message(msg.end_cell(), mode);\n}\n\n() request_payment(slice wallet, int requested_amount) impure inline_ref {\n  (int wc, _) = wallet.parse_std_addr();\n  int amount = gas_to_coins(wc, 15000) + short_msg_fwd_fee(wc);\n\n  var msg = begin_cell().store_uint(0x18, 6)\n                        .store_slice(wallet)\n                        .store_grams(amount)\n                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                        .store_uint(op:payment_request(), 32) ;; request op\n                        .store_uint(cur_lt(), 64) ;; query_id\n                        .store_grams(requested_amount)\n                        .store_uint(0, 1); ;; empty extra\n  send_raw_message(msg.end_cell(), 3);\n}\n\n() self_destruct(slice wallet, slice beneficiary) impure {\n  ;; send event to wallet\n  (int wc, _) = wallet.parse_std_addr();\n  int amount = gas_to_coins(wc, 10000);\n\n  var msg = begin_cell().store_uint(0x10, 6) ;; non-bounce - we dont need answer from wallet\n                        .store_slice(wallet)\n                        .store_grams(amount)\n                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                        .store_uint(op:destruct(), 32) ;; request op\n                        .store_uint(cur_lt(), 64); ;; query_id\n  send_raw_message(msg.end_cell(), 3);\n\n  ;; forward all the remaining funds to the beneficiary & destroy\n\n  forward_funds(beneficiary, true, op:destruct());\n}\n\n() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {\n  var (wallet, beneficiary, amount, period, start_time, timeout, last_payment_time, last_request_time, failed_attempts, subscription_id) = load_storage();\n  var cs = in_msg_cell.begin_parse();\n  var flags = cs~load_uint(4);\n  slice s_addr = cs~load_msg_addr();\n\n  if (slice_data_equal?(s_addr, beneficiary)) {\n    int op = in_msg~load_uint(32);\n    if (op == op:destruct()) {\n        ;; end subscription\n        return self_destruct(wallet, beneficiary);\n    }\n    return forward_funds(beneficiary, false, op:fallback());\n  }\n  if (~ slice_data_equal?(s_addr, wallet)) {\n    return forward_funds(beneficiary, false, op:fallback());\n  }\n  if (in_msg.slice_bits() < 32) {\n    return forward_funds(beneficiary, false, op:fallback());\n  }\n  int op = in_msg~load_uint(32);\n\n  if (op == (op:payment_request() | 0x80000000)) {\n    int last_timeslot = (last_payment_time - start_time) / period;\n    int cur_timeslot = (now() - start_time) / period;\n    throw_if(49, last_timeslot >= cur_timeslot);\n    (int from_wc, _) = s_addr.parse_std_addr();\n\n    if (msg_value >= amount - short_msg_fwd_fee(from_wc) ) {\n      last_payment_time = now();\n      failed_attempts = 0;\n      forward_funds(beneficiary, false, op:subscription());\n    }\n\n    return save_storage(wallet, beneficiary, amount, period, start_time, timeout, last_payment_time, last_request_time, failed_attempts, subscription_id);\n  }\n  if (op == op:destruct()) { ;; self-destruct\n    ;; forward all the remaining funds to the beneficiary & destroy\n    return forward_funds(beneficiary, true, op:destruct());\n  }\n}\n\n() recv_external(slice in_msg) impure {\n  var (wallet, beneficiary, amount, period, start_time, timeout, last_payment_time, last_request_time, failed_attempts, subscription_id) = load_storage();\n  int last_timeslot = (last_payment_time - start_time) / period;\n  int cur_timeslot = (now() - start_time) / period;\n  throw_unless(30, (cur_timeslot > last_timeslot) & (last_request_time + timeout < now())); ;; too early request\n  accept_message();\n  if (failed_attempts >= max_failed_attempts()) {\n    self_destruct(wallet, beneficiary);\n  } else {\n    request_payment(wallet, amount);\n    failed_attempts += 1;\n  }\n  save_storage(wallet, beneficiary, amount, period, start_time, timeout, last_payment_time, now(), failed_attempts, subscription_id);\n}\n\n;; Get methods\n\n([int, int], [int, int], int, int, int, int, int, int, int, int) get_subscription_data() method_id {\n  var (wallet, beneficiary, amount, period, start_time, timeout, last_payment_time, last_request_time, failed_attempts, subscription_id) = load_storage();\n  return (pair(parse_std_addr(wallet)), pair(parse_std_addr(beneficiary)),\n          amount, period, start_time, timeout, last_payment_time, last_request_time, failed_attempts, subscription_id);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}