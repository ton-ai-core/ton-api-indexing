{
  "code": "b5ee9c7201024301001279000114ff00f4a413f4bcf2c80b0102016202030202c90e0f02012004050135bea98780efc20ed9e7c26fc27112cd4c23350906080c9adb810704200201200607020120080901cbbb019f01df849f849db3cf84ef84ef84da1a986a4f84df84e2259a98401f841f849f84af842f84bf843f84cf84df84ef845f846f84ff847f850f852f853f8541110111211100f11110f0e11100e10df10ce10bd10ac109b108a1079106810571046103510248200201580a0b0201200c0d006dadbcf80efc147c22382a3002098a81e46581ac7d0100e78b00e78b6490e4658089fa00097a00658064fc80383a6465816503e5ffe4e840001baf16f80efc20bffc217c21fc224000fbb3c1bc077e107000245c239c3e107e1260840ee6b2802a0060840ee6b2802a28483c0da08c01280f39a34855557e12208c03782dace9d900002a610068208c01280f39a34855557e1260840ee6b2802a208c03782dace9d900002a611628208030d60870003cbca08c03782dace9d90000006a6120840ee6b2802a4138a00291b09d3c07483e127e10687e137e1389166a61144ce87e1076cf14c06f23a744d7c0fe104868148436cf3e13be13be13686a61be137e1388966a6116648c40788c08304064d6dc083820182002012010110097b0bf0508806e0a8c008262a07919606b1f404039e2c039e2d924391960227e80025e80196019241f200e0e9919605940f97ff93a0ef003191960ab19e2ca009f4042796d625999992e3f60100201201213020120292a04e3d0cc8b1c02497c0f83434c0c05c6c2497c0f83e900c00b4c7f4cffc0748a0842bdd434d2eb8c088a0841a3a1c3faeb8c08cc8608413560d526eb8c0887005638a16fe1084b1c17cb8127e903e80350c0834201835c87e800c3e11040d1410bc117e1040683e187c07b80860841ef765f7aea1415161702016e272803fe32f84fc000f2d2c722820afaf080b9f2d2c502820afaf080a101fa00f40420c700b3963504fa4030049130e22220f849f841a1f84df84e2459a9845133a1f841db3c5301bc8e9d135f03f84121a05210db3cf84ef84ef84da1a986f84df84e2259a98459923101e25215b921b1c101f2d2c35143a1f84125a0f861f847534218201902fe6c21f84fc000f2d2c7fa00fa00fa40f40430f828f844235970546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c9f9007074c8cb02ca07cbffc9d05006c705f2e2c903820afaf080b9f2d2c5f8495220bcf2d2ca21f841db3cf84df84e2259a98466a15203b9f2d2c3f84123a1f861f8475321a0202100c83101fa4030f828f84470546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c9f9007074c8cb02ca07cbffc9d022c705f2e2c9f84fc001f2d2c88210a8ce3fe7708010c8cb055004cf1623fa0213cb6a12cb1fcb3fc98040fb0001f68e773101fa00fa40f828f844102370546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c9f9007074c8cb02ca07cbffc9d05004c705f2e04af84101a1f86101fa403020d70b01c3008e1f8210d53276db708010c8cb055003cf1622fa0212cb6acb1fcb3fc98042fb00915be2f01ee0212301d40182103b9aca00a80182103b9aca00a8f84982103b9aca00a801a120f036823004a03ce68d215555f84982103b9aca00a882300de0b6b3a7640000a98458a0522082300de0b6b3a7640000a984823004a03ce68d215555f84882300de0b6b3a7640000a9845003a001a02201fea1a0f867f823f86653128210fdaa7c9d708010c8cb05f84ccf165004fa0213cb6a12cb1ff400c98011fb008210cd78325dc8cb1f27cf1624fa0225fa02f841fa02f847fa0213f40070800cc8cb03cb6301cf17c970fb00f841f849be20983132820afaf080a09a5033a1f82ca08014fb02e22192801093810090e2250510361a01e25970208210178d4519c8cb1f15cb3f5006fa0213cb015003cf1623fa0213cb00c9f828f844102570546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c920f9007074c8cb02ca07cbffc9d0778018c8cb0558cf165003fa0212cb6bcc12ccc901fb00e300f01e1b02ea70f86ff84782102160ec00a1821005f5e100a1820afaf080a1f852a1f84adb3cf841f84aa0f861f852c2008e25f852f8508210fdaa7c9d708010c8cb05f84ccf165004fa0213cb6a12cb1ff400c98011fb00de20db3c82100f6ab54fc8cb1f01fa02f84afa0270800cc8cb03cb6301cf17c970fb001c1d01f4f853f828f84470546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c920f9007074c8cb02ca07cbffc9d06d71c821fa02f828cf16cb0070fa02f400c9843f821037c096dfc8cb1ff854cf16f828cf16f828cf16cb3fccc9708210178d4519c8cb1fcb3f5004fa02f828cf16f828cf161e01f4f853f828f84470546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c9f9007074c8cb02ca07cbffc9d06d71c821fa02f828cf16cb0070fa02f400c9843f821037c096dfc8cb1f5003cf16f828cf16f828cf1612cb3fccc9708209f3835d218018c8cb05f854cf162582100f7f4900a01f004e82100e4e1c00fa0213f400c9778018c8cb055004cf16821011e1a300fa0213cb6bccccc971fb00002afa02cb6acb1fcb3f58fa02f828cf16f400c971fb0001d282103b9aca00a80182103b9aca00a8f84982103b9aca00a858a120f036823004a03ce68d215555f84882300de0b6b3a7640000a98401a0522082300de0b6b3a7640000a984823004a03ce68d215555f84982103b9aca00a882300de0b6b3a7640000a9845003a001a02200cca1f867f823f8665ca0f82ca1801cfb02248210fdaa7c9d708010c8cb05f84ccf165004fa0213cb6a12cb1ff400c98011fb0082105e97d116c8cb1f23cf1601fa0201fa02f841fa02f847fa0212f40070800cc8cb03cb6301cf17c970fb0070810090f03ff01e003c8200c35821c000f2f282300de0b6b3a764000001a98482103b9aca00a90403fe82102c76b973bae302302082104d5f2ccaba8e1630f8425220c705f2e2cbfa4030f862f01e708040f03fe02082107fbd764eba8e1630f84b5220c705f2e2ccfa4030f86bf01e708040f03fe0208210fadc0412ba8e1730f8425220c705f84b13c70512b1f2e2cbd430f863f01ee02082104b89c3d4bae3022082109c0f322024252600f83101fa40d2000101d195c821cf16c9916de2c8801001cb055004cf1670fa027001cb6a8210d173540001cb1f5801cb3f21fa4430c0008e36f828f844102370546004131503c8cb0358fa0201cf1601cf16c921c8cb0113f40012f400cb00c9f9007074c8cb02ca07cbffc9d0cf1695317001cb01e2f400c98050fb00004230f8425220c705f2e2cbfa4001f86cd30f01f86dd30f01f86ed1708040f03ff01e00e0ba8e1330f8425220c705f2e2cbd4d1fb04708040f03fe020821046e9f1dbba8e1330f8425220c705f2e2cbd4d1ed54708040f03fe0208210bd9d1e7dba8e1730f8425220c705f2e2cbd4d4d101fb04ed54708040f03fe06c21208210d372158cba9130e08210d53276dbbadc840ff2f000db5ed44d0fa0001f861fa4001f862d401f863d401f864d31f01f865d31f01f866fa0001f867fa0001f868d401d0fa0001f869fa0001f86afa4001f86bfa4001f86cd30f01f86dd30f01f86ed30001f86fd401f870d33f01f871fa0001f872d401d0fa4001f873fa4001f874d1d1d1800af4c8f853cf16f854cf16c9f851f850f84ff84ef84dc8f849fa02f84afa02f84bcf16f84ccf16cb0fcb0fcb00cccb3ff852fa02ccc9f846f845f844f843c8f841fa02f842cf16cccccb1fcb1ff847fa02f848fa02ccc9ed5480201202b2c02012040410143b44104601bc16d674ec80001731c2304601bc16d674ec80000a4055309e04547c61d2d0135bc4104601bc16d674ec8000175366104604b728dd78166c2e7c61d3601fe702182b05803bcc5cb9634ba4cfb2213f784019318ed4dcb6017880faa35be8e23308288195e54c5dd42177f53a27172fa9ec630262827aa23a904821b782dace9d9aa18de2182708bcc0026baae9e45e470190267a230cfaa18be8e1c0182501425982cf597cd205cef7380a90401821b782dace9d9aa17a0dea76401a7642e01f2208261855144814a7ff805980ff0084000be8e2a8238056bc75e2d631000008261855144814a7ff805980ff0084000a98401822056bc75e2d631aa18a001de20824adf0ab5a80a22c61ab5a700be8e278238056bc75e2d63100000824adf0ab5a80a22c61ab5a700a98401822056bc75e2d631aa17a001de202f02f882403f1fce3da636ea5cf850be8e268238056bc75e2d6310000082403f1fce3da636ea5cf850a98401822056bc75e2d631aa16a001de20823927fa27722cc06cc5e2be8e268238056bc75e2d63100000823927fa27722cc06cc5e2a98401823815af1d78b58c400000a001de208238280e60114edb805d03bee300203031004c8238056bc75e2d631000008238280e60114edb805d03a9840182380ad78ebc5ac6200000a00102f482380ebc5fb41746121110be8e268238056bc75e2d6310000082380ebc5fb41746121110a984018238056bc75e2d63100000a001de20823808f00f760a4b2db55dbe8e258238056bc75e2d63100000823808f00f760a4b2db55da984018232b5e3af16b1880000a001de20823806f5f1775788937937bee300203233004a8238056bc75e2d63100000823806f5f1775788937937a9840182315af1d78b58c40000a00101ec823806248f33704b286603be8e258238056bc75e2d63100000823806248f33704b286603a984018230ad78ebc5ac620000a001de20823805c548670b9510e7acbe8e258238056bc75e2d63100000823805c548670b9510e7aca98401823056bc75e2d6310000a001de208238056bc75e2d63100000a13401fe8238056bc75e2d631000005122a012a98453008238056bc75e2d63100000a9845c8238056bc75e2d63100000a9842073a90413a051218238056bc75e2d63100000a9842075a90413a051218238056bc75e2d63100000a9842077a90413a051218238056bc75e2d63100000a9842079a90413a0598238056bc75e2d6310000035001ca984800ba904a0aa00a08064a90402fc8200c354218235c702bd3a30fc0000be228238070c1cc73b00c80000bbb0f2f420c1008e1282300de0b6b3a76400005202a3f02e12a984e020821b782dace9d9aa18be8e2820821b782dace9d9aa17be8e18821b782dace9d9aa17a182501425982cf597cd205cef73809171e2e30d01a7648238056bc75e2d631000002137380042821b782dace9d9aa18a18288195e54c5dd42177f53a27172fa9ec630262827aa2303fc822056bc75e2d631aa18be8e1c30822056bc75e2d631aa18a18261855144814a7ff805980ff0084000de21822056bc75e2d631aa17be8e2701822056bc75e2d631aa17a101824adf0ab5a80a22c61ab5a7008238056bc75e2d63100000a984de21822056bc75e2d631aa16bee30021823815af1d78b58c400000bee30021393a3b004c01822056bc75e2d631aa16a10182403f1fce3da636ea5cf8508238056bc75e2d63100000a984004c01823815af1d78b58c400000a101823927fa27722cc06cc5e28238056bc75e2d63100000a98402f482380ad78ebc5ac6200000be8e260182380ad78ebc5ac6200000a1018238280e60114edb805d038238056bc75e2d63100000a984de218238056bc75e2d63100000be8e26018238056bc75e2d63100000a10182380ebc5fb417461211108238056bc75e2d63100000a984de218232b5e3af16b1880000bee300213c3d004a018232b5e3af16b1880000a101823808f00f760a4b2db55d8238056bc75e2d63100000a98401ec82315af1d78b58c40000be8e250182315af1d78b58c40000a101823806f5f17757889379378238056bc75e2d63100000a984de218238056bc75e2d6310000021a0511382380ad78ebc5ac6200000a98466a0511382381043561a8829300000a98466a05113823815af1d78b58c400000a98466a051133e01ea82381b1ae4d6e2ef500000a98466a0511382382086ac351052600000a98466a05113823825f273933db5700000a98466a05113822056bc75e2d631aa16a98466a05113823830ca024f987b900000a98466a0511382383635c9adc5dea00000a98466a0511382383ba1910bf341b00000a98466a0033f00428238410d586a20a4c00000a98412a08238056bc75e2d63100000a984018064a98401e1bd04600c55f7bc23038e39f09104601bc16d674ec800015309f0930420773594015104601bc16d674ec8000153090460094079cd1a42aaabf0930420773594015104601bc16d674ec800015308b141040186b0438001e5e504601bc16d674ec800000353090460094079cd1a42aaabf091420045fc108784fc8c6b8104008646582a803678b28027d010a65b509658f89658fe480fd804001a82300de0b6b3a7640000a984a1",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            s3 POP\n            s2 PUSH\n            SEMPTY\n            IFJMP:<{\n                  3 BLKDROP\n            }>\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  3 BLKDROP\n            }>\n            LDMSGADDR\n            DROP\n            s0 s2 XCHG\n            32 LDU\n            64 LDU\n            29 CALLDICT\n            s2 PUSH\n            2943683892 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  s2 POP\n                  15 GETGLOB\n                  0 EQINT\n                  711 THROWIF\n                  s2 PUSH\n                  50000000 PUSHINT\n                  LESS\n                  709 THROWIF\n                  s0 s2 XCHG\n                  50000000 PUSHINT\n                  SUB\n                  SWAP\n                  LDGRAMS\n                  LDDICT\n                  DUP\n                  SEMPTY\n                  NOT\n                  IF:<{\n                        s5 POP\n                        s0 s4 XCHG\n                        LDMSGADDR\n                        DROP\n                        s0 s4 XCHG\n                  }>ELSE<{\n                        DROP\n                  }>\n                  s2 PUSH\n                  DUP\n                  9 GETGLOB\n                  1 GETGLOB\n                  SUB\n                  13 GETGLOB\n                  14 GETGLOB\n                  s4 PUSH\n                  ROTREV\n                  MULDIV\n                  s3 s3 XCPU\n                  SUB\n                  1 GETGLOB\n                  CALL:<{\n                        SWAP\n                        1000000000 PUSHINT\n                        MUL\n                        SWAP\n                        1000000000 PUSHINT\n                        MUL\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        SWAP\n                        SUB\n                        DUP\n                        54 CALLDICT\n                        333333333333333333 PUSHINT\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        ROT\n                        ADD\n                        s2 s(-1) PUXC\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        333333333333333333 PUSHINT\n                        8 GETGLOB\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        s0 s3 XCHG2\n                        ADD\n                        SWAP\n                        ADD\n                        50008 PUSHINT\n                        OVER\n                        0 EQINT\n                        THROWANYIF\n                        1000000000000000000 PUSHINT\n                        SWAP\n                        MULDIV\n                        1000000000 PUSHINT\n                        DIV\n                  }>\n                  s0 s1 PUSH2\n                  GREATER\n                  IF:<{\n                        s1 s3 XCHG\n                        3 BLKDROP\n                        1 GETGLOB\n                        OVER\n                        ADD\n                        s1 s(-1) PUXC\n                        CALL:<{\n                              1000000000 PUSHINT\n                              MUL\n                              SWAP\n                              1000000000 PUSHINT\n                              MUL\n                              9 GETGLOB\n                              1000000000 PUSHINT\n                              MUL\n                              ROT\n                              SUB\n                              DUP\n                              54 CALLDICT\n                              333333333333333333 PUSHINT\n                              8 GETGLOB\n                              1000000000000000000 PUSHINT\n                              MULDIV\n                              SWAP\n                              ADD\n                              s2 s(-1) PUXC\n                              1000000000000000000 PUSHINT\n                              MULDIV\n                              333333333333333333 PUSHINT\n                              9 GETGLOB\n                              1000000000 PUSHINT\n                              MUL\n                              1000000000000000000 PUSHINT\n                              MULDIV\n                              s0 s3 XCHG2\n                              ADD\n                              SWAP\n                              ADD\n                              50008 PUSHINT\n                              OVER\n                              0 EQINT\n                              THROWANYIF\n                              1000000000000000000 PUSHINT\n                              SWAP\n                              MULDIV\n                              1000000000 PUSHINT\n                              DIV\n                        }>\n                        14 GETGLOB\n                        14 GETGLOB\n                        13 GETGLOB\n                        SUB\n                        MULDIVC\n                        13 GETGLOB\n                        14 GETGLOB\n                        s2 PUSH\n                        ROTREV\n                        MULDIV\n                        ROTREV\n                  }>ELSE<{\n                        NIP\n                        SWAP\n                  }>\n                  s1 s4 PUXC\n                  LESS\n                  OVER\n                  OR\n                  1 LESSINT\n                  707 THROWIF\n                  s4 s3 XCPU\n                  SUB\n                  1 GETGLOB\n                  s5 PUSH\n                  ADD\n                  1 SETGLOB\n                  7 GETGLOB\n                  s4 s2 PUSH2\n                  SUB\n                  ADD\n                  7 SETGLOB\n                  NOW\n                  6 SETGLOB\n                  s1 s2 PUSH2\n                  4255808669 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  12 GETGLOB\n                  STSLICER\n                  s0 s4 XCHG2\n                  STGRAMS\n                  s1 s3 XCHG\n                  107 STU\n                  s1 s2 XCHG\n                  32 STU\n                  STDICT\n                  ENDC\n                  17 PUSHINT\n                  SENDRAWMSG\n                  3447206493 PUSHINT\n                  NEWC\n                  32 STU\n                  s7 PUSH\n                  STSLICER\n                  s4 PUSH\n                  STGRAMS\n                  s5 PUSH\n                  STGRAMS\n                  1 GETGLOB\n                  STGRAMS\n                  7 GETGLOB\n                  STGRAMS\n                  s1 s3 XCHG\n                  STDICT\n                  0 PUSHINT\n                  12 PUSHINT\n                  NEWC\n                  4 STU\n                  100 STU\n                  SWAP\n                  STBR\n                  ENDC\n                  0 PUSHINT\n                  SENDRAWMSG\n                  1 GETGLOB\n                  9 GETGLOB\n                  GEQ\n                  DUP\n                  IF:<{\n                        NIP\n                        s2 POP\n                        50000000 PUSHINT\n                        ADD\n                  }>ELSE<{\n                        s3 s3 XCHG2\n                        SUB\n                        12 GETPARAM\n                        ADD\n                        20 PUSHINT\n                        RAWRESERVE\n                  }>\n                  OVER\n                  IF:<{\n                        16 PUSHINT\n                  }>ELSE<{\n                        144 PUSHINT\n                  }>\n                  s5 PUSH\n                  s0 s5 XCHG\n                  s3 s6 XCHG\n                  ROTREV\n                  0 PUSHINT\n                  DUP\n                  395134233 PUSHINT\n                  NEWC\n                  32 STU\n                  s1 s5 XCHG\n                  64 STU\n                  s0 s6 XCHG2\n                  STGRAMS\n                  s1 s3 XCHG\n                  2 STU\n                  s0 s3 XCHG2\n                  STSLICER\n                  s3 PUSH\n                  STGRAMS\n                  s1 s3 XCHG\n                  1 STU\n                  ENDC\n                  MYADDR\n                  4 GETGLOB\n                  s2 s5 XCHG\n                  0 PUSHINT\n                  s0 s(-1) s2 PU2XC\n                  s1 s3 XCHG\n                  s1 s5 XCHG\n                  s0 s3 XCHG\n                  NEWC\n                  4 STU\n                  ROT\n                  STGRAMS\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  ENDC\n                  OVER\n                  NEWC\n                  2 STU\n                  s1 s3 XCHG\n                  STDICT\n                  s1 s2 XCHG\n                  STDICT\n                  1 STU\n                  ENDC\n                  DUP\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  7 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  ROT\n                  STSLICER\n                  s0 s3 XCHG2\n                  STGRAMS\n                  s1 s2 XCHG\n                  108 STU\n                  STREF\n                  s1 s2 XCHG\n                  STREF\n                  ENDC\n                  SWAP\n                  SENDRAWMSG\n                  IF:<{\n                        0 PUSHINT\n                        15 SETGLOB\n                        7 GETGLOB\n                        560000000 PUSHINT\n                        SUB\n                        100000000 PUSHINT\n                        SUB\n                        50000000 PUSHINT\n                        SUB\n                        18 GETGLOB\n                        SUB\n                        10 GETGLOB\n                        CALL:<{\n                              19 GETGLOB\n                              MYADDR\n                              4 GETGLOB\n                              0 PUSHINT\n                              s0 s(-1) s2 PU2XC\n                              s1 s3 XCHG\n                              s1 s5 XCHG\n                              s0 s3 XCHG\n                              NEWC\n                              4 STU\n                              ROT\n                              STGRAMS\n                              SWAP\n                              STSLICER\n                              SWAP\n                              STSLICER\n                              ENDC\n                              OVER\n                              NEWC\n                              2 STU\n                              s1 s3 XCHG\n                              STDICT\n                              s1 s2 XCHG\n                              STDICT\n                              1 STU\n                              ENDC\n                              DUP\n                              HASHCU\n                              0 PUSHINT\n                              4 PUSHINT\n                              NEWC\n                              3 STU\n                              8 STI\n                              256 STU\n                              ENDC\n                              CTOS\n                              PUSHNULL\n                              1 PUSHINT\n                              NEWC\n                              OVER\n                              STGRAMS\n                              MYADDR\n                              STSLICER\n                              1 STU\n                              0 PUSHINT\n                              STGRAMS\n                              STDICT\n                              ENDC\n                              64 PUSHPOW2DEC\n                              935368415 PUSHINT\n                              NEWC\n                              32 STU\n                              20 GETGLOB\n                              STSLICER\n                              MYADDR\n                              STSLICER\n                              MYADDR\n                              STSLICER\n                              64 STU\n                              STREF\n                              ENDC\n                              0 PUSHINT\n                              395134233 PUSHINT\n                              NEWC\n                              32 STU\n                              64 STU\n                              s0 s4 XCHG2\n                              STGRAMS\n                              MYADDR\n                              STSLICER\n                              MYADDR\n                              STSLICER\n                              240000000 PUSHINT\n                              STGRAMS\n                              s1 s3 XCHG\n                              STDICT\n                              ENDC\n                              7 PUSHINT\n                              24 PUSHINT\n                              NEWC\n                              6 STU\n                              s0 s4 XCHG2\n                              STSLICER\n                              300000000 PUSHINT\n                              STGRAMS\n                              s1 s3 XCHG\n                              108 STU\n                              STREF\n                              STREF\n                              ENDC\n                              1 PUSHINT\n                              SENDRAWMSG\n                        }>\n                        1 GETGLOB\n                        10 GETGLOB\n                        ADD\n                        1 SETGLOB\n                        18 GETGLOB\n                        0 GTINT\n                        IF:<{\n                              18 GETGLOB\n                              16 GETGLOB\n                              4255808669 PUSHINT\n                              0 PUSHINT\n                              16 PUSHINT\n                              NEWC\n                              6 STU\n                              12 GETGLOB\n                              STSLICER\n                              s0 s4 XCHG2\n                              STGRAMS\n                              s1 s3 XCHG\n                              107 STU\n                              s1 s2 XCHG\n                              32 STU\n                              STDICT\n                              ENDC\n                              17 PUSHINT\n                              SENDRAWMSG\n                        }>\n                        DUP\n                        CALL:<{\n                              19 GETGLOB\n                              MYADDR\n                              4 GETGLOB\n                              0 PUSHINT\n                              s0 s(-1) s2 PU2XC\n                              s1 s3 XCHG\n                              s1 s5 XCHG\n                              s0 s3 XCHG\n                              NEWC\n                              4 STU\n                              ROT\n                              STGRAMS\n                              SWAP\n                              STSLICER\n                              SWAP\n                              STSLICER\n                              ENDC\n                              OVER\n                              NEWC\n                              2 STU\n                              s1 s3 XCHG\n                              STDICT\n                              s1 s2 XCHG\n                              STDICT\n                              1 STU\n                              ENDC\n                              HASHCU\n                              0 PUSHINT\n                              4 PUSHINT\n                              NEWC\n                              3 STU\n                              8 STI\n                              256 STU\n                              ENDC\n                              CTOS\n                              PUSHNULL\n                              1 PUSHINT\n                              NEWC\n                              OVER\n                              STGRAMS\n                              MYADDR\n                              STSLICER\n                              1 STU\n                              0 PUSHINT\n                              STGRAMS\n                              STDICT\n                              ENDC\n                              64 PUSHPOW2DEC\n                              935368415 PUSHINT\n                              NEWC\n                              32 STU\n                              s0 s3 XCHG2\n                              STSLICER\n                              MYADDR\n                              STSLICER\n                              MYADDR\n                              STSLICER\n                              s1 s2 XCHG\n                              64 STU\n                              STREF\n                              ENDC\n                              0 PUSHINT\n                              32736093 PUSHINT\n                              OVER\n                              24 PUSHINT\n                              NEWC\n                              6 STU\n                              20 GETGLOB\n                              STSLICER\n                              s5 PUSH\n                              260000000 PUSHINT\n                              ADD\n                              STGRAMS\n                              107 STU\n                              32 STU\n                              64 STU\n                              ROT\n                              STGRAMS\n                              MYADDR\n                              STSLICER\n                              STDICT\n                              ENDC\n                              1 PUSHINT\n                              SENDRAWMSG\n                        }>\n                        258651471 PUSHINT\n                        NEWC\n                        32 STU\n                        SWAP\n                        STGRAMS\n                        10 GETGLOB\n                        STGRAMS\n                        0 PUSHINT\n                        12 PUSHINT\n                        NEWC\n                        4 STU\n                        100 STU\n                        SWAP\n                        STBR\n                        ENDC\n                        0 PUSHINT\n                        SENDRAWMSG\n                  }>\n                  30 CALLDICT\n            }>\n            s2 PUSH\n            1760063742 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  2 1 BLKDROP2\n                  15 GETGLOB\n                  0 EQINT\n                  711 THROWIF\n                  LDGRAMS\n                  LDGRAMS\n                  LDMSGADDR\n                  LDDICT\n                  DROP\n                  MYADDR\n                  4 GETGLOB\n                  s3 PUSH\n                  ROTREV\n                  0 PUSHINT\n                  s0 s(-1) s2 PU2XC\n                  s1 s3 XCHG\n                  s1 s5 XCHG\n                  s0 s3 XCHG\n                  NEWC\n                  4 STU\n                  ROT\n                  STGRAMS\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  ENDC\n                  OVER\n                  NEWC\n                  2 STU\n                  s1 s3 XCHG\n                  STDICT\n                  s1 s2 XCHG\n                  STDICT\n                  1 STU\n                  ENDC\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  s0 s6 XCHG2\n                  SDEQ\n                  713 THROWIFNOT\n                  s0 s3 XCHG\n                  50000000 PUSHINT\n                  LESS\n                  709 THROWIF\n                  9 GETGLOB\n                  s2 s(-1) PUXC\n                  GREATER\n                  714 THROWIF\n                  OVER\n                  1 GETGLOB\n                  CALL:<{\n                        1000000000 PUSHINT\n                        MUL\n                        SWAP\n                        1000000000 PUSHINT\n                        MUL\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        ROT\n                        SUB\n                        DUP\n                        54 CALLDICT\n                        333333333333333333 PUSHINT\n                        8 GETGLOB\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        SWAP\n                        ADD\n                        s2 s(-1) PUXC\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        333333333333333333 PUSHINT\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        s0 s3 XCHG2\n                        ADD\n                        SWAP\n                        ADD\n                        50008 PUSHINT\n                        OVER\n                        0 EQINT\n                        THROWANYIF\n                        1000000000000000000 PUSHINT\n                        SWAP\n                        MULDIV\n                        1000000000 PUSHINT\n                        DIV\n                  }>\n                  13 GETGLOB\n                  14 GETGLOB\n                  s2 PUSH\n                  ROTREV\n                  MULDIV\n                  TUCK\n                  SUB\n                  s0 s2 PUXC\n                  LESS\n                  707 THROWIF\n                  1 GETGLOB\n                  s3 PUSH\n                  SUB\n                  1 SETGLOB\n                  7 GETGLOB\n                  s2 s1 PUSH2\n                  ADD\n                  SUB\n                  7 SETGLOB\n                  NOW\n                  6 SETGLOB\n                  2DUP\n                  ADD\n                  12 GETPARAM\n                  SUB\n                  28 PUSHINT\n                  RAWRESERVE\n                  s4 PUSH\n                  4255808669 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  12 GETGLOB\n                  STSLICER\n                  s0 s4 XCHG2\n                  STGRAMS\n                  s1 s3 XCHG\n                  107 STU\n                  s1 s2 XCHG\n                  32 STU\n                  STDICT\n                  ENDC\n                  17 PUSHINT\n                  SENDRAWMSG\n                  1587007766 PUSHINT\n                  NEWC\n                  32 STU\n                  s3 PUSH\n                  STSLICER\n                  SWAP\n                  STGRAMS\n                  SWAP\n                  STGRAMS\n                  1 GETGLOB\n                  STGRAMS\n                  7 GETGLOB\n                  STGRAMS\n                  s1 s2 XCHG\n                  STDICT\n                  0 PUSHINT\n                  12 PUSHINT\n                  NEWC\n                  4 STU\n                  100 STU\n                  SWAP\n                  STBR\n                  ENDC\n                  0 PUSHINT\n                  SENDRAWMSG\n                  0 PUSHINT\n                  144 PUSHINT\n                  63 CALLDICT\n                  30 CALLDICT\n            }>\n            s3 POP\n            OVER\n            1297626441 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  NIP\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  MYADDR\n                  4 GETGLOB\n                  0 PUSHINT\n                  s0 s(-1) s2 PU2XC\n                  s1 s3 XCHG\n                  s1 s5 XCHG\n                  s0 s3 XCHG\n                  NEWC\n                  4 STU\n                  ROT\n                  STGRAMS\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  ENDC\n                  OVER\n                  NEWC\n                  2 STU\n                  s1 s3 XCHG\n                  STDICT\n                  s1 s2 XCHG\n                  STDICT\n                  1 STU\n                  ENDC\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  s2 PUSH\n                  SDEQ\n                  713 THROWIFNOT\n                  15 GETGLOB\n                  1 EQINT\n                  712 THROWIF\n                  2832089063 PUSHINT\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s4 XCHG2\n                  STSLICER\n                  s3 PUSH\n                  STGRAMS\n                  s1 s3 XCHG\n                  107 STU\n                  s1 s2 XCHG\n                  32 STU\n                  64 STU\n                  ENDC\n                  64 PUSHINT\n                  SENDRAWMSG\n            }>\n            OVER\n            21 EQINT\n            IFJMP:<{\n                  2DROP\n                  2 GETGLOB\n                  s1 s2 XCHG\n                  SDEQ\n                  73 THROWIFNOT\n                  LDMSGADDR\n                  LDGRAMS\n                  LDREF\n                  DROP\n                  DUP\n                  CTOS\n                  96 PUSHINT\n                  SDSKIPFIRST\n                  LDGRAMS\n                  DROP\n                  4 GETGLOB\n                  s3 s4 XCHG\n                  s4 s2 XCHG2\n                  69 CALLDICT\n                  1 GETGLOB\n                  SWAP\n                  ADD\n                  1 SETGLOB\n                  30 CALLDICT\n            }>\n            OVER\n            2078119902 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  NIP\n                  SWAP\n                  LDGRAMS\n                  LDMSGADDR\n                  MYADDR\n                  4 GETGLOB\n                  s2 s3 XCHG\n                  0 PUSHINT\n                  s0 s(-1) s2 PU2XC\n                  s1 s3 XCHG\n                  s1 s5 XCHG\n                  s0 s3 XCHG\n                  NEWC\n                  4 STU\n                  ROT\n                  STGRAMS\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  ENDC\n                  OVER\n                  NEWC\n                  2 STU\n                  s1 s3 XCHG\n                  STDICT\n                  s1 s2 XCHG\n                  STDICT\n                  1 STU\n                  ENDC\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  s0 s4 XCHG2\n                  SDEQ\n                  74 THROWIFNOT\n                  1 GETGLOB\n                  SWAP\n                  SUB\n                  1 SETGLOB\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  DUP\n                  2 PLDU\n                  0 NEQINT\n                  IF:<{\n                        3576854235 PUSHINT\n                        0 PUSHINT\n                        16 PUSHINT\n                        NEWC\n                        6 STU\n                        s0 s3 XCHG2\n                        STSLICER\n                        s2 PUSH\n                        STGRAMS\n                        s1 s2 XCHG\n                        107 STU\n                        32 STU\n                        64 STU\n                        ENDC\n                        66 PUSHINT\n                        SENDRAWMSG\n                  }>ELSE<{\n                        2DROP\n                  }>\n                  30 CALLDICT\n            }>\n            OVER\n            745978227 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  NIP\n                  SWAP\n                  LDMSGADDR\n                  1 LDI\n                  SWAP\n                  SWAP\n                  ENDS\n                  IF:<{\n                        NEWC\n                        OVER\n                        STSLICER\n                        ENDC\n                  }>ELSE<{\n                        PUSHNULL\n                  }>\n                  NEWC\n                  16 PUSHINT\n                  SWAP\n                  6 STU\n                  s0 s4 XCHG2\n                  STSLICER\n                  0 PUSHINT\n                  STGRAMS\n                  0 PUSHINT\n                  SWAP\n                  107 STU\n                  3513996288 PUSHINT\n                  SWAP\n                  32 STU\n                  ROT\n                  SWAP\n                  64 STU\n                  OVER\n                  REWRITESTDADDR\n                  DROP\n                  0 EQINT\n                  IF:<{\n                        MYADDR\n                        4 GETGLOB\n                        s2 s3 XCHG\n                        0 PUSHINT\n                        s0 s(-1) s2 PU2XC\n                        s1 s3 XCHG\n                        s1 s5 XCHG\n                        s0 s3 XCHG\n                        NEWC\n                        4 STU\n                        ROT\n                        STGRAMS\n                        SWAP\n                        STSLICER\n                        SWAP\n                        STSLICER\n                        ENDC\n                        OVER\n                        NEWC\n                        2 STU\n                        s1 s3 XCHG\n                        STDICT\n                        s1 s2 XCHG\n                        STDICT\n                        1 STU\n                        ENDC\n                        HASHCU\n                        0 PUSHINT\n                        4 PUSHINT\n                        NEWC\n                        3 STU\n                        8 STI\n                        256 STU\n                        ENDC\n                        CTOS\n                        STSLICER\n                  }>ELSE<{\n                        NIP\n                        0 PUSHINT\n                        SWAP\n                        2 STU\n                  }>\n                  STDICT\n                  ENDC\n                  80 PUSHINT\n                  SENDRAWMSG\n            }>\n            DROP\n            DUP\n            1298083018 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  715 THROWIFNOT\n                  LDMSGADDR\n                  DROP\n                  2 SETGLOB\n                  30 CALLDICT\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n            }>\n            DUP\n            2143123022 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  11 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  716 THROWIFNOT\n                  LDMSGADDR\n                  DROP\n                  11 SETGLOB\n                  30 CALLDICT\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n            }>\n            DUP\n            4208722962 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  11 GETGLOB\n                  s1 s3 XCHG\n                  SDEQ\n                  s1 s2 XCHG\n                  OR\n                  715 THROWIFNOT\n                  LDREF\n                  DROP\n                  3 SETGLOB\n                  30 CALLDICT\n            }>\n            DUP\n            1267319764 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  715 THROWIFNOT\n                  LDMSGADDR\n                  SWAP\n                  12 SETGLOB\n                  16 LDU\n                  SWAP\n                  13 SETGLOB\n                  16 LDU\n                  SWAP\n                  14 SETGLOB\n                  ENDS\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n                  30 CALLDICT\n            }>\n            DUP\n            2618241568 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  715 THROWIFNOT\n                  LDREF\n                  ENDS\n                  SETCODE\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n            }>\n            DUP\n            1189736923 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  715 THROWIFNOT\n                  LDREF\n                  ENDS\n                  c4 POP\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n            }>\n            DUP\n            3181190781 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n                  2 GETGLOB\n                  s2 s(-1) PUXC\n                  SDEQ\n                  715 THROWIFNOT\n                  LDREF\n                  LDREF\n                  ENDS\n                  SWAP\n                  SETCODE\n                  c4 POP\n                  0 PUSHINT\n                  64 PUSHINT\n                  63 CALLDICT\n            }>\n            2 1 BLKDROP2\n            DUP\n            3547469196 PUSHINT\n            EQUAL\n            IFJMP:<{\n                  DROP\n            }>\n            3576854235 PUSHINT\n            EQUAL\n            IFRET\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      29 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            SWAP\n            1 SETGLOB\n            LDMSGADDR\n            SWAP\n            2 SETGLOB\n            LDREF\n            SWAP\n            3 SETGLOB\n            LDREF\n            SWAP\n            4 SETGLOB\n            32 LDU\n            SWAP\n            5 SETGLOB\n            32 LDU\n            SWAP\n            6 SETGLOB\n            LDGRAMS\n            SWAP\n            7 SETGLOB\n            LDGRAMS\n            SWAP\n            8 SETGLOB\n            LDREF\n            SWAP\n            CTOS\n            LDGRAMS\n            SWAP\n            9 SETGLOB\n            LDGRAMS\n            SWAP\n            10 SETGLOB\n            LDMSGADDR\n            SWAP\n            11 SETGLOB\n            LDMSGADDR\n            SWAP\n            12 SETGLOB\n            16 LDU\n            SWAP\n            13 SETGLOB\n            16 LDU\n            SWAP\n            14 SETGLOB\n            1 LDU\n            SWAP\n            15 SETGLOB\n            LDREF\n            SWAP\n            16 SETGLOB\n            64 LDU\n            SWAP\n            17 SETGLOB\n            LDGRAMS\n            SWAP\n            18 SETGLOB\n            LDREF\n            SWAP\n            CTOS\n            LDMSGADDR\n            SWAP\n            19 SETGLOB\n            LDMSGADDR\n            SWAP\n            20 SETGLOB\n            ENDS\n            ENDS\n            ENDS\n      }>\n      30 => <{\n            NEWC\n            19 GETGLOB\n            STSLICER\n            20 GETGLOB\n            STSLICER\n            ENDC\n            17 GETGLOB\n            16 GETGLOB\n            15 GETGLOB\n            14 GETGLOB\n            13 GETGLOB\n            NEWC\n            9 GETGLOB\n            STGRAMS\n            10 GETGLOB\n            STGRAMS\n            11 GETGLOB\n            STSLICER\n            12 GETGLOB\n            STSLICER\n            16 STU\n            16 STU\n            1 STU\n            STREF\n            64 STU\n            18 GETGLOB\n            STGRAMS\n            STREF\n            ENDC\n            6 GETGLOB\n            5 GETGLOB\n            4 GETGLOB\n            3 GETGLOB\n            NEWC\n            1 GETGLOB\n            STGRAMS\n            2 GETGLOB\n            STSLICER\n            STREF\n            STREF\n            32 STU\n            32 STU\n            7 GETGLOB\n            STGRAMS\n            8 GETGLOB\n            STGRAMS\n            STREF\n            ENDC\n            c4 POP\n      }>\n      34 => <{\n            DUP\n            1000000000000000000 PUSHINT\n            LESS\n            IF:<{\n                  1000000000000000000 PUSHINT\n                  s0 s1 PUXC\n                  MULDIV\n                  34 CALLDICT\n                  NEGATE\n            }>ELSE<{\n                  0 PUSHINT\n                  OVER\n                  2158111692681982714103749998457715264521539211273193359375 PUSHINT\n                  54 LSHIFT#\n                  GEQ\n                  IF:<{\n                        DROP\n                        565736031566425676606013439595699310302734375 PUSHINT\n                        36 LSHIFT#\n                        DIV\n                        3814697265625 PUSHINT\n                        25 LSHIFT#\n                  }>\n                  OVER\n                  185821923041689899054467678070068359375 PUSHINT\n                  25 LSHIFT#\n                  GEQ\n                  IF:<{\n                        SWAP\n                        6235149080811616882910000000 PUSHINT\n                        DIV\n                        SWAP\n                        3814697265625 PUSHINT\n                        24 LSHIFT#\n                        ADD\n                  }>\n                  100 MULINT\n                  SWAP\n                  100 MULINT\n                  DUP\n                  7896296018268069516100000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        7896296018268069516100000000000000 PUSHINT\n                        MULDIV\n                        SWAP\n                        95367431640625 PUSHINT\n                        25 LSHIFT#\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  888611052050787263676000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        888611052050787263676000000 PUSHINT\n                        MULDIV\n                        SWAP\n                        95367431640625 PUSHINT\n                        24 LSHIFT#\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  298095798704172827474000 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        298095798704172827474000 PUSHINT\n                        MULDIV\n                        SWAP\n                        95367431640625 PUSHINT\n                        23 LSHIFT#\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  5459815003314423907810 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        5459815003314423907810 PUSHINT\n                        MULDIV\n                        SWAP\n                        400000000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  738905609893065022723 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        738905609893065022723 PUSHINT\n                        MULDIV\n                        SWAP\n                        200000000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  271828182845904523536 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        271828182845904523536 PUSHINT\n                        MULDIV\n                        SWAP\n                        100000000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  164872127070012814685 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        164872127070012814685 PUSHINT\n                        MULDIV\n                        SWAP\n                        50000000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  128402541668774148407 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        128402541668774148407 PUSHINT\n                        MULDIV\n                        SWAP\n                        25000000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  113314845306682631683 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        113314845306682631683 PUSHINT\n                        MULDIV\n                        SWAP\n                        12500000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  106449445891785942956 PUSHINT\n                  GEQ\n                  IF:<{\n                        100000000000000000000 PUSHINT\n                        106449445891785942956 PUSHINT\n                        MULDIV\n                        SWAP\n                        6250000000000000000 PUSHINT\n                        ADD\n                        SWAP\n                  }>\n                  DUP\n                  100000000000000000000 PUSHINT\n                  SUB\n                  100000000000000000000 PUSHINT\n                  s2 s2 XCPU\n                  ADD\n                  s1 s2 XCHG\n                  MULDIV\n                  s0 s0 PUSH2\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  2DUP\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  DUP\n                  3 PUSHINT\n                  DIV\n                  s1 s3 XCHG\n                  ADD\n                  s2 s1 XCPU\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  DUP\n                  5 PUSHINT\n                  DIV\n                  s1 s3 XCHG\n                  ADD\n                  s2 s1 XCPU\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  DUP\n                  7 PUSHINT\n                  DIV\n                  s1 s3 XCHG\n                  ADD\n                  s2 s1 XCPU\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  DUP\n                  9 PUSHINT\n                  DIV\n                  s1 s3 XCHG\n                  ADD\n                  ROTREV\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  11 PUSHINT\n                  DIV\n                  ADD\n                  1 LSHIFT#\n                  ADD\n                  100 PUSHINT\n                  DIV\n            }>\n      }>\n      46 => <{\n            DUP\n            1000000000000000000 PUSHINT\n            EQUAL\n            IF:<{\n                  DROP\n                  2718281828459045235 PUSHINT\n            }>ELSE<{\n                  50004 PUSHINT\n                  OVER\n                  -41000000000000000000 PUSHINT\n                  GEQ\n                  s2 PUSH\n                  130000000000000000000 PUSHINT\n                  LEQ\n                  AND\n                  THROWANYIFNOT\n                  DUP\n                  0 LESSINT\n                  IFJMP:<{\n                        1000000000000000000 PUSHINT\n                        s0 s1 PUXC\n                        NEGATE\n                        46 CALLDICT\n                        s1 s2 XCHG\n                        MULDIV\n                  }>\n                  DUP\n                  3814697265625 PUSHINT\n                  25 LSHIFT#\n                  GEQ\n                  IF:<{\n                        3814697265625 PUSHINT\n                        25 LSHIFT#\n                        SUB\n                        565736031566425676606013439595699310302734375 PUSHINT\n                        36 LSHIFT#\n                  }>ELSE<{\n                        DUP\n                        3814697265625 PUSHINT\n                        24 LSHIFT#\n                        GEQ\n                        IF:<{\n                              3814697265625 PUSHINT\n                              24 LSHIFT#\n                              SUB\n                              6235149080811616882910000000 PUSHINT\n                        }>ELSE<{\n                              1 PUSHINT\n                        }>\n                  }>\n                  SWAP\n                  100 MULINT\n                  100000000000000000000 PUSHINT\n                  OVER\n                  95367431640625 PUSHINT\n                  25 LSHIFT#\n                  GEQ\n                  IF:<{\n                        DROP\n                        95367431640625 PUSHINT\n                        25 LSHIFT#\n                        SUB\n                        7896296018268069516100000000000000 PUSHINT\n                  }>\n                  OVER\n                  95367431640625 PUSHINT\n                  24 LSHIFT#\n                  GEQ\n                  IF:<{\n                        SWAP\n                        95367431640625 PUSHINT\n                        24 LSHIFT#\n                        SUB\n                        SWAP\n                        888611052050787263676000000 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  95367431640625 PUSHINT\n                  23 LSHIFT#\n                  GEQ\n                  IF:<{\n                        SWAP\n                        95367431640625 PUSHINT\n                        23 LSHIFT#\n                        SUB\n                        SWAP\n                        298095798704172827474000 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  400000000000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        SWAP\n                        400000000000000000000 PUSHINT\n                        SUB\n                        SWAP\n                        5459815003314423907810 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  200000000000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        SWAP\n                        200000000000000000000 PUSHINT\n                        SUB\n                        SWAP\n                        738905609893065022723 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  100000000000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        SWAP\n                        100000000000000000000 PUSHINT\n                        SUB\n                        SWAP\n                        271828182845904523536 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  50000000000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        SWAP\n                        50000000000000000000 PUSHINT\n                        SUB\n                        SWAP\n                        164872127070012814685 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  25000000000000000000 PUSHINT\n                  GEQ\n                  IF:<{\n                        SWAP\n                        25000000000000000000 PUSHINT\n                        SUB\n                        SWAP\n                        128402541668774148407 PUSHINT\n                        100000000000000000000 PUSHINT\n                        MULDIV\n                  }>\n                  OVER\n                  100000000000000000000 PUSHINT\n                  OVER\n                  ADD\n                  s1 s3 XCPU\n                  200000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  300000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  400000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  500000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  600000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  700000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  95367431640625 PUSHINT\n                  23 LSHIFT#\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  900000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  1000000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s1 s3 XCPU\n                  1100000000000000000000 PUSHINT\n                  MULDIV\n                  TUCK\n                  ADD\n                  s0 s3 XCHG\n                  1200000000000000000000 PUSHINT\n                  MULDIV\n                  s1 s2 XCHG\n                  ADD\n                  100000000000000000000 PUSHINT\n                  MULDIV\n                  SWAP\n                  100 PUSHINT\n                  MULDIV\n            }>\n      }>\n      54 => <{\n            444444444444444444 PUSHINT\n            8 GETGLOB\n            1000000000000000000 PUSHINT\n            MULDIV\n            9 GETGLOB\n            1000000000 PUSHINT\n            MUL\n            1000000000000000000 PUSHINT\n            MULDIV\n            333333333333333333 PUSHINT\n            9 GETGLOB\n            1000000000 PUSHINT\n            MUL\n            1000000000000000000 PUSHINT\n            MULDIV\n            ROT\n            ADD\n            50008 PUSHINT\n            OVER\n            0 EQINT\n            THROWANYIF\n            1000000000000000000 PUSHINT\n            SWAP\n            MULDIV\n            333333333333333333 PUSHINT\n            8 GETGLOB\n            1000000000000000000 PUSHINT\n            MULDIV\n            SUB\n      }>\n      63 => <{\n            4036989325 PUSHINT\n            0 PUSHINT\n            DUP\n            16 PUSHINT\n            NEWC\n            6 STU\n            s0 s6 XCHG2\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s4 XCHG\n            107 STU\n            s1 s2 XCHG\n            32 STU\n            s1 s2 XCHG\n            32 STU\n            ENDC\n            SWAP\n            SENDRAWMSG\n      }>\n      69 => <{\n            MYADDR\n            s4 s0 s3 XCHG3\n            0 PUSHINT\n            s0 s(-1) s2 PU2XC\n            s1 s3 XCHG\n            s1 s5 XCHG\n            s0 s3 XCHG\n            NEWC\n            4 STU\n            ROT\n            STGRAMS\n            SWAP\n            STSLICER\n            SWAP\n            STSLICER\n            ENDC\n            OVER\n            NEWC\n            2 STU\n            s1 s3 XCHG\n            STDICT\n            s1 s2 XCHG\n            STDICT\n            1 STU\n            ENDC\n            DUP\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            ROT\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s3 XCHG\n            108 STU\n            s1 s2 XCHG\n            STREF\n            STREF\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n      }>\n      87344 => <{\n            29 CALLDICT\n            1 GETGLOB\n            CALL:<{\n                  1000000000 PUSHINT\n                  MUL\n                  SWAP\n                  1000000000 PUSHINT\n                  MUL\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  ROT\n                  SUB\n                  DUP\n                  54 CALLDICT\n                  333333333333333333 PUSHINT\n                  8 GETGLOB\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  SWAP\n                  ADD\n                  s2 s(-1) PUXC\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  333333333333333333 PUSHINT\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  s0 s3 XCHG2\n                  ADD\n                  SWAP\n                  ADD\n                  50008 PUSHINT\n                  OVER\n                  0 EQINT\n                  THROWANYIF\n                  1000000000000000000 PUSHINT\n                  SWAP\n                  MULDIV\n                  1000000000 PUSHINT\n                  DIV\n            }>\n            13 GETGLOB\n            14 GETGLOB\n            s2 PUSH\n            ROTREV\n            MULDIV\n            TUCK\n            SUB\n            DUP\n            1 LESSINT\n            IFJMP:<{\n                  2DROP\n                  0 PUSHINT\n                  DUP\n            }>\n      }>\n      103289 => <{\n            29 CALLDICT\n            MYADDR\n            4 GETGLOB\n            0 PUSHINT\n            s0 s(-1) s2 PU2XC\n            s1 s3 XCHG\n            s1 s5 XCHG\n            s0 s3 XCHG\n            NEWC\n            4 STU\n            ROT\n            STGRAMS\n            SWAP\n            STSLICER\n            SWAP\n            STSLICER\n            ENDC\n            OVER\n            NEWC\n            2 STU\n            s1 s3 XCHG\n            STDICT\n            s1 s2 XCHG\n            STDICT\n            1 STU\n            ENDC\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n      }>\n      106029 => <{\n            29 CALLDICT\n            1 GETGLOB\n            -1 PUSHINT\n            2 GETGLOB\n            3 GETGLOB\n            4 GETGLOB\n      }>\n      110342 => <{\n            29 CALLDICT\n            1 GETGLOB\n            0 EQINT\n            IF:<{\n                  0 PUSHINT\n            }>ELSE<{\n                  1 GETGLOB\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  SWAP\n                  1000000000 PUSHINT\n                  MUL\n                  SUB\n                  DUP\n                  54 CALLDICT\n                  333333333333333333 PUSHINT\n                  8 GETGLOB\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  SWAP\n                  ADD\n                  333333333333333333 PUSHINT\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  ROT\n                  ADD\n                  50008 PUSHINT\n                  OVER\n                  0 EQINT\n                  THROWANYIF\n                  1000000000000000000 PUSHINT\n                  SWAP\n                  MULDIV\n                  1000000000 PUSHINT\n                  DIV\n            }>\n      }>\n      111220 => <{\n            29 CALLDICT\n            DUP\n            9 GETGLOB\n            1 GETGLOB\n            SUB\n            13 GETGLOB\n            14 GETGLOB\n            s4 PUSH\n            ROTREV\n            MULDIV\n            s3 s3 XCPU\n            SUB\n            1 GETGLOB\n            CALL:<{\n                  SWAP\n                  1000000000 PUSHINT\n                  MUL\n                  SWAP\n                  1000000000 PUSHINT\n                  MUL\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  SWAP\n                  SUB\n                  DUP\n                  54 CALLDICT\n                  333333333333333333 PUSHINT\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  ROT\n                  ADD\n                  s2 s(-1) PUXC\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  333333333333333333 PUSHINT\n                  8 GETGLOB\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  s0 s3 XCHG2\n                  ADD\n                  SWAP\n                  ADD\n                  50008 PUSHINT\n                  OVER\n                  0 EQINT\n                  THROWANYIF\n                  1000000000000000000 PUSHINT\n                  SWAP\n                  MULDIV\n                  1000000000 PUSHINT\n                  DIV\n            }>\n            s0 s1 PUSH2\n            GREATER\n            IF:<{\n                  s1 s3 XCHG\n                  3 BLKDROP\n                  1 GETGLOB\n                  OVER\n                  ADD\n                  s1 s(-1) PUXC\n                  CALL:<{\n                        1000000000 PUSHINT\n                        MUL\n                        SWAP\n                        1000000000 PUSHINT\n                        MUL\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        ROT\n                        SUB\n                        DUP\n                        54 CALLDICT\n                        333333333333333333 PUSHINT\n                        8 GETGLOB\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        SWAP\n                        ADD\n                        s2 s(-1) PUXC\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        333333333333333333 PUSHINT\n                        9 GETGLOB\n                        1000000000 PUSHINT\n                        MUL\n                        1000000000000000000 PUSHINT\n                        MULDIV\n                        s0 s3 XCHG2\n                        ADD\n                        SWAP\n                        ADD\n                        50008 PUSHINT\n                        OVER\n                        0 EQINT\n                        THROWANYIF\n                        1000000000000000000 PUSHINT\n                        SWAP\n                        MULDIV\n                        1000000000 PUSHINT\n                        DIV\n                  }>\n                  14 GETGLOB\n                  14 GETGLOB\n                  13 GETGLOB\n                  SUB\n                  MULDIVC\n                  13 GETGLOB\n                  14 GETGLOB\n                  s2 PUSH\n                  ROTREV\n                  MULDIV\n                  ROTREV\n            }>ELSE<{\n                  NIP\n                  SWAP\n            }>\n            DROP\n            DUP\n            1 LESSINT\n            IFJMP:<{\n                  2DROP\n                  0 PUSHINT\n                  DUP\n            }>\n      }>\n      127001 => <{\n            29 CALLDICT\n            9 GETGLOB\n            9 GETGLOB\n            CALL:<{\n                  1000000000 PUSHINT\n                  MUL\n                  SWAP\n                  1000000000 PUSHINT\n                  MUL\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  ROT\n                  SUB\n                  DUP\n                  54 CALLDICT\n                  333333333333333333 PUSHINT\n                  8 GETGLOB\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  SWAP\n                  ADD\n                  s2 s(-1) PUXC\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  333333333333333333 PUSHINT\n                  9 GETGLOB\n                  1000000000 PUSHINT\n                  MUL\n                  1000000000000000000 PUSHINT\n                  MULDIV\n                  s0 s3 XCHG2\n                  ADD\n                  SWAP\n                  ADD\n                  50008 PUSHINT\n                  OVER\n                  0 EQINT\n                  THROWANYIF\n                  1000000000000000000 PUSHINT\n                  SWAP\n                  MULDIV\n                  1000000000 PUSHINT\n                  DIV\n            }>\n            14 GETGLOB\n            14 GETGLOB\n            13 GETGLOB\n            SUB\n            MULDIVC\n            INC\n            13 GETGLOB\n            14 GETGLOB\n            s2 PUSH\n            ROTREV\n            MULDIV\n            SWAP\n            1 GETGLOB\n            9 GETGLOB\n            10 GETGLOB\n            2 GETGLOB\n            11 GETGLOB\n            3 GETGLOB\n            12 GETGLOB\n            13 GETGLOB\n            14 GETGLOB\n            5 GETGLOB\n            6 GETGLOB\n            15 GETGLOB\n            7 GETGLOB\n            16 GETGLOB\n            18 GETGLOB\n            19 GETGLOB\n            20 GETGLOB\n            s0 s16 XCHG\n            s0 s18 XCHG\n            s0 s16 XCHG\n            s0 s15 XCHG\n            s0 s17 XCHG\n            s0 s15 XCHG\n            s0 s14 XCHG\n            s0 s16 XCHG\n            s0 s14 XCHG\n            s13 s15 XCHG\n            s12 s14 XCHG\n            s11 s13 XCHG\n            s10 s12 XCHG\n            s9 s11 XCHG\n            s8 s10 XCHG\n            s7 s9 XCHG\n            s6 s8 XCHG\n            s5 s7 XCHG\n            s4 s6 XCHG\n            s3 s5 XCHG\n            s2 s4 XCHG\n      }>\n}\n11 THROWARG",
  "code_hash": "912b0317bfb5c79760eac245efcc709245aa382a1332dadb5a4524e7834e1dcf",
  "methods": [
    {
      "id": 103289,
      "method": "get_wallet_address"
    },
    {
      "id": 106029,
      "method": "get_jetton_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "contracts/imports/stdlib_modern.fc",
        "content": ";; Standard library for funC\n;;\n\n{-\n    This file is part of TON FunC Standard Library.\n\n    FunC Standard Library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    FunC Standard Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n-}\n\n{-\n  # Tuple manipulation primitives\n  The names and the types are mostly self-explaining.\n  See [polymorhism with forall](https://ton.org/docs/#/func/functions?id=polymorphism-with-forall)\n  for more info on the polymorphic functions.\n\n  Note that currently values of atomic type `tuple` can't be cast to composite tuple type (e.g. `[int, cell]`)\n  and vise versa.\n-}\n\n{-\n  # Lisp-style lists\n\n  Lists can be represented as nested 2-elements tuples.\n  Empty list is conventionally represented as TVM `null` value (it can be obtained by calling [null()]).\n  For example, tuple `(1, (2, (3, null)))` represents list `[1, 2, 3]`. Elements of a list can be of different types.\n-}\n\n;;; Adds an element to the beginning of lisp-style list.\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\n\n;;; Extracts the head and the tail of lisp-style list.\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\n\n;;; Extracts the tail and the head of lisp-style list.\nforall X -> (tuple, X) list_next(tuple list) asm(-> 1 0) \"UNCONS\";\n\n;;; Returns the head of lisp-style list.\nforall X -> X car(tuple list) asm \"CAR\";\n\n;;; Returns the tail of lisp-style list.\ntuple cdr(tuple list) asm \"CDR\";\n\n;;; Creates tuple with zero elements.\ntuple empty_tuple() asm \"NIL\";\n\n;;; Appends a value `x` to a `Tuple t = (x1, ..., xn)`, but only if the resulting `Tuple t' = (x1, ..., xn, x)`\n;;; is of length at most 255. Otherwise throws a type check exception.\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\n\n;;; Creates a tuple of length one with given argument as element.\nforall X -> [X] single(X x) asm \"SINGLE\";\n\n;;; Unpacks a tuple of length one\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\n\n;;; Creates a tuple of length two with given arguments as elements.\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\n\n;;; Unpacks a tuple of length two\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\n\n;;; Creates a tuple of length three with given arguments as elements.\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\n\n;;; Unpacks a tuple of length three\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\n\n;;; Creates a tuple of length four with given arguments as elements.\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\n\n;;; Unpacks a tuple of length four\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\n\n;;; Returns the first element of a tuple (with unknown element types).\nforall X -> X first(tuple t) asm \"FIRST\";\n\n;;; Returns the second element of a tuple (with unknown element types).\nforall X -> X second(tuple t) asm \"SECOND\";\n\n;;; Returns the third element of a tuple (with unknown element types).\nforall X -> X third(tuple t) asm \"THIRD\";\n\n;;; Returns the fourth element of a tuple (with unknown element types).\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\n\n;;; Returns the first element of a pair tuple.\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\n\n;;; Returns the second element of a pair tuple.\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\n\n;;; Returns the first element of a triple tuple.\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\n\n;;; Returns the second element of a triple tuple.\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\n\n;;; Returns the third element of a triple tuple.\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\n\n\n;;; Push null element (casted to given type)\n;;; By the TVM type `Null` FunC represents absence of a value of some atomic type.\n;;; So `null` can actually have any atomic type.\nforall X -> X null() asm \"PUSHNULL\";\n\n;;; Moves a variable [x] to the top of the stack\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\n\n\n;;; Returns the current Unix time as an Integer\nint now() asm \"NOW\";\n\n;;; Returns the internal address of the current smart contract as a Slice with a `MsgAddressInt`.\n;;; If necessary, it can be parsed further using primitives such as [parse_std_addr].\nslice my_address() asm \"MYADDR\";\n\n;;; Returns the balance of the smart contract as a tuple consisting of an int\n;;; (balance in nanotoncoins) and a `cell`\n;;; (a dictionary with 32-bit keys representing the balance of \"extra currencies\")\n;;; at the start of Computation Phase.\n;;; Note that RAW primitives such as [send_raw_message] do not update this field.\n[int, cell] get_balance() asm \"BALANCE\";\n\n;;; Returns the logical time of the current transaction.\nint cur_lt() asm \"LTIME\";\n\n;;; Returns the starting logical time of the current block.\nint block_lt() asm \"BLOCKLT\";\n\n;;; Computes the representation hash of a `cell` [c] and returns it as a 256-bit unsigned integer `x`.\n;;; Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.\nint cell_hash(cell c) asm \"HASHCU\";\n\n;;; Computes the hash of a `slice s` and returns it as a 256-bit unsigned integer `x`.\n;;; The result is the same as if an ordinary cell containing only data and references from `s` had been created\n;;; and its hash computed by [cell_hash].\nint slice_hash(slice s) asm \"HASHSU\";\n\n;;; Computes sha256 of the data bits of `slice` [s]. If the bit length of `s` is not divisible by eight,\n;;; throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer `x`.\nint string_hash(slice s) asm \"SHA256U\";\n\n{-\n  # Signature checks\n-}\n\n;;; Checks the Ed25519-`signature` of a `hash` (a 256-bit unsigned integer, usually computed as the hash of some data)\n;;; using [public_key] (also represented by a 256-bit unsigned integer).\n;;; The signature must contain at least 512 data bits; only the first 512 bits are used.\n;;; The result is `−1` if the signature is valid, `0` otherwise.\n;;; Note that `CHKSIGNU` creates a 256-bit slice with the hash and calls `CHKSIGNS`.\n;;; That is, if [hash] is computed as the hash of some data, these data are hashed twice,\n;;; the second hashing occurring inside `CHKSIGNS`.\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\n\n;;; Checks whether [signature] is a valid Ed25519-signature of the data portion of `slice data` using `public_key`,\n;;; similarly to [check_signature].\n;;; If the bit length of [data] is not divisible by eight, throws a cell underflow exception.\n;;; The verification of Ed25519 signatures is the standard one,\n;;; with sha256 used to reduce [data] to the 256-bit number that is actually signed.\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n{---\n  # Computation of boc size\n  The primitives below may be useful for computing storage fees of user-provided data.\n-}\n\n;;; Returns `(x, y, z, -1)` or `(null, null, null, 0)`.\n;;; Recursively computes the count of distinct cells `x`, data bits `y`, and cell references `z`\n;;; in the DAG rooted at `cell` [c], effectively returning the total storage used by this DAG taking into account\n;;; the identification of equal cells.\n;;; The values of `x`, `y`, and `z` are computed by a depth-first traversal of this DAG,\n;;; with a hash table of visited cell hashes used to prevent visits of already-visited cells.\n;;; The total count of visited cells `x` cannot exceed non-negative [max_cells];\n;;; otherwise the computation is aborted before visiting the `(max_cells + 1)`-st cell and\n;;; a zero flag is returned to indicate failure. If [c] is `null`, returns `x = y = z = 0`.\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n\n;;; Similar to [compute_data_size?], but accepting a `slice` [s] instead of a `cell`.\n;;; The returned value of `x` does not take into account the cell that contains the `slice` [s] itself;\n;;; however, the data bits and the cell references of [s] are accounted for in `y` and `z`.\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n\n;;; A non-quiet version of [compute_data_size?] that throws a cell overflow exception (`8`) on failure.\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; A non-quiet version of [slice_compute_data_size?] that throws a cell overflow exception (8) on failure.\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; Throws an exception with exit_code excno if cond is not 0 (commented since implemented in compilator)\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n{--\n  # Debug primitives\n  Only works for local TVM execution with debug level verbosity\n-}\n;;; Dumps the stack (at most the top 255 values) and shows the total stack depth.\n() dump_stack() impure asm \"DUMPSTK\";\n\n{-\n  # Persistent storage save and load\n-}\n\n;;; Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.\ncell get_data() asm \"c4 PUSH\";\n\n;;; Sets `cell` [c] as persistent contract data. You can update persistent contract storage with this primitive.\n() set_data(cell c) impure asm \"c4 POP\";\n\n{-\n  # Continuation primitives\n-}\n;;; Usually `c3` has a continuation initialized by the whole code of the contract. It is used for function calls.\n;;; The primitive returns the current value of `c3`.\ncont get_c3() impure asm \"c3 PUSH\";\n\n;;; Updates the current value of `c3`. Usually, it is used for updating smart contract code in run-time.\n;;; Note that after execution of this primitive the current code\n;;; (and the stack of recursive function calls) won't change,\n;;; but any other function call will use a function from the new code.\n() set_c3(cont c) impure asm \"c3 POP\";\n\n;;; Transforms a `slice` [s] into a simple ordinary continuation `c`, with `c.code = s` and an empty stack and savelist.\ncont bless(slice s) impure asm \"BLESS\";\n\n{---\n  # Gas related primitives\n-}\n\n;;; Sets current gas limit `gl` to its maximal allowed value `gm`, and resets the gas credit `gc` to zero,\n;;; decreasing the value of `gr` by `gc` in the process.\n;;; In other words, the current smart contract agrees to buy some gas to finish the current transaction.\n;;; This action is required to process external messages, which bring no value (hence no gas) with themselves.\n;;;\n;;; For more details check [accept_message effects](https://ton.org/docs/#/smart-contracts/accept).\n() accept_message() impure asm \"ACCEPT\";\n\n;;; Sets current gas limit `gl` to the minimum of limit and `gm`, and resets the gas credit `gc` to zero.\n;;; If the gas consumed so far (including the present instruction) exceeds the resulting value of `gl`,\n;;; an (unhandled) out of gas exception is thrown before setting new gas limits.\n;;; Notice that [set_gas_limit] with an argument `limit ≥ 2^63 − 1` is equivalent to [accept_message].\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n\n;;; Commits the current state of registers `c4` (“persistent data”) and `c5` (“actions”)\n;;; so that the current execution is considered “successful” with the saved values even if an exception\n;;; in Computation Phase is thrown later.\n() commit() impure asm \"COMMIT\";\n\n;;; Not implemented\n;;; Computes the amount of gas that can be bought for `amount` nanoTONs,\n;;; and sets `gl` accordingly in the same way as [set_gas_limit].\n;;() buy_gas(int amount) impure asm \"BUYGAS\";\n\n;;; Computes the minimum of two integers [x] and [y].\nint min(int x, int y) asm \"MIN\";\n\n;;; Computes the maximum of two integers [x] and [y].\nint max(int x, int y) asm \"MAX\";\n\n;;; Sorts two integers.\n(int, int) minmax(int x, int y) asm \"MINMAX\";\n\n;;; Computes the absolute value of an integer [x].\nint abs(int x) asm \"ABS\";\n\n{-\n  # Slice primitives\n\n  It is said that a primitive _loads_ some data,\n  if it returns the data and the remainder of the slice\n  (so it can also be used as [modifying method](https://ton.org/docs/#/func/statements?id=modifying-methods)).\n\n  It is said that a primitive _preloads_ some data, if it returns only the data\n  (it can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods)).\n\n  Unless otherwise stated, loading and preloading primitives read the data from a prefix of the slice.\n-}\n\n\n;;; Converts a `cell` [c] into a `slice`. Notice that [c] must be either an ordinary cell,\n;;; or an exotic cell (see [TVM.pdf](https://ton-blockchain.github.io/docs/tvm.pdf), 3.1.2)\n;;; which is automatically loaded to yield an ordinary cell `c'`, converted into a `slice` afterwards.\nslice begin_parse(cell c) asm \"CTOS\";\n\n;;; Checks if [s] is empty. If not, throws an exception.\n() end_parse(slice s) impure asm \"ENDS\";\n\n;;; Loads the first reference from the slice.\n(slice, cell) load_ref(slice s) asm(-> 1 0) \"LDREF\";\n\n;;; Preloads the first reference from the slice.\ncell preload_ref(slice s) asm \"PLDREF\";\n\n{- Functions below are commented because are implemented on compilator level for optimisation -}\n\n;;; Loads a signed [len]-bit integer from a slice [s].\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n\n;;; Loads an unsigned [len]-bit integer from a slice [s].\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n\n;;; Preloads a signed [len]-bit integer from a slice [s].\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n\n;;; Preloads an unsigned [len]-bit integer from a slice [s].\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n\n;;; Loads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n\n;;; Preloads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n\n;;; Loads serialized amount of TonCoins (any unsigned integer up to `2^128 - 1`).\n(slice, int) load_grams(slice s) asm(-> 1 0) \"LDGRAMS\";\n(slice, int) load_coins(slice s) asm(-> 1 0) \"LDVARUINT16\";\n\n;;; Returns all but the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n\n;;; Returns the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\n\n;;; Returns all but the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n\n;;; Returns the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n\n;;; Loads a dictionary `D` (HashMapE) from `slice` [s].\n;;; (returns `null` if `nothing` constructor is used).\n(slice, cell) load_dict(slice s) asm(-> 1 0) \"LDDICT\";\n\n;;; Preloads a dictionary `D` from `slice` [s].\ncell preload_dict(slice s) asm \"PLDDICT\";\n\n;;; Loads a dictionary as [load_dict], but returns only the remainder of the slice.\nslice skip_dict(slice s) asm \"SKIPDICT\";\n(slice, ()) ~skip_dict(slice s) asm \"SKIPDICT\";\n\n;;; Loads (Maybe ^Cell) from `slice` [s].\n;;; In other words loads 1 bit and if it is true\n;;; loads first ref and return it with slice remainder\n;;; otherwise returns `null` and slice remainder\n(slice, cell) load_maybe_ref(slice s) asm(-> 1 0) \"LDOPTREF\";\n\n;;; Preloads (Maybe ^Cell) from `slice` [s].\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\n\n\n;;; Returns the depth of `cell` [c].\n;;; If [c] has no references, then return `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [c].\n;;; If [c] is a `null` instead of a cell, returns zero.\nint cell_depth(cell c) asm \"CDEPTH\";\n\n\n{-\n  # Slice size primitives\n-}\n\n;;; Returns the number of references in `slice` [s].\nint slice_refs(slice s) asm \"SREFS\";\n\n;;; Returns the number of data bits in `slice` [s].\nint slice_bits(slice s) asm \"SBITS\";\n\n;;; Returns both the number of data bits and the number of references in `slice` [s].\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\n\n;;; Checks whether a `slice` [s] is empty (i.e., contains no bits of data and no cell references).\nint slice_empty?(slice s) asm \"SEMPTY\";\n\n;;; Checks whether `slice` [s] has no bits of data.\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\n\n;;; Checks whether `slice` [s] has no references.\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\n\n;;; Returns the depth of `slice` [s].\n;;; If [s] has no references, then returns `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [s].\nint slice_depth(slice s) asm \"SDEPTH\";\n\n{-\n  # Builder size primitives\n-}\n\n;;; Returns the number of cell references already stored in `builder` [b]\nint builder_refs(builder b) asm \"BREFS\";\n\n;;; Returns the number of data bits already stored in `builder` [b].\nint builder_bits(builder b) asm \"BBITS\";\n\n;;; Returns the depth of `builder` [b].\n;;; If no cell references are stored in [b], then returns 0;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [b].\nint builder_depth(builder b) asm \"BDEPTH\";\n\n{-\n  # Builder primitives\n  It is said that a primitive _stores_ a value `x` into a builder `b`\n  if it returns a modified version of the builder `b'` with the value `x` stored at the end of it.\n  It can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods).\n\n  All the primitives below first check whether there is enough space in the `builder`,\n  and only then check the range of the value being serialized.\n-}\n\n;;; Creates a new empty `builder`.\nbuilder begin_cell() asm \"NEWC\";\n\n;;; Converts a `builder` into an ordinary `cell`.\ncell end_cell(builder b) asm \"ENDC\";\n\n;;; Stores a reference to `cell` [c] into `builder` [b].\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n\n;;; Stores an unsigned [len]-bit integer `x` into `b` for `0 ≤ len ≤ 256`.\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n\n;;; Stores a signed [len]-bit integer `x` into `b` for` 0 ≤ len ≤ 257`.\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\n\n\n;;; Stores `slice` [s] into `builder` [b]\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\n\n;;; Stores (serializes) an integer [x] in the range `0..2^128 − 1` into `builder` [b].\n;;; The serialization of [x] consists of a 4-bit unsigned big-endian integer `l`,\n;;; which is the smallest integer `l ≥ 0`, such that `x < 2^8l`,\n;;; followed by an `8l`-bit unsigned big-endian representation of [x].\n;;; If [x] does not belong to the supported range, a range check exception is thrown.\n;;;\n;;; Store amounts of TonCoins to the builder as VarUInteger 16\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n\n;;; Stores dictionary `D` represented by `cell` [c] or `null` into `builder` [b].\n;;; In other words, stores a `1`-bit and a reference to [c] if [c] is not `null` and `0`-bit otherwise.\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n;;; Stores (Maybe ^Cell) to builder:\n;;; if cell is null store 1 zero bit\n;;; otherwise store 1 true bit and ref to cell\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\n\n{-\n  # Address manipulation primitives\n  The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme:\n  ```TL-B\n  addr_none$00 = MsgAddressExt;\n  addr_extern$01 len:(## 8) external_address:(bits len)\n               = MsgAddressExt;\n  anycast_info$_ depth:(#<= 30) { depth >= 1 }\n    rewrite_pfx:(bits depth) = Anycast;\n  addr_std$10 anycast:(Maybe Anycast)\n    workchain_id:int8 address:bits256 = MsgAddressInt;\n  addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)\n    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;\n  _ _:MsgAddressInt = MsgAddress;\n  _ _:MsgAddressExt = MsgAddress;\n\n  int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n    src:MsgAddress dest:MsgAddressInt\n    value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ```\n  A deserialized `MsgAddress` is represented by a tuple `t` as follows:\n\n  - `addr_none` is represented by `t = (0)`,\n    i.e., a tuple containing exactly one integer equal to zero.\n  - `addr_extern` is represented by `t = (1, s)`,\n    where slice `s` contains the field `external_address`. In other words, `\n    t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`.\n  - `addr_std` is represented by `t = (2, u, x, s)`,\n    where `u` is either a `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if anycast is present).\n    Next, integer `x` is the `workchain_id`, and slice `s` contains the address.\n  - `addr_var` is represented by `t = (3, u, x, s)`,\n    where `u`, `x`, and `s` have the same meaning as for `addr_std`.\n-}\n\n;;; Loads from slice [s] the only prefix that is a valid `MsgAddress`,\n;;; and returns both this prefix `s'` and the remainder `s''` of [s] as slices.\n(slice, slice) load_msg_addr(slice s) asm(-> 1 0) \"LDMSGADDR\";\n\n;;; Decomposes slice [s] containing a valid `MsgAddress` into a `tuple t` with separate fields of this `MsgAddress`.\n;;; If [s] is not a valid `MsgAddress`, a cell deserialization exception is thrown.\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n\n;;; Parses slice [s] containing a valid `MsgAddressInt` (usually a `msg_addr_std`),\n;;; applies rewriting from the anycast (if present) to the same-length prefix of the address,\n;;; and returns both the workchain and the 256-bit address as integers.\n;;; If the address is not 256-bit, or if [s] is not a valid serialization of `MsgAddressInt`,\n;;; throws a cell deserialization exception.\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n\n;;; A variant of [parse_std_addr] that returns the (rewritten) address as a slice [s],\n;;; even if it is not exactly 256 bit long (represented by a `msg_addr_var`).\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\n{-\n  # Dictionary primitives\n-}\n\n\n;;; Sets the value associated with [key_len]-bit key signed index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n\n;;; Sets the value associated with [key_len]-bit key unsigned index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\n\n;;; Creates an empty dictionary, which is actually a null value. Equivalent to PUSHNULL\ncell new_dict() asm \"NEWDICT\";\n;;; Checks whether a dictionary is empty. Equivalent to cell_null?.\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n\n{- Prefix dictionary primitives -}\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\n;;; Returns the value of the global configuration parameter with integer index `i` as a `cell` or `null` value.\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\n;;; Checks whether c is a null. Note, that FunC also has polymorphic null? built-in.\nint cell_null?(cell c) asm \"ISNULL\";\n\n;;; Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if mode = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b − amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means `amount <- -amount` before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently, amount must be a non-negative integer, and mode must be in the range 0..15.\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n;;; Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n;;; Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smart contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n;;; Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract\n() set_code(cell new_code) impure asm \"SETCODE\";\n\n;;; Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.\nint random() impure asm \"RANDU256\";\n;;; Generates a new pseudo-random integer z in the range 0..range−1 (or range..−1, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.\nint rand(int range) impure asm \"RAND\";\n;;; Returns the current random seed as an unsigned 256-bit Integer.\nint get_seed() impure asm \"RANDSEED\";\n;;; Sets the random seed to unsigned 256-bit seed.\n() set_seed(int x) impure asm \"SETRAND\";\n;;; Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.\n() randomize(int x) impure asm \"ADDRAND\";\n;;; Equivalent to randomize(cur_lt());.\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n;;; Checks whether the data parts of two slices coinside\nint equal_slices_bits(slice a, slice b) asm \"SDEQ\";\n;;; Checks whether b is a null. Note, that FunC also has polymorphic null? built-in.\nint builder_null?(builder b) asm \"ISNULL\";\n;;; Concatenates two builders\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n\n;; CUSTOM:\n\n;; TVM UPGRADE 2023-07 https://docs.ton.org/learn/tvm-instructions/tvm-upgrade-2023-07\n;; In mainnet since 20 Dec 2023 https://t.me/tonblockchain/226\n\n;;; Retrieves code of smart-contract from c7\ncell my_code() asm \"MYCODE\";\n\n;;; Creates an output action and returns a fee for creating a message. Mode has the same effect as in the case of SENDRAWMSG\nint send_message(cell msg, int mode) impure asm \"SENDMSG\";\n\nint gas_consumed() asm \"GASCONSUMED\";\n\n;; TVM V6 https://github.com/ton-blockchain/ton/blob/testnet/doc/GlobalVersions.md#version-6\n\nint get_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEE\";\nint get_storage_fee(int workchain, int seconds, int bits, int cells) asm(cells bits seconds workchain) \"GETSTORAGEFEE\";\nint get_forward_fee(int workchain, int bits, int cells) asm(cells bits workchain) \"GETFORWARDFEE\";\nint get_precompiled_gas_consumption() asm \"GETPRECOMPILEDGAS\";\n\nint get_simple_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEESIMPLE\";\nint get_simple_forward_fee(int workchain, int bits, int cells) asm(cells bits workchain) \"GETFORWARDFEESIMPLE\";\nint get_original_fwd_fee(int workchain, int fwd_fee) asm(fwd_fee workchain) \"GETORIGINALFWDFEE\";\nint my_storage_due() asm \"DUEPAYMENT\";\n\ntuple get_fee_cofigs() asm \"UNPACKEDCONFIGTUPLE\";\n\n;; BASIC\n\nconst int TRUE = -1;\nconst int FALSE = 0;\n\nconst int MASTERCHAIN = -1;\nconst int BASECHAIN = 0;\n\n;;; skip (Maybe ^Cell) from `slice` [s].\n(slice, ()) ~skip_maybe_ref(slice s) asm \"SKIPOPTREF\";\n\n(slice, int) ~load_bool(slice s) inline {\n    return s.load_int(1);\n}\n\nbuilder store_bool(builder b, int value) inline {\n    return b.store_int(value, 1);\n}\n\n;; ADDRESS NONE\n;; addr_none$00 = MsgAddressExt; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L100\n\nbuilder store_address_none(builder b) inline {\n    return b.store_uint(0, 2);\n}\n\nslice address_none() asm \"<b 0 2 u, b> <s PUSHSLICE\";\n\nint is_address_none(slice s) inline {\n    return s.preload_uint(2) == 0;\n}\n\n;; MESSAGE\n\n;; The message header info is organized as follows:\n\n;; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L126\n;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n;; src:MsgAddressInt dest:MsgAddressInt\n;; value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n;; created_lt:uint64 created_at:uint32 = CommonMsgInfo;\n\n;; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L135\n;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n;; src:MsgAddress dest:MsgAddressInt\n;; value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n;; created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n\n\n;; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L123C1-L124C33\n;; currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection;\n\n;; MSG FLAGS\n\nconst int BOUNCEABLE = 0x18; ;; 0b011000 tag - 0, ihr_disabled - 1, bounce - 1, bounced - 0, src = adr_none$00\nconst int NON_BOUNCEABLE = 0x10; ;; 0b010000 tag - 0, ihr_disabled - 1, bounce - 0, bounced - 0, src = adr_none$00\n\n;; store msg_flags and address none\nbuilder store_msg_flags_and_address_none(builder b, int msg_flags) inline {\n    return b.store_uint(msg_flags, 6);\n}\n\n;; load msg_flags only\n(slice, int) ~load_msg_flags(slice s) inline {\n    return s.load_uint(4);\n}\n;;; @param `msg_flags` - 4-bit\nint is_bounced(int msg_flags) inline {\n    return msg_flags & 1 == 1;\n}\n\n(slice, ()) ~skip_bounced_prefix(slice s) inline {\n    return (s.skip_bits(32), ()); ;; skip 0xFFFFFFFF prefix\n}\n\n;; after `grams:Grams` we have (1 + 4 + 4 + 64 + 32) zeroes - zeroed extracurrency, ihr_fee, fwd_fee, created_lt and created_at\nconst int MSG_INFO_REST_BITS = 1 + 4 + 4 + 64 + 32;\n\n;; MSG\n\n;; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L155\n;; message$_ {X:Type} info:CommonMsgInfo\n;;  init:Maybe (Either StateInit ^StateInit)\n;;  body:(Either X ^X) = Message X;\n;;\n;;message$_ {X:Type} info:CommonMsgInfoRelaxed\n;;  init:(Maybe (Either StateInit ^StateInit))\n;;  body:(Either X ^X) = MessageRelaxed X;\n;;\n;;_ (Message Any) = MessageAny;\n\n;; if have StateInit (always place StateInit in ref):\n;; 0b11 for `Maybe (Either StateInit ^StateInit)` and 0b1 or 0b0 for `body:(Either X ^X)`\n\nconst int MSG_WITH_STATE_INIT_AND_BODY_SIZE = MSG_INFO_REST_BITS + 1 + 1 + 1;\nconst int MSG_HAVE_STATE_INIT = 4;\nconst int MSG_STATE_INIT_IN_REF = 2;\nconst int MSG_BODY_IN_REF = 1;\n\n;; if no StateInit:\n;; 0b0 for `Maybe (Either StateInit ^StateInit)` and 0b1 or 0b0 for `body:(Either X ^X)`\n\nconst int MSG_ONLY_BODY_SIZE = MSG_INFO_REST_BITS + 1 + 1;\n\nbuilder store_statinit_ref_and_body_ref(builder b, cell state_init, cell body) inline {\n    return b\n    .store_uint(MSG_HAVE_STATE_INIT + MSG_STATE_INIT_IN_REF + MSG_BODY_IN_REF, MSG_WITH_STATE_INIT_AND_BODY_SIZE)\n    .store_ref(state_init)\n    .store_ref(body);\n}\n\nbuilder store_only_body_ref(builder b, cell body) inline {\n    return b\n    .store_uint(MSG_BODY_IN_REF, MSG_ONLY_BODY_SIZE)\n    .store_ref(body);\n}\n\nbuilder store_prefix_only_body(builder b) inline {\n    return b\n    .store_uint(0, MSG_ONLY_BODY_SIZE);\n}\n\n;; parse after sender_address\n(slice, int) ~retrieve_fwd_fee(slice in_msg_full_slice) inline {\n    in_msg_full_slice~load_msg_addr(); ;; skip dst\n    in_msg_full_slice~load_coins(); ;; skip value\n    in_msg_full_slice~skip_dict(); ;; skip extracurrency collection\n    in_msg_full_slice~load_coins(); ;; skip ihr_fee\n    int fwd_fee = in_msg_full_slice~load_coins();\n    return (in_msg_full_slice, fwd_fee);\n}\n\n;; MSG BODY\n\n;; According to the guideline, it is recommended to start the body of the internal message with uint32 op and uint64 query_id\n\nconst int MSG_OP_SIZE = 32;\nconst int MSG_QUERY_ID_SIZE = 64;\n\n(slice, int) ~load_op(slice s) inline {\n    return s.load_uint(MSG_OP_SIZE);\n}\n(slice, ()) ~skip_op(slice s) inline {\n    return (s.skip_bits(MSG_OP_SIZE), ());\n}\nbuilder store_op(builder b, int op) inline {\n    return b.store_uint(op, MSG_OP_SIZE);\n}\n\n(slice, int) ~load_query_id(slice s) inline {\n    return s.load_uint(MSG_QUERY_ID_SIZE);\n}\n(slice, ()) ~skip_query_id(slice s) inline {\n    return (s.skip_bits(MSG_QUERY_ID_SIZE), ());\n}\nbuilder store_query_id(builder b, int query_id) inline {\n    return b.store_uint(query_id, MSG_QUERY_ID_SIZE);\n}\n\n(slice, (int, int)) ~load_op_and_query_id(slice s) inline {\n    int op = s~load_op();\n    int query_id = s~load_query_id();\n    return (s, (op, query_id));\n}\n\n;; SEND MODES - https://docs.ton.org/tvm.pdf page 137, SENDRAWMSG\n\n;; For `send_raw_message` and `send_message`:\n\n;;; x = 0 is used for ordinary messages; the gas fees are deducted from the senging amount; action phaes should NOT be ignored.\nconst int SEND_MODE_REGULAR = 0;\n;;; +1 means that the sender wants to pay transfer fees separately.\nconst int SEND_MODE_PAY_FEES_SEPARATELY = 1;\n;;; + 2 means that any errors arising while processing this message during the action phase should be ignored.\nconst int SEND_MODE_IGNORE_ERRORS = 2;\n;;; + 32 means that the current account must be destroyed if its resulting balance is zero.\nconst int SEND_MODE_DESTROY = 32;\n;;; x = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.\nconst int SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;\n;;; x = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message).\nconst int SEND_MODE_CARRY_ALL_BALANCE = 128;\n;;; in the case of action fail - bounce transaction. No effect if SEND_MODE_IGNORE_ERRORS (+2) is used. TVM UPGRADE 2023-07. https://docs.ton.org/learn/tvm-instructions/tvm-upgrade-2023-07#sending-messages\nconst int SEND_MODE_BOUNCE_ON_ACTION_FAIL = 16;\n\n;; Only for `send_message`:\n\n;;; do not create an action, only estimate fee. TVM UPGRADE 2023-07. https://docs.ton.org/learn/tvm-instructions/tvm-upgrade-2023-07#sending-messages\nconst int SEND_MODE_ESTIMATE_FEE_ONLY = 1024;\n\n;; Other modes affect the fee calculation as follows:\n;; +64 substitutes the entire balance of the incoming message as an outcoming value (slightly inaccurate, gas expenses that cannot be estimated before the computation is completed are not taken into account).\n;; +128 substitutes the value of the entire balance of the contract before the start of the computation phase (slightly inaccurate, since gas expenses that cannot be estimated before the completion of the computation phase are not taken into account).\n\n;; RESERVE MODES - https://docs.ton.org/tvm.pdf page 137, RAWRESERVE\n\n;;; Creates an output action which would reserve exactly x nanograms (if y = 0).\nconst int RESERVE_REGULAR = 0;\n;;; Creates an output action which would reserve at most x nanograms (if y = 2).\n;;; Bit +2 in y means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved.\nconst int RESERVE_AT_MOST = 2;\n;;; in the case of action fail - bounce transaction. No effect if RESERVE_AT_MOST (+2) is used. TVM UPGRADE 2023-07. https://docs.ton.org/learn/tvm-instructions/tvm-upgrade-2023-07#sending-messages\nconst int RESERVE_BOUNCE_ON_ACTION_FAIL = 16;\n\n;; TOKEN METADATA\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md\n\n;; Key is sha256 hash of string. Value is data encoded as described in \"Data serialization\" paragraph.\n;; Snake format - must be prefixed with 0x00 byte\n(cell, ()) ~set_token_snake_metadata_entry(cell content_dict, int key, slice value) impure {\n    content_dict~udict_set_ref(256, key, begin_cell().store_uint(0, 8).store_slice(value).end_cell());\n    return (content_dict, ());\n}\n\n;; On-chain content layout The first byte is 0x00 and the rest is key/value dictionary.\ncell create_token_onchain_metadata(cell content_dict) inline {\n    return begin_cell().store_uint(0, 8).store_dict(content_dict).end_cell();\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/bcl_jetton_minter.fc",
        "content": "#include \"../imports/stdlib_modern.fc\";\n#include \"utils/jetton_utils.fc\";\n#include \"./op_codes.fc\";\n#include \"./storage.fc\";\n#include \"./errors.fc\";\n#include \"math/bcl_math.fc\";\n#include \"utils/log.fc\";\n#include \"utils/utils.fc\";\n#include \"dex/stonfi.fc\";\n#include \"../imports/math/math.fc\";\n\n;; TODO: probably we should use +16 flag for sending messages\n;; so that contract bounces if something goes wrong with our calculations\n\nconst gas::buy_op_cost = 50000000;      ;; 0.05 TON\nconst gas::sell_op_cost = 50000000;      ;; 0.05 TON\nconst gas::auxiliary_costs = 100000000;   ;; 0.1 TON\n\nconst additional_to_return_value = 50000000; ;; 0.05 TON\n\nint storage_fees() asm \"STORAGEFEES\";\n\n() send_fees(int amount, cell referal) impure inline {\n    ;; Send fees\n    send_raw_message(begin_cell()\n    .store_uint(0x10, 6)\n    .store_slice(ctx_fee_address)\n    .store_grams(amount)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(op::fee_payout, 32)\n    .store_dict(referal)\n    .end_cell(), SEND_MODE_PAY_FEES_SEPARATELY | SEND_MODE_BOUNCE_ON_ACTION_FAIL);\n}\n\n() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {\n    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);\n    slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n    var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(to_wallet_address)\n    .store_coins(amount)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init)\n    .store_ref(master_msg);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() send_mint_token(slice to_address, int amount, slice response_addr, int query_id, int msg_value, int send_mode) impure inline {\n    var master_msg = begin_cell()\n    .store_uint(0x178d4519, 32)\n    .store_uint(query_id, 64)\n    .store_coins(amount)\n    .store_uint(0, 2) ;; addr_none\n    .store_slice(response_addr) ;; resonse dest\n    .store_coins(0)     ;; forward ton amount\n    .store_uint(0, 1) ;; forward payload\n    .end_cell();\n\n    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), ctx_wallet_code);\n    slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n    var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(to_wallet_address)\n    .store_coins(msg_value)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init)\n    .store_ref(master_msg);\n    send_raw_message(msg.end_cell(), send_mode);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n\n    if (in_msg_body.slice_empty?()) {\n        ;; ignore empty messages\n        return ();\n    }\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        ;; ignore all bounced messages\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    load_base_data();\n\n    ;; User wants to buy some coins\n    if (op == op::buy) {\n        ;; By default sender is the buyer\n        var buyer_address = sender_address;\n\n        ;; Throw if trading is disabled\n        throw_if(err::trading_disabled, ctx_trading_enabled == 0);\n\n        ;; Throw if not enough TONs\n        throw_if(err::no_funds_for_gas, msg_value < gas::buy_op_cost);\n\n        ;; Deduct gas fee\n        msg_value -= gas::buy_op_cost;\n\n        var min_receive_amount = in_msg_body~load_coins();\n        var referral = in_msg_body~load_maybe_ref();\n\n        ;; Change buyer if its specified\n        if (~ slice_empty?(in_msg_body)) {\n            buyer_address = in_msg_body~load_msg_addr();\n        }\n\n\n        ;; Calculate amount of tokens to buy\n        var (ton_fees, coins_to_buy, tons_consumed) = calc_coins_for_tons(msg_value);\n\n        ;; Check slippage\n        throw_if(err::slippage_error, (coins_to_buy < min_receive_amount) | coins_to_buy <= 0);\n\n        var to_return = msg_value - tons_consumed;\n\n        ;; raw_reserve(x, 4) reserves balance BEFORE current message\n\n        ;; Update supply\n        ctx_total_supply += coins_to_buy;\n\n        ;; Update collected TON liq\n        ctx_ton_liq_collected += tons_consumed - ton_fees;\n\n        ;; Update last trade date\n        ctx_last_trade_date = now();\n\n        ;; Send fees\n        send_fees(ton_fees, referral);\n\n        ;; Send log message\n        emit_log(\n            begin_cell()\n            .store_uint(\"buy_log\"c, 32)\n            ;; Buyer\n            .store_slice(buyer_address)\n            ;; TON value\n            .store_coins(tons_consumed)\n            ;; Supply delta\n            .store_coins(coins_to_buy)\n            ;; New supply\n            .store_coins(ctx_total_supply)\n            ;; Collected TON liq\n            .store_coins(ctx_ton_liq_collected)\n            ;; Referal\n            .store_maybe_ref(referral)\n        );\n\n        var should_close_trading = ctx_total_supply >= ctx_bcl_supply;\n\n        if (should_close_trading) {\n            to_return += additional_to_return_value;\n        } else {\n            ;; This way we can return unused tons for gas to the user\n            raw_reserve(tons_consumed - ton_fees + storage_fees(), 4 + SEND_MODE_BOUNCE_ON_ACTION_FAIL);\n        }\n\n        ;; Send tokens\n        send_mint_token(\n            buyer_address,\n            coins_to_buy,\n            buyer_address,\n            query_id,\n            to_return,\n            should_close_trading ? (SEND_MODE_REGULAR | SEND_MODE_BOUNCE_ON_ACTION_FAIL) : (SEND_MODE_CARRY_ALL_BALANCE | SEND_MODE_BOUNCE_ON_ACTION_FAIL)\n        );\n\n        ;; All coins are sold, we cant send liq to STON.fi\n        if (should_close_trading) {\n            ;; Disable trading\n            ctx_trading_enabled = 0;\n\n            var ton_liq = ctx_ton_liq_collected - gas::total_lp_provide_gas - gas::auxiliary_costs - additional_to_return_value - ctx_trading_close_fee;\n\n            ;; Send Jetton part of liq\n            provide_jetton_lp(ctx_liq_supply);\n\n            ;; Increase total supply\n            ctx_total_supply += ctx_liq_supply;\n\n            ;; Send close fee\n            if (ctx_trading_close_fee > 0) {\n                send_fees(ctx_trading_close_fee, ctx_referral);\n            }\n\n            ;; Send TON part of liq\n            provide_ton_lp(ton_liq);\n\n            ;; Send log message\n            emit_log(\n                begin_cell()\n                .store_uint(\"send_liq_log\"c, 32)\n                ;; Liq in TON\n                .store_coins(ton_liq)\n                ;; Liq in coins\n                .store_coins(ctx_liq_supply)\n            );\n        }\n\n        ;; Save storage\n        store_base_data();\n\n        return ();\n    }\n\n    ;; BCL wallet wants to sell some tokens\n    if (op == op::sell_coins_notification) {\n        ;; Throw if trading is disabled\n        throw_if(err::trading_disabled, ctx_trading_enabled == 0);\n\n        int jetton_amount = in_msg_body~load_coins();\n        int min_receive_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n        cell referral = in_msg_body~load_maybe_ref();\n\n\n        ;; Accept sell messages only from wallets\n        throw_unless(err::not_valid_wallet, equal_slices_bits(calculate_user_jetton_wallet_address(from_address, my_address(), ctx_wallet_code), sender_address));\n\n        ;; Throw if not enough TONs\n        throw_if(err::no_funds_for_gas, msg_value < gas::sell_op_cost);\n\n        ;; This case should never appear\n        throw_if(err::too_many_coins_to_sell, jetton_amount > ctx_bcl_supply);\n\n        ;; Calculate amount TONs to return\n        var (ton_fees, tons_to_return) = calc_tons_for_coins(jetton_amount);\n\n        ;; Check slippage\n        throw_if(err::slippage_error, tons_to_return < min_receive_amount);\n\n        ;; Update supply\n        ctx_total_supply -= jetton_amount;\n\n        ;; Update collected TON liq\n        ctx_ton_liq_collected -= (tons_to_return + ton_fees);\n\n        ;; Update last trade date\n        ctx_last_trade_date = now();\n\n        ;; Reserve contract balance BEFORE the message minus tons to return minus fees and left sorage fees\n        ;; +8 means amount is considered as negative value\n        raw_reserve(tons_to_return + ton_fees - storage_fees(), 4 + 8 + SEND_MODE_BOUNCE_ON_ACTION_FAIL);\n\n        ;; Send fees\n        send_fees(ton_fees, referral);\n\n        ;; Send log message\n        emit_log(\n            begin_cell()\n            .store_uint(\"sell_log\"c, 32)\n            ;; Seller\n            .store_slice(from_address)\n            ;; TON value\n            .store_coins(tons_to_return)\n            ;; Supply delta\n            .store_coins(jetton_amount)\n            ;; New supply\n            .store_coins(ctx_total_supply)\n            ;; Collected TON liq\n            .store_coins(ctx_ton_liq_collected)\n            ;; Referal\n            .store_dict(referral)\n        );\n\n        ;; Send TONs\n        send_ok(from_address, 0, SEND_MODE_CARRY_ALL_BALANCE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);\n\n        ;; Save storage\n        store_base_data();\n\n\n        return ();\n    }\n\n    ;; Wallet wants to unlock\n    if (op == op::unlock_wallet_callback) {\n        var from_address = in_msg_body~load_msg_addr();\n\n        ;; Accept unlock request only from wallets\n        throw_unless(err::not_valid_wallet, equal_slices_bits(calculate_user_jetton_wallet_address(from_address, my_address(), ctx_wallet_code), sender_address));\n\n        ;; Wallets could be unlocked only after trading phase is over\n        throw_if(err::trading_enabled, ctx_trading_enabled == 1);\n\n        ;; Send excess to wallet\n        send_raw_message(begin_cell()\n        .store_uint(0x10, 6)\n        .store_slice(sender_address)\n        .store_grams(0)\n        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_uint(op::unlock_wallet_excess, 32)\n        .store_uint(query_id, 64)\n        .end_cell(), 64);\n\n        return ();\n    }\n\n    if (op == op::mint) {\n        throw_unless(73, equal_slices_bits(sender_address, ctx_admin));\n        slice to_address = in_msg_body~load_msg_addr();\n        int amount = in_msg_body~load_coins();\n        cell master_msg = in_msg_body~load_ref();\n        slice master_msg_cs = master_msg.begin_parse();\n        master_msg_cs~skip_bits(32 + 64); ;; op + query_id\n        int jetton_amount = master_msg_cs~load_coins();\n        mint_tokens(to_address, ctx_wallet_code, amount, master_msg);\n        ctx_total_supply += jetton_amount;\n        store_base_data();\n        return ();\n    }\n\n    if (op == op::burn_notification) {\n        int jetton_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n        throw_unless(74,\n            equal_slices_bits(calculate_user_jetton_wallet_address(from_address, my_address(), ctx_wallet_code), sender_address)\n        );\n        ctx_total_supply -= jetton_amount;\n        slice response_address = in_msg_body~load_msg_addr();\n        if (response_address.preload_uint(2) != 0) {\n            var msg = begin_cell()\n            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n            .store_slice(response_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses, 32)\n            .store_uint(query_id, 64);\n            send_raw_message(msg.end_cell(), 2 + 64);\n        }\n        store_base_data();\n        return ();\n    }\n\n    if (op == op::provide_wallet_address) {\n        ;; see provide_wallet_address TL-B layout in jetton.tlb\n        slice owner_address = in_msg_body~load_msg_addr();\n        int include_address? = in_msg_body~load_bool();\n        in_msg_body.end_parse();\n\n        cell included_address = include_address? ? begin_cell().store_slice(owner_address).end_cell() : null();\n\n        ;; build MessageRelaxed, see TL-B layout in stdlib.fc#L733\n        var msg = begin_cell()\n            .store_msg_flags_and_address_none(NON_BOUNCEABLE)\n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_prefix_only_body()\n            .store_op(op::take_wallet_address)\n            .store_query_id(query_id);\n\n        if (is_same_workchain(owner_address)) {\n            msg = msg.store_slice(calculate_user_jetton_wallet_address(owner_address, my_address(), ctx_wallet_code));\n        } else {\n            msg = msg.store_address_none();\n        }\n\n        cell msg_cell = msg.store_maybe_ref(included_address).end_cell();\n\n        send_raw_message(msg_cell, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE_BOUNCE_ON_ACTION_FAIL);\n        return ();\n    }\n\n    if (op == op::set_admin) {\n        ;; change admin\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin));\n        ctx_admin = in_msg_body~load_msg_addr();\n        store_base_data();\n\n        send_ok(sender_address, 0, 64);\n        return ();\n    }\n\n    if (op == op::set_author) {\n        ;; change author\n        throw_unless(err::not_author, equal_slices_bits(sender_address, ctx_author_address));\n        ctx_author_address = in_msg_body~load_msg_addr();\n        store_base_data();\n\n        send_ok(sender_address, 0, 64);\n        return ();\n    }\n\n    if (op == op::set_content) {\n        ;; change content, delete this for immutable tokens\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin) | equal_slices_bits(sender_address, ctx_author_address));\n        ctx_content = in_msg_body~load_ref();\n        store_base_data();\n        return ();\n    }\n\n    if (op == op::set_fees) {\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin));\n        ;; Fees address\n        ctx_fee_address = in_msg_body~load_msg_addr();\n        ;; Numerator\n        ctx_trade_fee_numerator = in_msg_body~load_uint(16);\n        ;; Denominator\n        ctx_trade_fee_denominator = in_msg_body~load_uint(16);\n\n        in_msg_body.end_parse();\n        send_ok(sender_address, 0, 64);\n        store_base_data();\n        return ();\n    }\n\n    if (op == op::set_code) {\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin));\n        var code = in_msg_body~load_ref();\n        in_msg_body.end_parse();\n        set_code(code);\n\n        send_ok(sender_address, 0, 64);\n        return ();\n    }\n\n    if (op == op::set_data) {\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin));\n        var data = in_msg_body~load_ref();\n        in_msg_body.end_parse();\n        set_data(data);\n\n        send_ok(sender_address, 0, 64);\n        return ();\n    }\n\n    if (op == op::set_code_data) {\n        throw_unless(err::not_admin, equal_slices_bits(sender_address, ctx_admin));\n        var code = in_msg_body~load_ref();\n        var data = in_msg_body~load_ref();\n        in_msg_body.end_parse();\n\n        set_code(code);\n        set_data(data);\n\n        send_ok(sender_address, 0, 64);\n        return ();\n    }\n\n    if (op == op::top_up) {\n        return (); ;; just accept tons\n    }\n\n    if (op == op::excesses) {\n        return ();\n    }\n\n    throw(0xffff);\n}\n\nvar get_jetton_data() method_id {\n    load_base_data();\n    return (ctx_total_supply, -1, ctx_admin, ctx_content, ctx_wallet_code);\n}\n\nvar get_wallet_address(slice owner_address) method_id {\n    load_base_data();\n    return calculate_user_jetton_wallet_address(\n        owner_address,\n        my_address(),\n        ctx_wallet_code\n    );\n}\n\n;;\n;; BCL specific methods\n;;\nvar coin_price() method_id {\n    load_base_data();\n    return calc_coin_price();\n}\n\nvar coins_for_tons(int tons) method_id {\n    load_base_data();\n\n    var (fees, coins, tons_consumed) = calc_coins_for_tons(tons);\n\n    if (coins <= 0) {\n        return (0, 0);\n    }\n\n    return (fees, coins);\n}\n\nvar tons_for_coins(int coins) method_id {\n    load_base_data();\n\n    var (fees, tons) = calc_tons_for_coins(coins);\n\n    if (tons <= 0) {\n        return (0, 0);\n    }\n    return (fees, tons);\n}\n\nvar get_bcl_data() method_id {\n    load_base_data();\n    var (full_price_ton_fees, full_price_ton_need) = calc_tons_for_all_coins();\n    return (\n        ctx_total_supply,\n        ctx_bcl_supply,\n        ctx_liq_supply,\n        ctx_admin,\n        ctx_author_address,\n        ctx_content,\n        ctx_fee_address,\n        ctx_trade_fee_numerator,\n        ctx_trade_fee_denominator,\n        ctx_ttl,\n        ctx_last_trade_date,\n        ctx_trading_enabled,\n        ctx_ton_liq_collected,\n        ctx_referral,\n        ctx_trading_close_fee,\n        full_price_ton_need,\n        full_price_ton_fees,\n        ctx_router_address,\n        ctx_router_pton_wallet_address\n    );\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "contracts/bcl/utils/utils.fc",
        "content": "#include \"../../imports/stdlib_modern.fc\";\n\nconst addr_none = \"2_\"s;\n\nconst const::ok = 0xf09f918d;\n\n() send_ok(slice to_addr, int value, int mode) impure {\n    var msg = begin_cell()\n    .store_uint(0x10, 6)\n    .store_slice(to_addr)\n    .store_grams(value)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(0, 32)\n    .store_uint(const::ok, 32)\n    .end_cell();\n\n    send_raw_message(msg, mode);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/imports/math/fp/fp.fc",
        "content": "{-\n    math/fp/fp.fc\n\n    This library provide functions for fixed point math.\n-}\n\n;; internal functions\n\n(int) negate(int _n) asm \"NEGATE\";\n\nint __fp_math::ln_36(int _x) impure inline {\n    _x *= __math::ONE_18;\n    int z = muldiv((_x - __math::ONE_36), __math::ONE_36, (_x + __math::ONE_36));\n    int z_squared = muldiv(z, z, __math::ONE_36);\n\n    int num = z;\n    int series_sum = num;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 3;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 5;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 7;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 9;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 11;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 13;\n\n    num = muldiv(num, z_squared, __math::ONE_36);\n    series_sum += num / 15;\n\n    return series_sum * 2;\n}\n\nint __fp_math::ln(int _a) impure inline {\n    if _a < __math::ONE_18 { return negate(__fp_math::ln(muldiv(__math::ONE_18, __math::ONE_18, _a))); }\n\n    int sum = 0;\n    if _a >= __math::a0 * __math::ONE_18 {\n        _a /= __math::a0;\n        sum += __math::x0;\n    }\n\n    if _a >= __math::a1 * __math::ONE_18 {\n        _a /= __math::a1;\n        sum += __math::x1;\n    }\n\n    sum *= 100;\n    _a *= 100;\n\n    if _a >= __math::a2 {\n        _a = muldiv(_a, __math::ONE_20, __math::a2);\n        sum += __math::x2;\n    }\n\n    if _a >= __math::a3 {\n        _a = muldiv(_a, __math::ONE_20, __math::a3);\n        sum += __math::x3;\n    }\n\n    if _a >= __math::a4 {\n        _a = muldiv(_a, __math::ONE_20, __math::a4);\n        sum += __math::x4;\n    }\n\n    if _a >= __math::a5 {\n        _a = muldiv(_a, __math::ONE_20, __math::a5);\n        sum += __math::x5;\n    }\n\n    if _a >= __math::a6 {\n        _a = muldiv(_a, __math::ONE_20, __math::a6);\n        sum += __math::x6;\n    }\n\n    if _a >= __math::a7 {\n        _a = muldiv(_a, __math::ONE_20, __math::a7);\n        sum += __math::x7;\n    }\n\n    if _a >= __math::a8 {\n        _a = muldiv(_a, __math::ONE_20, __math::a8);\n        sum += __math::x8;\n    }\n\n    if _a >= __math::a9 {\n        _a = muldiv(_a, __math::ONE_20, __math::a9);\n        sum += __math::x9;\n    }\n\n    if _a >= __math::a10 {\n        _a = muldiv(_a, __math::ONE_20, __math::a10);\n        sum += __math::x10;\n    }\n\n    if _a >= __math::a11 {\n        _a = muldiv(_a, __math::ONE_20, __math::a11);\n        sum += __math::x11;\n    }\n\n    int z = muldiv((_a - __math::ONE_20),  __math::ONE_20, (_a + __math::ONE_20));\n    int z_squared = muldiv(z, z, __math::ONE_20);\n\n    int num = z;\n    int series_sum = num;\n\n    num = muldiv(num, z_squared, __math::ONE_20);\n    series_sum += num / 3;\n\n    num = muldiv(num, z_squared, __math::ONE_20);\n    series_sum += num / 5;\n\n    num = muldiv(num, z_squared, __math::ONE_20);\n    series_sum += num / 7;\n\n    num = muldiv(num, z_squared, __math::ONE_20);\n    series_sum += num / 9;\n\n    num = muldiv(num, z_squared, __math::ONE_20);\n    series_sum += num / 11;\n\n    series_sum *= 2;\n\n    int result = (sum + series_sum) / 100;\n    return result;\n}\n\n;; public functions\n\nint math::fp::mul(int a, int b) inline {\n    return muldiv(a, b, __math::ONE_18);\n}\n\nint math::fp::div(int a, int b) impure inline {\n    throw_if(math::error::zero_division, b == 0);\n    return muldiv(a, __math::ONE_18, b);\n}\n\nint math::fp::mul_up(int a, int b) inline {\n    int product = a * b;\n\n    ;; The traditional divUp formula is:\n    ;; divUp(x, y) := (x + y - 1) / y\n    ;; To avoid intermediate overflow in the addition, we distribute the division and get:\n    ;; divUp(x, y) := (x - 1) / y + 1\n    ;; Note that this requires x != 0, if x == 0 then the result is zero\n    return product == 0 ? 0 : ((product - 1) / math::ONE_DEC) + 1;\n}\n\nint math::fp::div_up(int a, int b) inline {\n    throw_if(math::error::zero_division, b == 0);\n\n    ;; The traditional divUp formula is:\n    ;; divUp(x, y) := (x + y - 1) / y\n    ;; To avoid intermediate overflow in the addition, we distribute the division and get:\n    ;; _divUp(x, y) := (x - 1) / y + 1\n    ;; Note that this requires x != 0, if x == 0 then the result is zero\n\n    return a == 0 ? 0 : (a * math::ONE_DEC - 1) / b + 1;\n}\n\n;; add 18 decimals\nint math::fp::from(int _x) inline {\n    return _x * __math::ONE_18;\n}\n\n;; remove 18 decimals (floor)\nint math::fp::to(int _x) inline {\n    return _x / __math::ONE_18;\n}\n\n;; remove 18 decimals (ceil)\nint math::fp::to_ceil(int _x) inline {\n    return _x ^/ __math::ONE_18;\n}\n\n;; remove 18 decimals (round)\nint math::fp::to_round(int _x) inline {\n    return _x ~/ __math::ONE_18;\n}\n\n;; same as regular muldiv because extra __math::ONE_18 cancel each other out in div and mul\nint math::fp::muldiv(int _x, int _y, int _z) inline {\n    ;; ((x * y / __math::ONE_18) * __math::ONE_18 / z) = x * y / z\n    return muldiv(_x, _y, _z);\n}\n\n;; _a should have 18 decimals -> returns with 18 decimals\nint math::fp::ln(int _a) impure inline {\n    if _a == __math::e { return __math::ONE_18; }\n    if _a == __math::ONE_18 { return 0; }\n\n    throw_unless(math::error::out_of_bounds, _a > 0);\n\n    if (__math::LN_36_LOWER_BOUND < _a) & (_a < __math::LN_36_UPPER_BOUND) {\n        return __fp_math::ln_36(_a) / __math::ONE_18;\n    } else {\n        return __fp_math::ln(_a);\n    }\n}\n\n;; _arg and _base should have 18 decimals -> returns with 18 decimals\nint math::fp::log(int _arg, int _base) impure inline {\n    throw_if(math::error::0_base, _base == 0);\n    if _arg == __math::ONE_18 { return 0; }\n\n    int log_base = 0;\n    if (__math::LN_36_LOWER_BOUND < _base) & (_base < __math::LN_36_UPPER_BOUND) {\n        log_base = __fp_math::ln_36(_base);\n    } else {\n        log_base = __fp_math::ln(_base) * __math::ONE_18;\n    }\n\n    int log_arg = 0;\n    if (__math::LN_36_LOWER_BOUND < _arg) & (_arg < __math::LN_36_UPPER_BOUND) {\n        log_arg = __fp_math::ln_36(_arg);\n    } else {\n        log_arg = __fp_math::ln(_arg) * __math::ONE_18;\n    }\n\n    return muldiv(log_arg, __math::ONE_18, log_base);\n}\n\n;; _x should have 18 decimals -> returns with 18 decimals\nint math::fp::exp(int _x) impure inline {\n    if _x == __math::ONE_18 { return __math::e; }\n    throw_unless(math::error::invalid_exponent,\n        (_x >= __math::MIN_NATURAL_EXPONENT) & (_x <= __math::MAX_NATURAL_EXPONENT));\n\n    if _x < 0 { return muldiv(__math::ONE_18, __math::ONE_18, math::fp::exp(_x.negate())); }\n\n    int first_AN = 0;\n    if _x >= __math::x0 {\n        _x -= __math::x0;\n        first_AN = __math::a0;\n    } elseif _x >= __math::x1 {\n        _x -= __math::x1;\n        first_AN = __math::a1;\n    } else {\n        first_AN = 1;\n    }\n\n    _x *= 100;\n\n    int product = __math::ONE_20;\n    if _x >= __math::x2 {\n        _x -= __math::x2;\n        product = muldiv(product, __math::a2, __math::ONE_20);\n    }\n    if _x >= __math::x3 {\n        _x -= __math::x3;\n        product = muldiv(product, __math::a3, __math::ONE_20);\n    }\n    if _x >= __math::x4 {\n        _x -= __math::x4;\n        product = muldiv(product, __math::a4, __math::ONE_20);\n    }\n    if _x >= __math::x5 {\n        _x -= __math::x5;\n        product = muldiv(product, __math::a5, __math::ONE_20);\n    }\n    if _x >= __math::x6 {\n        _x -= __math::x6;\n        product = muldiv(product, __math::a6, __math::ONE_20);\n    }\n    if _x >= __math::x7 {\n        _x -= __math::x7;\n        product = muldiv(product, __math::a7, __math::ONE_20);\n    }\n    if _x >= __math::x8 {\n        _x -= __math::x8;\n        product = muldiv(product, __math::a8, __math::ONE_20);\n    }\n    if _x >= __math::x9 {\n        _x -= __math::x9;\n        product = muldiv(product, __math::a9, __math::ONE_20);\n    }\n\n    int series_sum = __math::ONE_20;\n    int term = _x;\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 2);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 3);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 4);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 5);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 6);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 7);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 8);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 9);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 10);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 11);\n    series_sum += term;\n\n    term = muldiv(term, _x, __math::ONE_20 * 12);\n    series_sum += term;\n\n    return muldiv(muldiv(product, series_sum, __math::ONE_20), first_AN, 100);\n}\n\n;; _x and _y should have 18 decimals -> returns with 18 decimals\nint math::fp::pow(int _x, int _y) impure inline {\n    if _y == 0 { return __math::ONE_18; }\n    if _x == 0 { return 0; }\n    if _x == __math::ONE_18 { return __math::ONE_18; }\n\n    throw_unless(math::error::x_out_of_bounds, _x >> 256 == 0);\n    throw_unless(math::error::y_out_of_bounds, _y < __math::MILD_EXPONENT_BOUND);\n\n    int logx_times_y = 0;\n    if (__math::LN_36_LOWER_BOUND < _x) & (_x < __math::LN_36_UPPER_BOUND) {\n        int ln_36_x = __fp_math::ln_36(_x);\n        logx_times_y = (ln_36_x / __math::ONE_18) * _y + muldiv(ln_36_x % __math::ONE_18, _y, __math::ONE_18);\n    } else {\n        logx_times_y = __fp_math::ln(_x) * _y;\n    }\n    logx_times_y /= __math::ONE_18;\n    throw_unless(math::error::product_out_of_bounds,\n        (__math::MIN_NATURAL_EXPONENT <= logx_times_y) & (logx_times_y <= __math::MAX_NATURAL_EXPONENT));\n\n    return math::fp::exp(logx_times_y);\n}\n\n;; _x has 18 decimals -> returns with 18 decimals\nint math::fp::pow_dec(int _x, int _y) impure inline {\n    if _y == 0 { return __math::ONE_18; }\n    if _x == 0 { return 0; }\n    if _x == __math::ONE_18 { return __math::ONE_18; }\n    throw_unless(math::error::negative_power, _y > 0);\n\n    int res = __math::ONE_18;\n    while _y > 0 {\n        if _y & 1 {\n            res = muldiv(res, _x, __math::ONE_18);\n        }\n        _y = _y >> 1;\n        _x = muldiv(_x, _x, __math::ONE_18);\n    }\n\n    return res;\n}\n\nint math::fp::complement(int _x) impure inline {\n    throw_if(math::error::cmplment_out_of_range, (_x < 0) | (_x > math::ONE_DEC));\n    return math::ONE_DEC - _x;\n}\n\n;; optimized pow for weighted math\n;; Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n;; the true value (that is, the error function expected - actual is always positive).\nint math::fp::ow_pow(int x, int y) impure inline {\n    ;; Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\n    ;; and 80/20 Weighted Pools\n    if y == 2 * math::ONE_DEC {\n        return math::fp::mul(x, x);\n    } elseif y == 4 * math::ONE_DEC {\n        int square = math::fp::mul(x, x);\n        return math::fp::mul(square, square);\n    } else {\n        int raw = math::fp::pow(x, y);\n        int maxError = math::fp::mul(raw, __math::max_pow_relative_error) + 1;\n\n        if raw < maxError {\n            return 0;\n        } else {\n            return raw - maxError;\n        }\n    }\n}\n\n;; optimized pow_up for weighted math\n;; Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n;; the true value (that is, the error function expected - actual is always negative).\nint math::fp::ow_pow_up(int x, int y) impure inline {\n    ;; Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\n    ;; and 80/20 Weighted Pools\n    if y == 2 * math::ONE_DEC {\n        return math::fp::mul(x, x);\n    } elseif y == 4 * math::ONE_DEC {\n        int square = math::fp::mul(x, x);\n        return math::fp::mul(square, square);\n    } else {\n        int raw = math::fp::pow(x, y);\n        int maxError = math::fp::mul(raw, __math::max_pow_relative_error) + 1;\n\n        return raw + maxError;\n    }\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/dex/stonfi.fc",
        "content": "#include \"../../imports/stdlib_modern.fc\";\n#include \"../utils/jetton_utils.fc\";\n#include \"../op_codes.fc\";\n#include \"../storage.fc\";\n#include \"../utils/utils.fc\";\n\nconst STON_PROVIDE_LP = 0x37c096df;\nconst PTON_TRANSFER_TON = 0x01f3835d;\n\nslice get_router() inline {\n    return ctx_router_address;\n}\n\nslice get_router_pton_wallet() inline {\n    return ctx_router_pton_wallet_address;\n}\n\nconst gas::lp_jetton::gas = 300000000; ;; 0.3 TON\nconst gas::lp_jetton::forward_gas = 240000000; ;; 0.24 TON\nconst gas::lp_ton::gas = 260000000; ;; 0.26 TON\nconst gas::total_lp_provide_gas = gas::lp_jetton::gas + gas::lp_ton::gas; ;; 0.3 + 0.26 = 0.56 TON\n\n;; internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n;;                     response_address:MsgAddress\n;;                     forward_ton_amount:(VarUInteger 16)\n;;                     forward_payload:(Either Cell ^Cell)\n;;                     = InternalMsgBody;\n\n() provide_jetton_lp(int amount) impure inline {\n    cell state_init = calculate_jetton_wallet_state_init(get_router(), my_address(), ctx_wallet_code);\n    slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n\n    var master_msg = begin_cell()\n    .store_uint(op::internal_transfer, 32)\n    .store_uint(0, 64)\n    .store_coins(amount)\n    .store_slice(my_address()) ;; from\n    .store_slice(my_address()) ;; resonse dest\n    .store_coins(gas::lp_jetton::forward_gas)\n    .store_dict(\n        begin_cell()\n            .store_uint(STON_PROVIDE_LP, 32) ;; PROVIDE_LP\n            .store_slice(get_router_pton_wallet()) ;; other wallet\n            .store_slice(my_address()) ;; refund address\n            .store_slice(my_address()) ;; excess address\n            .store_uint(0xffffffffffffffff, 64) ;; tx deadline\n            .store_ref(\n                begin_cell()\n                    .store_coins(1) ;; min lp out\n                    .store_slice(my_address()) ;; to address\n                    .store_uint(1, 1) ;; both positive\n                    .store_coins(0) ;; fwd amount\n                    .store_maybe_ref(null()) ;; fwd payload\n                .end_cell()\n            )\n        .end_cell()\n    )\n    .end_cell();\n\n    var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(to_wallet_address)\n    .store_coins(gas::lp_jetton::gas)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init)\n    .store_ref(master_msg);\n    send_raw_message(msg.end_cell(), 1);\n}\n\n;; transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\n;;           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n;;           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\n;;           = InternalMsgBody;\n\n() provide_ton_lp(int amount) impure inline {\n    cell state_init = calculate_jetton_wallet_state_init(get_router(), my_address(), ctx_wallet_code);\n    slice router_wallet_address = calculate_jetton_wallet_address(state_init);\n\n    var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(get_router_pton_wallet())\n    .store_coins(amount + gas::lp_ton::gas)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(PTON_TRANSFER_TON, 32)\n    .store_uint(0, 64)\n    .store_coins(amount)\n    .store_slice(my_address()) ;; response dest\n    .store_dict(\n        begin_cell()\n            .store_uint(STON_PROVIDE_LP, 32) ;; PROVIDE_LP\n            .store_slice(router_wallet_address) ;; other wallet\n            .store_slice(my_address()) ;; refund address\n            .store_slice(my_address()) ;; excess address\n            .store_uint(0xffffffffffffffff, 64) ;; tx deadline\n            .store_ref(\n                begin_cell()\n                    .store_coins(1) ;; min lp out\n                    .store_slice(my_address()) ;; to address\n                    .store_uint(1, 1) ;; both positive\n                    .store_coins(0) ;; fwd amount\n                    .store_maybe_ref(null()) ;; fwd payload\n                .end_cell()\n            )\n        .end_cell()\n    );\n\n    send_raw_message(msg.end_cell(), 1);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/imports/math/math.fc",
        "content": "{-\n    math.fc\n\n    This library provide functions for math. \n-}\n\n;; internal constants\n\nconst int __math::ONE_18 = 1000000000000000000; ;; 1e18\nconst int __math::ONE_20 = 100000000000000000000; ;; 1e20\nconst int __math::ONE_36 = 1000000000000000000000000000000000000; ;; 1e36\nconst int __math::MAX_NATURAL_EXPONENT = 130000000000000000000; ;; 130e18\nconst int __math::MIN_NATURAL_EXPONENT = -41000000000000000000;   ;; -41e18\nconst int __math::LN_36_LOWER_BOUND = __math::ONE_18 - 100000000000000000; ;; ONE_18 - 1e17\nconst int __math::LN_36_UPPER_BOUND = __math::ONE_18 + 100000000000000000; ;; ONE_18 + 1e17\nconst int __math::MILD_EXPONENT_BOUND = 28948022309329048855892746252171976963317496166410141009864396001978282409984 / __math::ONE_20; ;; 2**254 / ONE_20\nconst int __math::e   = 2718281828459045235;      ;; e\nconst int __math::x0  = 128000000000000000000;    ;; 2ˆ7\nconst int __math::a0  = 38877084059945950922200000000000000000000000000000000000; ;; eˆ(x0) (no decimals)\nconst int __math::x1  = 64000000000000000000;     ;; 2ˆ6\nconst int __math::a1  = 6235149080811616882910000000; ;; eˆ(x1) (no decimals)\nconst int __math::x2  = 3200000000000000000000;   ;; 2ˆ5\nconst int __math::a2  = 7896296018268069516100000000000000; ;; eˆ(x2)\nconst int __math::x3  = 1600000000000000000000;   ;; 2ˆ4\nconst int __math::a3  = 888611052050787263676000000; ;; eˆ(x3)\nconst int __math::x4  = 800000000000000000000;    ;; 2ˆ3\nconst int __math::a4  = 298095798704172827474000; ;; eˆ(x4)\nconst int __math::x5  = 400000000000000000000;    ;; 2ˆ2\nconst int __math::a5  = 5459815003314423907810;   ;; eˆ(x5)\nconst int __math::x6  = 200000000000000000000;    ;; 2ˆ1\nconst int __math::a6  = 738905609893065022723;    ;; eˆ(x6)\nconst int __math::x7  = 100000000000000000000;    ;; 2ˆ0\nconst int __math::a7  = 271828182845904523536;    ;; eˆ(x7)\nconst int __math::x8  = 50000000000000000000;     ;; 2ˆ-1\nconst int __math::a8  = 164872127070012814685;    ;; eˆ(x8)\nconst int __math::x9  = 25000000000000000000;     ;; 2ˆ-2\nconst int __math::a9  = 128402541668774148407;    ;; eˆ(x9)\nconst int __math::x10 = 12500000000000000000;     ;; 2ˆ-3\nconst int __math::a10 = 113314845306682631683;    ;; eˆ(x10)\nconst int __math::x11 = 6250000000000000000;      ;; 2ˆ-4\nconst int __math::a11 = 106449445891785942956;    ;; eˆ(x11)\nconst int __math::max_pow_relative_error = 10000; ;; 10^(-14)\n\n\n;; public constants\n\nconst int math::MAX_UINT8   = 0xFF; \nconst int math::MAX_UINT16  = 0xFFFF; \nconst int math::MAX_UINT32  = 0xFFFFFFFF; \nconst int math::MAX_UINT64  = 0xFFFFFFFFFFFFFFFF; \nconst int math::MAX_UINT128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \nconst int math::MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; \nconst int math::MAX_COINS   = 1329227995784915872903807060280344575; ;; 2^120 - 1\nconst int math::ONE_DEC     = __math::ONE_18;         ;; 1      with 18 decimals\nconst int math::E           = __math::e;              ;; e      with 18 decimals\nconst int math::PI          = 3141592653589793238;  ;; pi     with 18 decimals\nconst int math::PI_SQ       = 9869604401089358618;  ;; pi^2   with 18 decimals\nconst int math::1_DIV_E     = 0367879441171442321;  ;; 1/e    with 18 decimals\nconst int math::1_DIV_PI    = 0318309886183790671;  ;; 1/pi   with 18 decimals\nconst int math::1_DIV_PI_SQ = 0101321183642337771;  ;; 1/pi^2 with 18 decimals\n\n\n;; errors\n\nconst math::error::x_out_of_bounds       = 50001;\nconst math::error::y_out_of_bounds       = 50002;\nconst math::error::product_out_of_bounds = 50003;\nconst math::error::invalid_exponent      = 50004;\nconst math::error::out_of_bounds         = 50005;\nconst math::error::0_base                = 50006;\nconst math::error::negative_power        = 50007;\nconst math::error::zero_division         = 50008;\nconst math::error::cmplment_out_of_range = 51002;\n\n\n#include \"int/int.fc\";\n#include \"fp/fp.fc\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/math/bcl_math.fc",
        "content": "#include \"../../imports/math/math.fc\";\n#include \"bcl_math_core_2.fc\";\n\n;;\n;; High level curve math\n;;\n\n;; Current price\nint calc_coin_price() inline {\n    if (ctx_total_supply == 0) {\n        return 0;\n    }\n\n    return math::calc_coin_price(ctx_total_supply);\n}\n\n;; Sell operation\nvar calc_tons_for_coins(int tokens) inline {\n    var tons_to_get = math::calc_tons_for_coins(tokens, ctx_total_supply);\n    ;; Calc fees in TON\n    var fees = muldiv(tons_to_get, ctx_trade_fee_numerator, ctx_trade_fee_denominator);\n\n    ;; Deduct fees\n    tons_to_get -= fees;\n\n    return (fees, tons_to_get);\n}\n\nvar calc_tons_for_all_coins() inline {\n    var tons_need = math::calc_tons_for_coins(ctx_bcl_supply, ctx_bcl_supply);\n\n    var full_tons_need = muldivc(tons_need, ctx_trade_fee_denominator, ctx_trade_fee_denominator - ctx_trade_fee_numerator) + 1;\n\n    var fees = muldiv(full_tons_need, ctx_trade_fee_numerator, ctx_trade_fee_denominator);\n\n    return (fees, full_tons_need);\n}\n\n;; Buy operation\nvar calc_coins_for_tons(int tons) inline {\n    var incoming_tons = tons;\n    var available_to_buy = ctx_bcl_supply - ctx_total_supply;\n\n    ;; Calc fees in TON\n    var fees = muldiv(tons, ctx_trade_fee_numerator, ctx_trade_fee_denominator);\n    ;; Deduct fees\n    tons = tons - fees;\n\n    var coins_to_get = math::calc_coins_for_tons(tons, ctx_total_supply);\n\n\n    ;; Calculations for rest of available coins\n    if (coins_to_get > available_to_buy) {\n        var tons_no_fees = math::calc_tons_for_coins(available_to_buy, ctx_total_supply + available_to_buy);\n\n        ;; Add fees\n        var tons_need = muldivc(tons_no_fees, ctx_trade_fee_denominator, ctx_trade_fee_denominator - ctx_trade_fee_numerator);\n\n        ;; Calc fees in TON\n        var fees = muldiv(tons_need, ctx_trade_fee_numerator, ctx_trade_fee_denominator);\n\n        return (fees, available_to_buy, tons_need);\n    }\n\n    return (fees, coins_to_get, incoming_tons);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/math/bcl_math_core_2.fc",
        "content": "#include \"../../imports/math/math.fc\";\n#include \"../../imports/math/fp/fp.fc\";\n\n;;\n;; Core curve math, does not include any edge cases handling or fees calculation\n;;\n\nconst coeff::vTon = 333333333333333333;\nconst coeff::vToken = 333333333333333333;\nconst coeff::K = 444444444444444444;\n\n;; const MAX_TON = 1500000000000000000000; ;; ctx_max_ton\n;; const MAX_TON = 3000000000000000000; ;; ctx_max_ton\n\nconst ONE_9 = 1000000000; ;; 1e9\n\n;; Formulas for on TONs and TOKENS, not in nano format\n\n;; Converts nanoTON to TON & FP\n;; nano TON is 10^9, FP numbers are * 10^18,\n;; so we need to mul by 10^18 and div by 10^9 which is just mul by 10^9\nint to_fp(int value) inline {\n    return value * ONE_9;\n}\n\n;; Converts FP TON to nanoTON\nint from_fp(int value) inline {\n    return value / ONE_9;\n}\n\nint real_ton(int r_token) {\n    var a = math::fp::mul(math::fp::mul(coeff::K,  ctx_max_ton), to_fp(ctx_bcl_supply));\n    var b = (math::fp::mul(coeff::vToken, to_fp(ctx_bcl_supply)) + r_token);\n\n    return math::fp::div(a, b) - math::fp::mul(coeff::vTon, ctx_max_ton);\n}\n\n;; Current price\nint math::calc_coin_price(int current_supply) inline {\n    var r_token = to_fp(ctx_bcl_supply) - to_fp(current_supply);\n    var r_ton = real_ton(r_token);\n\n    var a = math::fp::mul(coeff::vTon, ctx_max_ton) + r_ton;\n    var b = math::fp::mul(coeff::vToken, to_fp(ctx_bcl_supply)) + r_token;\n\n    return from_fp(math::fp::div(a, b));\n}\n\n;; Calculates how much TONs could be received for selling given amount of coins\n;; Used for SELL operation\nvar math::calc_tons_for_coins(int tokens, int current_supply) inline {\n\n    current_supply = to_fp(current_supply);\n    tokens = to_fp(tokens);\n\n    var r_token = to_fp(ctx_bcl_supply) - current_supply;\n    var r_ton = real_ton(r_token);\n\n    var a = math::fp::mul(\n        tokens,\n        math::fp::mul(coeff::vTon, ctx_max_ton) + r_ton\n    );\n\n    var b = math::fp::mul(coeff::vToken, to_fp(ctx_bcl_supply)) + tokens + r_token;\n\n    return from_fp(math::fp::div(a, b));\n}\n\n;; Calculates how much tokens could be received for given amount of TONs\n;; Used for BUY operation\nvar math::calc_coins_for_tons(int tons, int current_supply) inline {\n    tons = to_fp(tons);\n    current_supply = to_fp(current_supply);\n\n    var r_token = to_fp(ctx_bcl_supply) - current_supply;\n    var r_ton = real_ton(r_token);\n\n    var a = math::fp::mul(tons, math::fp::mul(coeff::vToken, to_fp(ctx_bcl_supply)) + r_token);\n    var b = math::fp::mul(coeff::vTon, ctx_max_ton) + tons + r_ton;\n\n    return from_fp(math::fp::div(a, b));\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/utils/jetton_utils.fc",
        "content": "#include \"../../imports/stdlib_modern.fc\";\n#include \"workchain.fc\";\n\nconst int STATUS_SIZE = 4;\n\ncell pack_jetton_wallet_data(int status, int balance, slice owner_address, slice jetton_master_address) inline {\n    return begin_cell()\n    .store_uint(status, STATUS_SIZE)\n    .store_coins(balance)\n    .store_slice(owner_address)\n    .store_slice(jetton_master_address)\n    .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    {-\n    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L144\n    _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)\n    code:(Maybe ^Cell) data:(Maybe ^Cell)\n    library:(Maybe ^Cell) = StateInit;\n  -}\n    return begin_cell()\n    .store_uint(0, 2) ;; 0b00 - No split_depth; No special\n    .store_maybe_ref(jetton_wallet_code)\n    .store_maybe_ref(\n        pack_jetton_wallet_data(\n            0, ;; status\n            0, ;; balance\n            owner_address,\n            jetton_master_address)\n    )\n    .store_uint(0, 1) ;; Empty libraries\n    .end_cell();\n}\n\nslice calculate_jetton_wallet_address(cell state_init) inline {\n    {-\n    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105\n    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;\n    -}\n    return begin_cell()\n    .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast\n    .store_int(MY_WORKCHAIN, 8)\n    .store_uint(cell_hash(state_init), 256)\n    .end_cell()\n    .begin_parse();\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n() check_either_forward_payload(slice s) impure inline {\n    if (s.preload_uint(1)) {\n        ;; forward_payload in ref\n        (int remain_bits, int remain_refs) = slice_bits_refs(s);\n        throw_unless(err::invalid_message, (remain_refs == 1) & (remain_bits == 1)); ;; we check that there is no excess in the slice\n    }\n    ;; else forward_payload in slice - arbitrary bits and refs\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/utils/workchain.fc",
        "content": "#include \"../../imports/stdlib_modern.fc\";\n#include \"../op_codes.fc\";\n#include \"../errors.fc\";\n\nconst MY_WORKCHAIN = BASECHAIN;\n\nint is_same_workchain(slice addr) inline {\n    (int wc, _) = parse_std_addr(addr);\n    return wc == MY_WORKCHAIN;\n}\n\n() check_same_workchain(slice addr) impure inline {\n    throw_unless(err::wrong_workchain, is_same_workchain(addr));\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/utils/log.fc",
        "content": "#include \"../../imports/stdlib_modern.fc\";\n\n() emit_log(builder data) impure inline {\n    ;; 1023 - (4+2+9+256+64+32+2) = 654 bit free\n\n    ;;    var msg = begin_cell()\n    ;;    .store_uint (12, 4)         ;; ext_out_msg_info$11 src:MsgAddressInt ()\n    ;;    .store_uint (1, 2)          ;; addr_extern$01\n    ;;    .store_uint (256, 9)        ;; len:(## 9)\n    ;;    .store_uint(event_id, 256); ;; external_address:(bits len)\n    ;;\n    ;;    if (need_separate_cell) {\n    ;;        msg = msg.store_uint(1, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n    ;;        .store_ref(data);\n    ;;    } else {\n    ;;        msg = msg.store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n    ;;        .store_slice(data.begin_parse());\n    ;;    }\n\n    send_raw_message(\n        begin_cell()\n        .store_uint (12, 4)\n        .store_uint(0, 100)\n        .store_builder(data)\n        .end_cell(),\n        0\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/imports/math/int/int.fc",
        "content": "{-\n    math/int/int.fc\n\n    This library provide functions for integer math. \n-}\n\nint math::int::sqrt(int x) inline {\n    if (x == 0) { return x; }\n\n    int r = 181;\n    int xx = x;\n    if xx >= 0x100000000000000000000000000000000 {\n        xx >>= 128;\n        r <<= 64;\n    }\n    if xx >= 0x10000000000000000 {\n        xx >>= 64;\n        r <<= 32;\n    }\n    if xx >= 0x100000000 {\n        xx >>= 32;\n        r <<= 16;\n    }\n    if xx >= 0x10000 {\n        xx >>= 16;\n        r <<= 8;\n    }\n\n    r = (r * (xx + 65536)) >> 18;\n\n    repeat(7) {\n        r = (r + x / r) >> 1;\n    }\n\n    int r1 = x / r;\n\n    return (r < r1 ? r : r1);\n}\n\nint math::int::pow(int _x, int _y) impure inline {\n    if _y == 0 { return 1; }\n    if _x == 0 { return 0; }\n    if _x == 1 { return 1; }\n    throw_unless(math::error::negative_power, _y > 0);\n\n    int res = 1;\n    while _y > 0 {\n        if _y & 1 {\n            res = res * _x;\n        }\n        _y = _y >> 1; \n        _x = _x * _x; \n    }\n\n    return res;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/op_codes.fc",
        "content": ";; Jetton standard\nconst op::transfer = 0xf8a7ea5;\nconst op::transfer_notification = 0x7362d09c;\nconst op::internal_transfer = 0x178d4519;\nconst op::excesses = 0xd53276db;\nconst op::burn = 0x595f07bc;\nconst op::burn_notification = 0x7bdd97de;\n\n;; Discoverable Jetton standard\nconst op::provide_wallet_address = 0x2c76b973;\nconst op::take_wallet_address = 0xd1735400;\n\n;; Jetton Minter\nconst op::mint = 21;\n\n;; BCL\nconst op::collect_fees = \"op::collect_fees\"c;\nconst op::set_fees = \"op::set_fees\"c;\nconst op::set_code = \"op::set_code\"c;\nconst op::set_data = \"op::set_data\"c;\nconst op::set_code_data = \"op::set_code_data\"c;\nconst op::set_admin = \"op::set_admin\"c;\nconst op::set_content = \"op::set_content\"c;\nconst op::set_author = \"op::set_author\"c;\nconst op::buy = \"op::buy\"c;\nconst op::sell = \"op::sell\"c;\n;; sent from user jetton wallet to master\nconst op::sell_coins_notification = \"op::sell_coins_notification\"c;\n\n;; sent to the wallet from owner\nconst op::unlock_wallet = \"op::unlock_wallet\"c;\n;; sent from wallet to master\nconst op::unlock_wallet_callback = \"op::unlock_wallet_callback\"c;\n;; sent from master to wallet\nconst op::unlock_wallet_excess = \"op::unlock_wallet_excess\"c;\n\nconst op::send_liq = \"op::send_liq\"c;\nconst op::drain = \"op::drain\"c;\n\nconst op::fee_payout = \"op::fee_payout\"c;\n\nconst op::top_up = 0xd372158c;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/errors.fc",
        "content": "const err::slippage_error = 707;\nconst err::too_many_coins_to_buy = 708;\nconst err::no_funds_for_gas = 709;\nconst err::trading_disabled = 711;\nconst err::trading_enabled = 712;\nconst err::not_valid_wallet = 713;\nconst err::too_many_coins_to_sell = 714;\nconst err::not_admin = 715;\nconst err::not_author = 716;\n\nconst err::wrong_workchain = 333;\nconst err::not_owner = 73;\n;; jetton-wallet\nconst err::balance_error = 47;\nconst err::not_enough_gas = 48;\nconst err::invalid_message = 49;\n\nconst err::wrong_op = 0xffff;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "contracts/bcl/storage.fc",
        "content": "#include \"../imports/stdlib_modern.fc\";\n\n;; Jetton Minter data\nglobal int ctx_total_supply;\nglobal slice ctx_admin;\nglobal cell ctx_content;\nglobal cell ctx_wallet_code;\nglobal int ctx_ttl;\nglobal int ctx_last_trade_date;\nglobal int ctx_ton_liq_collected;\nglobal int ctx_max_ton;\n\n\n;; BCL data\nglobal int ctx_bcl_supply;\nglobal int ctx_liq_supply;\nglobal slice ctx_author_address;\nglobal slice ctx_fee_address;\nglobal int ctx_trade_fee_numerator;\nglobal int ctx_trade_fee_denominator;\nglobal int ctx_trading_enabled;\nglobal cell ctx_referral;\nglobal int ctx_seed;\nglobal int ctx_trading_close_fee;\n\nglobal slice ctx_router_address;\nglobal slice ctx_router_pton_wallet_address;\n\n() load_base_data() impure {\n    var ds = get_data().begin_parse();\n\n    ctx_total_supply = ds~load_coins();\n    ctx_admin = ds~load_msg_addr();\n    ctx_content = ds~load_ref();\n    ctx_wallet_code = ds~load_ref();\n    ctx_ttl = ds~load_uint(32);\n    ctx_last_trade_date = ds~load_uint(32);\n    ctx_ton_liq_collected = ds~load_coins();\n    ctx_max_ton = ds~load_coins();\n\n\n    var bcl_ds = ds~load_ref().begin_parse();\n    ctx_bcl_supply = bcl_ds~load_coins();\n    ctx_liq_supply = bcl_ds~load_coins();\n    ctx_author_address = bcl_ds~load_msg_addr();\n    ctx_fee_address = bcl_ds~load_msg_addr();\n    ctx_trade_fee_numerator = bcl_ds~load_uint(16);\n    ctx_trade_fee_denominator = bcl_ds~load_uint(16);\n    ctx_trading_enabled = bcl_ds~load_uint(1);\n    ctx_referral = bcl_ds~load_ref();\n    ctx_seed = bcl_ds~load_uint(64);\n    ctx_trading_close_fee = bcl_ds~load_coins();\n\n    slice router_info = bcl_ds~load_ref().begin_parse();\n    ctx_router_address = router_info~load_msg_addr();\n    ctx_router_pton_wallet_address = router_info~load_msg_addr();\n\n    router_info.end_parse();\n    bcl_ds.end_parse();\n    ds.end_parse();\n}\n\n() store_base_data() impure {\n    set_data(begin_cell()\n    .store_coins(ctx_total_supply)\n    .store_slice(ctx_admin)\n    .store_ref(ctx_content)\n    .store_ref(ctx_wallet_code)\n    .store_uint(ctx_ttl, 32)\n    .store_uint(ctx_last_trade_date, 32)\n    .store_coins(ctx_ton_liq_collected)\n    .store_coins(ctx_max_ton)\n    .store_ref(begin_cell()\n        .store_coins(ctx_bcl_supply)\n        .store_coins(ctx_liq_supply)\n        .store_slice(ctx_author_address)\n        .store_slice(ctx_fee_address)\n        .store_uint(ctx_trade_fee_numerator, 16)\n        .store_uint(ctx_trade_fee_denominator, 16)\n        .store_uint(ctx_trading_enabled, 1)\n        .store_ref(ctx_referral)\n        .store_uint(ctx_seed, 64)\n        .store_coins(ctx_trading_close_fee)\n        .store_ref(\n            begin_cell()\n                .store_slice(ctx_router_address)\n                .store_slice(ctx_router_pton_wallet_address)\n            .end_cell())\n        .end_cell())\n    .end_cell()\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}