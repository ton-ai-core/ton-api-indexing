{
  "code": "b5ee9c72010214010002d4000114ff00f4a413f4bcf2c80b010201200203020148040504f8f28308d71820d31fd31fd31f02f823bbf264ed44d0d31fd31fd3fff404d15143baf2a15151baf2a205f901541064f910f2a3f80024a4c8cb1f5240cb1f5230cbff5210f400c9ed54f80f01d30721c0009f6c519320d74a96d307d402fb00e830e021c001e30021c002e30001c0039130e30d03a4c8cb1f12cb1fcbff1011121302e6d001d0d3032171b0925f04e022d749c120925f04e002d31f218210706c7567bd22821064737472bdb0925f05e003fa403020fa4401c8ca07cbffc9d0ed44d0810140d721f404305c810108f40a6fa131b3925f07e005d33fc8258210706c7567ba923830e30d03821064737472ba925f06e30d06070201200809007801fa00f40430f8276f2230500aa121bef2e0508210706c7567831eb17080185004cb0526cf1658fa0219f400cb6917cb1f5260cb3f20c98040fb0006008a5004810108f45930ed44d0810140d720c801cf16f400c9ed540172b08e23821064737472831eb17080185005cb055003cf1623fa0213cb6acb1fcb3fc98040fb00925f03e20201200a0b0059bd242b6f6a2684080a06b90fa0218470d4080847a4937d29910ce6903e9ff9837812801b7810148987159f31840201580c0d0011b8c97ed44d0d70b1f8003db29dfb513420405035c87d010c00b23281f2fff274006040423d029be84c600201200e0f0019adce76a26840206b90eb85ffc00019af1df6a26840106b90eb858fc0006ed207fa00d4d422f90005c8ca0715cbffc9d077748018c8cb05cb0222cf165005fa0214cb6b12ccccc973fb00c84014810108f451f2a7020070810108d718fa00d33fc8542047810108f451f2a782106e6f746570748018c8cb05cb025006cf165004fa0214cb6a12cb1fcb3fc973fb0002006c810108d718fa00d33f305224810108f459f2a782106473747270748018c8cb05cb025005cf165003fa0213cb6acb1f12cb3fc973fb00000af400c9ed54",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      -1 => <{\n            9 PUSHPOW2\n            LDSLICEX\n            DUP\n            32 LDU\n            32 LDU\n            32 LDU\n            s0 s2 XCHG\n            NOW\n            LEQ\n            36 THROWIF\n            c4 PUSH\n            CTOS\n            32 LDU\n            32 LDU\n            256 LDU\n            LDDICT\n            ENDS\n            s4 s3 XCPU\n            EQUAL\n            33 THROWIFNOT\n            s5 s1 XCPU\n            EQUAL\n            34 THROWIFNOT\n            s0 s5 XCHG\n            HASHSU\n            s0 s6 s4 XC2PU\n            CHKSIGNU\n            35 THROWIFNOT\n            ACCEPT\n            s4 PUSH\n            INC\n            NEWC\n            32 STU\n            s4 s(-1) PUXC\n            32 STU\n            s3 s(-1) PUXC\n            256 STU\n            s1 s(-1) PUXC\n            STDICT\n            ENDC\n            c4 POP\n            COMMIT\n            SWAP\n            8 LDU\n            OVER\n            0 EQINT\n            IFJMP:<{\n                  5 1 BLKDROP2\n                  WHILE:<{\n                        DUP\n                        SREFS\n                  }>DO<{\n                        8 LDU\n                        LDREF\n                        s0 s2 XCHG\n                        SENDRAWMSG\n                  }>\n                  DROP\n            }>\n            OVER\n            1 EQINT\n            IF:<{\n                  8 LDI\n                  LDGRAMS\n                  LDREF\n                  LDREF\n                  s2 PUSH\n                  HASHCU\n                  s0 s5 XCHG\n                  NEWC\n                  8 STI\n                  s1 s5 XCHG\n                  256 STU\n                  ENDC\n                  CTOS\n                  7 PUSHINT\n                  4 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  3 STU\n                  s2 PUSH\n                  STSLICER\n                  s0 s5 XCHG2\n                  STGRAMS\n                  s1 s4 XCHG\n                  108 STU\n                  s1 s2 XCHG\n                  STREF\n                  STREF\n                  ENDC\n                  3 PUSHINT\n                  SENDRAWMSG\n                  NEWC\n                  s0 s1 s4 XCHG3\n                  264 PUSHINT\n                  DICTADDB\n                  39 THROWIFNOT\n                  s0 s2 XCHG\n            }>\n            OVER\n            2 EQINT\n            IF:<{\n                  264 PUSHINT\n                  LDSLICEX\n                  LDGRAMS\n                  64 LDU\n                  NEWC\n                  s0 s4 s6 XCPUXC\n                  264 PUSHINT\n                  DICTADDB\n                  39 THROWIFNOT\n                  1852798053 PUSHINT\n                  0 PUSHINT\n                  4 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  3 STU\n                  s0 s6 XCHG2\n                  STSLICER\n                  s0 s4 XCHG2\n                  STGRAMS\n                  s1 s4 XCHG\n                  107 STU\n                  s1 s2 XCHG\n                  32 STU\n                  64 STU\n                  ENDC\n                  3 PUSHINT\n                  SENDRAWMSG\n                  s0 s2 XCHG\n            }>\n            SWAP\n            3 EQINT\n            IF:<{\n                  264 PUSHINT\n                  LDSLICEX\n                  LDGRAMS\n                  64 LDU\n                  DROP\n                  s2 s3 PUXC\n                  264 PUSHINT\n                  DICTDEL\n                  39 THROWIFNOT\n                  1685288050 PUSHINT\n                  0 PUSHINT\n                  4 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  3 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s0 s3 XCHG2\n                  STGRAMS\n                  s1 s3 XCHG\n                  107 STU\n                  32 STU\n                  s1 s2 XCHG\n                  64 STU\n                  ENDC\n                  3 PUSHINT\n                  SENDRAWMSG\n            }>ELSE<{\n                  DROP\n            }>\n            s0 s3 XCHG\n            INC\n            NEWC\n            32 STU\n            s1 s2 XCHG\n            32 STU\n            256 STU\n            STDICT\n            ENDC\n            c4 POP\n      }>\n      0 => <{\n            SWAP\n            CTOS\n            4 LDU\n            OVER\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  4 BLKDROP\n            }>\n            s2 PUSH\n            SBITS\n            32 LESSINT\n            IFJMP:<{\n                  4 BLKDROP\n            }>\n            s0 s2 XCHG\n            32 LDU\n            OVER\n            1886156135 PUSHINT\n            NEQ\n            s2 PUSH\n            1685288050 PUSHINT\n            NEQ\n            AND\n            IFJMP:<{\n                  5 BLKDROP\n            }>\n            s0 s3 XCHG\n            LDMSGADDR\n            DROP\n            DUP\n            REWRITESTDADDR\n            SWAP\n            NEWC\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            c4 PUSH\n            CTOS\n            320 PUSHINT\n            SDSKIPFIRST\n            LDDICT\n            DROP\n            2DUP\n            264 PUSHINT\n            DICTGET\n            NULLSWAPIFNOT\n            NIP\n            NOT\n            IFJMP:<{\n                  7 BLKDROP\n            }>\n            s0 s5 XCHG\n            64 LDU\n            NEWC\n            s5 PUSH\n            1886156135 PUSHINT\n            EQUAL\n            IF:<{\n                  SWAP\n                  LDGRAMS\n                  LDDICT\n                  DROP\n                  BALANCE\n                  2 UNTUPLE\n                  DROP\n                  s0 s10 XCHG2\n                  SUB\n                  OVER\n                  GEQ\n                  80 THROWIFNOT\n                  1886156135 PUSHINT\n                  31 PUSHPOW2\n                  OR\n                  0 PUSHINT\n                  24 PUSHINT\n                  s0 s4 XCHG2\n                  6 STU\n                  s6 PUSH\n                  STSLICER\n                  ROT\n                  STGRAMS\n                  s1 s9 XCHG\n                  STDICT\n                  106 STU\n                  s1 s7 XCHG\n                  32 STU\n                  s6 s(-1) PUXC\n                  64 STU\n                  DUP\n                  ENDC\n                  64 PUSHINT\n                  SENDRAWMSG\n                  s0 s6 XCHG\n            }>ELSE<{\n                  s8 POP\n                  DROP\n            }>\n            s0 s3 XCHG\n            1685288050 PUSHINT\n            EQUAL\n            IF:<{\n                  s0 s4 XCHG2\n                  264 PUSHINT\n                  DICTDEL\n                  DROP\n                  c4 PUSH\n                  CTOS\n                  320 PUSHINT\n                  SDCUTFIRST\n                  NEWC\n                  SWAP\n                  STSLICER\n                  STDICT\n                  ENDC\n                  c4 POP\n                  SWAP\n                  2 PUSHINT\n                  AND\n                  IF:<{\n                        1685288050 PUSHINT\n                        31 PUSHPOW2\n                        OR\n                        0 PUSHINT\n                        24 PUSHINT\n                        s0 s5 XCHG2\n                        6 STU\n                        s0 s3 XCHG2\n                        STSLICER\n                        s3 PUSH\n                        STGRAMS\n                        s1 s3 XCHG\n                        107 STU\n                        32 STU\n                        64 STU\n                        ENDC\n                        64 PUSHINT\n                        SENDRAWMSG\n                  }>ELSE<{\n                        3 BLKDROP\n                  }>\n            }>ELSE<{\n                  6 BLKDROP\n            }>\n      }>\n      76407 => <{\n            c4 PUSH\n            CTOS\n            320 PUSHINT\n            SDSKIPFIRST\n            LDDICT\n            DROP\n            s0 s2 XCHG\n            NEWC\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            SWAP\n            264 PUSHINT\n            DICTGET\n            NULLSWAPIFNOT\n            NIP\n      }>\n      78748 => <{\n            c4 PUSH\n            CTOS\n            64 PUSHINT\n            SDSKIPFIRST\n            256 PLDU\n      }>\n      81467 => <{\n            c4 PUSH\n            CTOS\n            32 PUSHINT\n            SDSKIPFIRST\n            32 PLDU\n      }>\n      85143 => <{\n            c4 PUSH\n            CTOS\n            32 PLDU\n      }>\n      107653 => <{\n            PUSHNULL\n            c4 PUSH\n            CTOS\n            320 PUSHINT\n            SDSKIPFIRST\n            LDDICT\n            DROP\n            UNTIL:<{\n                  264 PUSHINT\n                  DICTREMMIN\n                  NULLSWAPIFNOT2\n                  s2 POP\n                  OVER\n                  IF:<{\n                        8 LDI\n                        256 LDU\n                        DROP\n                        2 TUPLE\n                        s0 s3 XCHG2\n                        2 TUPLE\n                        s0 s2 XCHG\n                  }>ELSE<{\n                        DROP\n                  }>\n                  NOT\n            }>\n            DROP\n      }>\n}\n11 THROWARG",
  "code_hash": "feb5ff6820e2ff0d9483e7e0d62c817d846789fb4ae580c878866d959dabd5c0",
  "methods": [
    {
      "id": 85143,
      "method": "seqno"
    },
    {
      "id": 107653,
      "method": "get_plugin_list"
    },
    {
      "id": 76407,
      "method": "is_plugin_installed"
    },
    {
      "id": 78748,
      "method": "get_public_key"
    },
    {
      "id": 81467,
      "method": "get_subwallet_id"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "wallet-v4-code.fc",
        "content": "#pragma version =0.2.0;\n;; Wallet smart contract with plugins\n\n(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTGET\" \"NULLSWAPIFNOT\";\n(cell, int) dict_add_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTADDB\";\n(cell, int) dict_delete?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDEL\";\n\n() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {\n  var cs = in_msg_cell.begin_parse();\n  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n  if (flags & 1) {\n    ;; ignore all bounced messages\n    return ();\n  }\n  if (in_msg.slice_bits() < 32) {\n    ;; ignore simple transfers\n    return ();\n  }\n  int op = in_msg~load_uint(32);\n  if (op != 0x706c7567) & (op != 0x64737472) { ;; \"plug\" & \"dstr\"\n    ;; ignore all messages not related to plugins\n    return ();\n  }\n  slice s_addr = cs~load_msg_addr();\n  (int wc, int addr_hash) = parse_std_addr(s_addr);\n  slice wc_n_address = begin_cell().store_int(wc, 8).store_uint(addr_hash, 256).end_cell().begin_parse();\n  var ds = get_data().begin_parse().skip_bits(32 + 32 + 256);\n  var plugins = ds~load_dict();\n  var (_, success?) = plugins.dict_get?(8 + 256, wc_n_address);\n  if ~(success?) {\n    ;; it may be a transfer\n    return ();\n  }\n  int query_id = in_msg~load_uint(64);\n  var msg = begin_cell();\n  if (op == 0x706c7567) { ;; request funds\n\n    (int r_toncoins, cell r_extra) = (in_msg~load_grams(), in_msg~load_dict());\n\n    [int my_balance, _] = get_balance();\n    throw_unless(80, my_balance - msg_value >= r_toncoins);\n\n    msg = msg.store_uint(0x18, 6)\n             .store_slice(s_addr)\n             .store_grams(r_toncoins)\n             .store_dict(r_extra)\n             .store_uint(0, 4 + 4 + 64 + 32 + 1 + 1)\n             .store_uint(0x706c7567 | 0x80000000, 32)\n             .store_uint(query_id, 64);\n    send_raw_message(msg.end_cell(), 64);\n\n  }\n\n  if (op == 0x64737472) { ;; remove plugin by its request\n\n    plugins~dict_delete?(8 + 256, wc_n_address);\n    var ds = get_data().begin_parse().first_bits(32 + 32 + 256);\n    set_data(begin_cell().store_slice(ds).store_dict(plugins).end_cell());\n    ;; return coins only if bounce expected\n    if (flags & 2) {\n      msg = msg.store_uint(0x18, 6)\n               .store_slice(s_addr)\n               .store_grams(0)\n               .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n               .store_uint(0x64737472 | 0x80000000, 32)\n               .store_uint(query_id, 64);\n      send_raw_message(msg.end_cell(), 64);\n    }\n  }\n}\n\n() recv_external(slice in_msg) impure {\n  var signature = in_msg~load_bits(512);\n  var cs = in_msg;\n  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));\n  throw_if(36, valid_until <= now());\n  var ds = get_data().begin_parse();\n  var (stored_seqno, stored_subwallet, public_key, plugins) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256), ds~load_dict());\n  ds.end_parse();\n  throw_unless(33, msg_seqno == stored_seqno);\n  throw_unless(34, subwallet_id == stored_subwallet);\n  throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));\n  accept_message();\n  set_data(begin_cell()\n    .store_uint(stored_seqno + 1, 32)\n    .store_uint(stored_subwallet, 32)\n    .store_uint(public_key, 256)\n    .store_dict(plugins)\n    .end_cell());\n  commit();\n  cs~touch();\n  int op = cs~load_uint(8);\n\n  if (op == 0) { ;; simple send\n    while (cs.slice_refs()) {\n      var mode = cs~load_uint(8);\n      send_raw_message(cs~load_ref(), mode);\n    }\n    return (); ;; have already saved the storage\n  }\n\n  if (op == 1) { ;; deploy and install plugin\n    int plugin_workchain = cs~load_int(8);\n    int plugin_balance = cs~load_grams();\n    (cell state_init, cell body) = (cs~load_ref(), cs~load_ref());\n    int plugin_address = cell_hash(state_init);\n    slice wc_n_address = begin_cell().store_int(plugin_workchain, 8).store_uint(plugin_address, 256).end_cell().begin_parse();\n    var msg = begin_cell()\n      .store_uint(0x18, 6)\n      .store_uint(4, 3).store_slice(wc_n_address)\n      .store_grams(plugin_balance)\n      .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n      .store_ref(state_init)\n      .store_ref(body);\n    send_raw_message(msg.end_cell(), 3);\n    (plugins, int success?) = plugins.dict_add_builder?(8 + 256, wc_n_address, begin_cell());\n    throw_unless(39, success?);\n  }\n\n  if (op == 2) { ;; install plugin\n    slice wc_n_address = cs~load_bits(8 + 256);\n    int amount = cs~load_grams();\n    int query_id = cs~load_uint(64);\n\n    (plugins, int success?) = plugins.dict_add_builder?(8 + 256, wc_n_address, begin_cell());\n    throw_unless(39, success?);\n\n    builder msg = begin_cell()\n      .store_uint(0x18, 6)\n      .store_uint(4, 3).store_slice(wc_n_address)\n      .store_grams(amount)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(0x6e6f7465, 32) ;; op\n      .store_uint(query_id, 64);\n    send_raw_message(msg.end_cell(), 3);\n  }\n\n  if (op == 3) { ;; remove plugin\n    slice wc_n_address = cs~load_bits(8 + 256);\n    int amount = cs~load_grams();\n    int query_id = cs~load_uint(64);\n\n    (plugins, int success?) = plugins.dict_delete?(8 + 256, wc_n_address);\n    throw_unless(39, success?);\n\n    builder msg = begin_cell()\n      .store_uint(0x18, 6)\n      .store_uint(4, 3).store_slice(wc_n_address)\n      .store_grams(amount)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(0x64737472, 32) ;; op\n      .store_uint(query_id, 64);\n    send_raw_message(msg.end_cell(), 3);\n  }\n\n  set_data(begin_cell()\n    .store_uint(stored_seqno + 1, 32)\n    .store_uint(stored_subwallet, 32)\n    .store_uint(public_key, 256)\n    .store_dict(plugins)\n    .end_cell());\n}\n\n;; Get methods\n\nint seqno() method_id {\n  return get_data().begin_parse().preload_uint(32);\n}\n\nint get_subwallet_id() method_id {\n  return get_data().begin_parse().skip_bits(32).preload_uint(32);\n}\n\nint get_public_key() method_id {\n  var cs = get_data().begin_parse().skip_bits(64);\n  return cs.preload_uint(256);\n}\n\nint is_plugin_installed(int wc, int addr_hash) method_id {\n  var ds = get_data().begin_parse().skip_bits(32 + 32 + 256);\n  var plugins = ds~load_dict();\n  var (_, success?) = plugins.dict_get?(8 + 256, begin_cell().store_int(wc, 8).store_uint(addr_hash, 256).end_cell().begin_parse());\n  return success?;\n}\n\ntuple get_plugin_list() method_id {\n  var list = null();\n  var ds = get_data().begin_parse().skip_bits(32 + 32 + 256);\n  var plugins = ds~load_dict();\n  do {\n    var (wc_n_address, _, f) = plugins~dict::delete_get_min(8 + 256);\n    if (f) {\n      (int wc, int addr) = (wc_n_address~load_int(8), wc_n_address~load_uint(256));\n      list = cons(pair(wc, addr), list);\n    }\n  } until (~ f);\n  return list;\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}