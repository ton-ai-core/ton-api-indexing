{
  "code": "b5ee9c7201020e010002a3000114ff00f4a413f4bcf2c80b0102016202030202cc040502037a600c0d01f5d906380492f81f000e8698180b8d8492f81f07d207d2018fd0018b8eb90fd0018fd001839d4da0001698fe99ff6a2687d007d206a6a18400aa9385d47199a9a9b1b289a6382f97024817d207d006a18106840306b90fd001812881a282178048a502819e428027d012c678b666664f6aa7041083deecbef29385d4060093b3f0508806e0a84026a8280790a009f404b19e2c039e2d99924591960225e801e80196019241f200e0e9919605940f97ff93a0ef003191960ab19e2ca009f4042796d625999992e3f60104f48ee036373701fa00fa40f82854120670542013541403c85004fa0258cf1601cf16ccc922c8cb0112f400f400cb00c9f9007074c8cb02ca07cbffc9d05006c705f2e04aa1034545c85004fa0258cf16ccccc9ed5401fa403020d70b01c300915be30de082102c76b9735270bae30235373723c003e3023502c0040708090a003e8210d53276db708010c8cb055003cf1622fa0212cb6acb1fcb3fc98042fb0001fe365f03820898968015a015bcf2e04b02fa40d3003095c821cf16c9916de28210d1735400708018c8cb055005cf1624fa0214cb6a13cb1f14cb3f23fa443070ba8e33f828440370542013541403c85004fa0258cf1601cf16ccc922c8cb0112f400f400cb00c9f9007074c8cb02ca07cbffc9d0cf16966c227001cb01e2f4000b0034335035c705f2e04903fa403059c85004fa0258cf16ccccc9ed5400428e185124c705f2e049d4304300c85004fa0258cf16ccccc9ed54e05f05840ff2f0000ac98040fb00007dadbcf6a2687d007d206a6a183618fc1400b82a1009aa0a01e428027d012c678b00e78b666491646580897a007a00658064fc80383a6465816503e5ffe4e840001faf16f6a2687d007d206a6a183faa9040",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            DUP\n            SEMPTY\n            IFJMP:<{\n                  3 BLKDROP\n            }>\n            SWAP\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  3 BLKDROP\n            }>\n            LDMSGADDR\n            LDMSGADDR\n            NIP\n            LDGRAMS\n            NIP\n            1 PUSHINT\n            SDSKIPFIRST\n            LDGRAMS\n            NIP\n            LDGRAMS\n            DROP\n            3 PUSHINT\n            1 MULRSHIFT\n            s0 s2 XCHG\n            32 LDU\n            64 LDU\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            21 PUSHINT\n            s7 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s5 POP\n                  s5 POP\n                  s6 POP\n                  s6 POP\n                  s3 s4 XCPU\n                  SDEQ\n                  73 THROWIFNOT\n                  s0 s2 XCHG\n                  LDMSGADDR\n                  LDGRAMS\n                  LDREF\n                  DROP\n                  DUP\n                  CTOS\n                  96 PUSHINT\n                  SDSKIPFIRST\n                  LDGRAMS\n                  DROP\n                  s5 PUSH\n                  s3 s4 XCHG\n                  s4 s2 XCHG2\n                  9 CALLDICT\n                  s1 s4 XCHG\n                  ADD\n                  s3 s3 XCHG2\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            2078119902 PUSHINT\n            s7 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s6 POP\n                  s7 POP\n                  s7 POP\n                  SWAP\n                  LDGRAMS\n                  LDMSGADDR\n                  MYADDR\n                  s2 s0 s6 XC2PU\n                  0 PUSHINT\n                  s0 s1 s2 XCPUXC\n                  s4 s0 s3 XC2PU\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  STREF\n                  ENDC\n                  s2 PUSH\n                  NEWC\n                  2 STU\n                  s1 s2 XCHG\n                  STDICT\n                  STDICT\n                  1 STU\n                  ENDC\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  s0 s6 XCHG2\n                  SDEQ\n                  74 THROWIFNOT\n                  SUB\n                  s0 s3 XCHG\n                  s5 s4 s5 XCHG3\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  DUP\n                  2 PLDU\n                  0 NEQINT\n                  IF:<{\n                        3576854235 PUSHINT\n                        0 PUSHINT\n                        16 PUSHINT\n                        NEWC\n                        6 STU\n                        s0 s3 XCHG2\n                        STSLICER\n                        s2 PUSH\n                        STGRAMS\n                        s1 s2 XCHG\n                        107 STU\n                        32 STU\n                        64 STU\n                        ENDC\n                        66 PUSHINT\n                        SENDRAWMSG\n                  }>ELSE<{\n                        2DROP\n                  }>\n            }>\n            745978227 PUSHINT\n            s7 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s6 POP\n                  3 BLKDROP\n                  10000000 PUSHINT\n                  s1 s5 XCHG\n                  ADD\n                  s1 s5 XCHG\n                  GREATER\n                  75 THROWIFNOT\n                  s0 s2 XCHG\n                  LDMSGADDR\n                  1 LDU\n                  DROP\n                  IF:<{\n                        NEWC\n                        OVER\n                        STSLICER\n                        ENDC\n                  }>ELSE<{\n                        PUSHNULL\n                  }>\n                  3513996288 PUSHINT\n                  0 PUSHINT\n                  24 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s4 PUSH\n                  STGRAMS\n                  s1 s4 XCHG\n                  107 STU\n                  s1 s3 XCHG\n                  32 STU\n                  s1 s4 XCHG\n                  64 STU\n                  s3 PUSH\n                  REWRITESTDADDR\n                  DROP\n                  0 PUSHINT\n                  EQUAL\n                  IF:<{\n                        MYADDR\n                        s4 s0 s3 XCHG3\n                        0 PUSHINT\n                        s0 s1 s2 XCPUXC\n                        s4 s0 s3 XC2PU\n                        NEWC\n                        s0 s4 XCHG2\n                        STGRAMS\n                        ROT\n                        STSLICER\n                        SWAP\n                        STSLICER\n                        STREF\n                        ENDC\n                        s2 PUSH\n                        NEWC\n                        2 STU\n                        s1 s2 XCHG\n                        STDICT\n                        STDICT\n                        1 STU\n                        ENDC\n                        HASHCU\n                        0 PUSHINT\n                        4 PUSHINT\n                        NEWC\n                        3 STU\n                        8 STI\n                        256 STU\n                        ENDC\n                        CTOS\n                        STSLICER\n                  }>ELSE<{\n                        2 2 BLKDROP2\n                        0 PUSHINT\n                        SWAP\n                        2 STU\n                  }>\n                  STDICT\n                  ENDC\n                  64 PUSHINT\n                  SENDRAWMSG\n            }>\n            s5 POP\n            s7 POP\n            s7 POP\n            s3 PUSH\n            3 EQINT\n            IFJMP:<{\n                  s3 POP\n                  s3 s5 XCHG2\n                  SDEQ\n                  73 THROWIFNOT\n                  s0 s3 XCHG\n                  LDMSGADDR\n                  DROP\n                  ROTREV\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            s5 POP\n            s0 s2 XCHG\n            4 EQINT\n            IFJMP:<{\n                  s2 s4 XCPU\n                  SDEQ\n                  73 THROWIFNOT\n                  LDREF\n                  DROP\n                  s3 s0 s0 XCHG3\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            5 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      9 => <{\n            MYADDR\n            s4 s0 s3 XCHG3\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            DUP\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            ROT\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s3 XCHG\n            108 STU\n            s1 s2 XCHG\n            STREF\n            STREF\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n      }>\n      103289 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            3 1 BLKDROP2\n            MYADDR\n            SWAP\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n      }>\n      106029 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            -1 PUSHINT\n            3 1 BLKSWAP\n      }>\n}\n11 THROWARG",
  "code_hash": "0571976c63ec1b7550230a2609dbedb36e1b64ef8d022a16b34ea57063185b2f",
  "methods": [
    {
      "id": 103289,
      "method": "get_wallet_address"
    },
    {
      "id": 106029,
      "method": "get_jetton_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "jetton-utils/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "jetton-utils/discovery-params.fc",
        "content": ";; moved to the separate file to keep hex of the previous codes unchanged\n\nint op::provide_wallet_address() asm \"0x2c76b973 PUSHINT\";\nint op::take_wallet_address() asm \"0xd1735400 PUSHINT\";\n\nint is_resolvable?(slice addr) inline {\n    (int wc, _) = parse_std_addr(addr);\n\n    return wc == workchain();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "jetton-utils/utils.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n    (int wc, _) = parse_std_addr(addr);\n    throw_unless(333, wc == workchain());\n}\n\ncell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return  begin_cell()\n        .store_coins(balance)\n        .store_slice(owner_address)\n        .store_slice(jetton_master_address)\n        .store_ref(jetton_wallet_code)\n    .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return begin_cell()\n        .store_uint(0, 2)\n        .store_dict(jetton_wallet_code)\n        .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\n        .store_uint(0, 1)\n    .end_cell();\n}\n\nslice calculate_jetton_wallet_address(cell state_init) inline {\n    return begin_cell().store_uint(4, 3)\n        .store_int(workchain(), 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "jetton_minter_discoverable.fc",
        "content": ";; Jettons discoverable smart contract\n#include \"jetton-utils/stdlib.fc\";\n#include \"jetton-utils/op.fc\";\n#include \"jetton-utils/utils.fc\";\n#include \"jetton-utils/discovery-params.fc\";\n\n;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000\n;; ceil(6905000) = 10000000 ~= 0.01 TON\nint provide_address_gas_consumption() asm \"10000000 PUSHINT\";\n\n;; storage scheme\n;; storage#_ total_supply:Coins admin_address:MsgAddress content:^Cell jetton_wallet_code:^Cell = Storage;\n\n(int, slice, cell, cell) load_data() inline {\n    slice ds = get_data().begin_parse();\n    return (\n        ds~load_coins(), ;; total_supply\n        ds~load_msg_addr(), ;; admin_address\n        ds~load_ref(), ;; content\n        ds~load_ref() ;; jetton_wallet_code\n    );\n}\n\n() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {\n    set_data(begin_cell()\n        .store_coins(total_supply)\n        .store_slice(admin_address)\n        .store_ref(content)\n        .store_ref(jetton_wallet_code)\n        .end_cell());\n}\n\n() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {\n    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);\n    slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n    var msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(to_wallet_address)\n        .store_coins(amount)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init)\n        .store_ref(master_msg);\n    send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n    cs~load_msg_addr(); ;; skip dst\n    cs~load_coins(); ;; skip value\n    cs~skip_bits(1); ;; skip extracurrency collection\n    cs~load_coins(); ;; skip ihr_fee\n    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\n\n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n\n    if (op == op::mint()) {\n        throw_unless(73, equal_slices(sender_address, admin_address));\n\n        slice to_address = in_msg_body~load_msg_addr();\n        int amount = in_msg_body~load_coins();\n\n        cell master_msg = in_msg_body~load_ref();\n        slice master_msg_cs = master_msg.begin_parse();\n        master_msg_cs~skip_bits(32 + 64); ;; op + query_id\n        int jetton_amount = master_msg_cs~load_coins();\n\n        mint_tokens(to_address, jetton_wallet_code, amount, master_msg);\n        save_data(total_supply + jetton_amount, admin_address, content, jetton_wallet_code);\n        return ();\n    }\n\n    if (op == op::burn_notification()) {\n        int jetton_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n\n        throw_unless(74,\n            equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address)\n        );\n\n        save_data(total_supply - jetton_amount, admin_address, content, jetton_wallet_code);\n        slice response_address = in_msg_body~load_msg_addr();\n\n        if (response_address.preload_uint(2) != 0) {\n            var msg = begin_cell()\n                .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n                .store_slice(response_address)\n                .store_coins(0)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_uint(op::excesses(), 32)\n                .store_uint(query_id, 64);\n            send_raw_message(msg.end_cell(), 2 + 64);\n        }\n\n        return ();\n    }\n\n    if (op == op::provide_wallet_address()) {\n        throw_unless(75, msg_value > fwd_fee + provide_address_gas_consumption());\n\n        slice owner_address = in_msg_body~load_msg_addr();\n        int include_address? = in_msg_body~load_uint(1);\n\n        cell included_address = include_address?\n                ? begin_cell().store_slice(owner_address).end_cell()\n                : null();\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(sender_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::take_wallet_address(), 32)\n            .store_uint(query_id, 64);\n\n        if (is_resolvable?(owner_address)) {\n            msg = msg.store_slice(calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code));\n        } else {\n            msg = msg.store_uint(0, 2); ;; addr_none\n        }\n\n        send_raw_message(msg.store_maybe_ref(included_address).end_cell(), 64);\n        return ();\n    }\n\n    if (op == 3) { ;; change admin\n        throw_unless(73, equal_slices(sender_address, admin_address));\n        slice new_admin_address = in_msg_body~load_msg_addr();\n        save_data(total_supply, new_admin_address, content, jetton_wallet_code);\n        return ();\n    }\n\n    if (op == 4) { ;; change content, delete this for immutable tokens\n        throw_unless(73, equal_slices(sender_address, admin_address));\n        save_data(total_supply, admin_address, in_msg_body~load_ref(), jetton_wallet_code);\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, int, slice, cell, cell) get_jetton_data() method_id {\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n    return (total_supply, -1, admin_address, content, jetton_wallet_code);\n}\n\nslice get_wallet_address(slice owner_address) method_id {\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/op-codes.fc",
        "content": "int op::transfer() asm \"0xf8a7ea5 PUSHINT\";\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\nint op::internal_transfer() asm \"0x178d4519 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::burn() asm \"0x595f07bc PUSHINT\";\nint op::burn_notification() asm \"0x7bdd97de PUSHINT\";\n\n;; Minter\nint op::mint() asm \"21 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}