{
  "code": "b5ee9c7201022a010006a5000114ff00f4a413f4bcf2c80b0102016202030202cc0405020120202102012006070201481a1b020120080902015818190201200a0b000d470c8cb01c9d0801f73e09dbc400b434c0c05c6c2497c1383e903e900c7e800c5c75c87e800c7e800c3c0289ece39497c15b088d148cb1c17cb865407e90350c1b5c3232c1fd00327e08e08418b93cc428608209e3402a4108308324cc200337a082024ea02082024b1c162a20032a41287e08c0683c00911dfc02440d7e08fc02f814d6600c00113e910c1c2ebcb8536004fac70518b08e34109b5f0bfa40307020f8256d8040708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00e029c70091709509d31f50aae221f008f82321bc24c0008e9e343a3a3b8e1636363737375135c705f2e196102510241023f823f00be30ee0310dd33f256eb31fb0e30f0d0e0f1001fc302680698064a98452b0bef2e19782103b9aca0052a0a15270bc993682103b9aca0019a193390805e220c2008e328210557cea20f82510396d71708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00923036e2810e1023f823a1a120c2009313a0029130e24474f0091024f8231100d2343653cda182103b9aca005210a15270bc993682103b9aca0016a1923005e220c2008e378210370fec516d72295134544743708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb001ca10b9130e26d5477655477632ef00b0200046c2104c882105fcc3d145220ba8e9531373b5372c705f2e191109a104910384706401504e082101a0b9d515220ba8e195b32353537375135c705f2e19a03d4304015045033f823f00be02182104eb1f0f9bae3023b20821044beae41bae302382782104ed14b65ba151213140004f00b00885b363638385147c705f2e19b04d3ff20d74ac20007d0d30701c000f2e19cf404300798d43040168307f417983050058307f45b30e270c8cb07f400c910354014f823f00b01fe30363a246ef2e19d8050f833d0f4043052408307f40e6fa1f2e19fd30721c00022c001b1f2e1a021c0008e9124109b1068517a10571046105c43144cdd9630103a395f07e201c0018e32708210370fec51586d8100a0708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00915be21501a2e3025f0432353582102fcb26a2ba8e3a7082108b77173504c8cbff5005cf161443308040708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00e05f04840ff2f01701f03502fa4021f001fa40d20031fa0082103b9aca001da121945314a0a1de22d70b01c300209205a19135e220c2fff2e192218e3e821005138d91c8500bcf16500dcf1671244b145448c0708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb00106994102c395be20116008a8e3528f0018210d53276db103946096d71708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb0093383430e21045103412f823f00b00fc37f8235006a18209e28500bc066e16b0f2e19e23d0d749f823f0075290bef2e1975178a182103b9aca00a120c2008e32102782104ed14b6558076d72708010c8cb055007cf165005fa0215cb6a12cb1fcb3f226eb39458cf17019132e201c901fb0093303535e2f8238208093a80a0f0024477f0091045103412f823f00b0093083001258c2040fa201938083001658c20407d200cb8083001a58c204064200a38083001e58c20404b2007b8083002258c204032200538083002650c20191eb83002a4e00c9d781e9c600069006ac0bc018060840ee6b2802a0060840ee6b2802a00a08418b93cc428608209e3402a410830856456f81b04a5a9d6a0192a4139200201201c1d0201201e1f0021081ba50c1b5c0838343e903e8034cfcc200017321400f3c5807e80b2cff26000513b513434fffe900835d2708027dfc07e9035353d0134cfcc0415c415b80c1c1b5b5b5b490415c415a0002b01b232ffd40173c59400f3c5b3333d0032cff27b5520020120222302012026270013bbb39f00a175f07f008802027424250010a874f00a10475f07000ca959f00a6c71000db8fcff00a5f03802012028290013b64a5e014204ebe0fa1000c7b461843ae9240f152118001e5c08de014206ebe0fa1a60e038001e5c339e8086007ae140f8001e5c33b84111c466105e033e04883dcb11fb64ddc4964ad1ba06b879240dc23572f37cc5caaab143a2fffbc4180012660f003c003060fe81edf4260f0030",
  "code_hash": "8b5ffc9ebfd39064d8d5f56e4659c826bb7593923f5ca48728be4d60af6f51f9",
  "methods": [
    {
      "id": 102351,
      "method": "get_nft_data"
    },
    {
      "id": 119378,
      "method": "get_domain"
    },
    {
      "id": 90228,
      "method": "get_editor"
    },
    {
      "id": 123660,
      "method": "dnsresolve"
    },
    {
      "id": 80697,
      "method": "get_auction_info"
    },
    {
      "id": 91481,
      "method": "get_last_fill_up_time"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == workchain());\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "dns-utils.fc",
        "content": "const int one_month = 2592000; ;; 1 month in seconds = 60 * 60 * 24 * 30\nconst int one_year = 31622400; ;; 1 year in seconds = 60 * 60 * 24 * 366\nconst int auction_start_time = 1659171600; ;; GMT: Monday, 30 July 2022 Ð³., 09:00:00\nconst int one_ton = 1000000000;\nconst int dns_next_resolver_prefix = 0xba93; ;; dns_next_resolver prefix - https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L819\n\nconst int dns_config_id = 80; ;; dns black list config param; in testnet -80\n\nconst int op::fill_up = 0x370fec51;\nconst int op::outbid_notification = 0x557cea20;\nconst int op::change_dns_record = 0x4eb1f0f9;\nconst int op::process_governance_decision = 0x44beae41;\nconst int op::dns_balance_release = 0x4ed14b65;\n\nint mod(int x, int y) asm \"MOD\";\n\nslice zero_address() {\n    return begin_cell().store_uint(0, 2).end_cell().begin_parse();\n}\n\n;; \"ton\\0test\\0\" -> \"ton\"\nint get_top_domain_bits(slice domain) {\n    int i = 0;\n    int need_break = 0;\n    do {\n        int char = domain~load_uint(8); ;; we do not check domain.length because it MUST contains \\0 character\n        need_break = char == 0;\n        if (~ need_break) {\n            i += 8;\n        }\n    } until (need_break);\n    throw_if(201, i == 0); ;; starts with \\0\n    return i;\n}\n\nslice read_domain_from_comment(slice in_msg_body) {\n    int need_break = 0;\n    builder result = begin_cell();\n    do {\n        result = result.store_slice(in_msg_body~load_bits(in_msg_body.slice_bits()));\n        int refs_len = in_msg_body.slice_refs();\n        need_break = refs_len == 0;\n        if (~ need_break) {\n            throw_unless(202, refs_len == 1);\n            in_msg_body = in_msg_body~load_ref().begin_parse();\n        }\n    } until (need_break);\n    return result.end_cell().begin_parse();\n}\n\nint check_domain_string(slice domain) {\n    int i = 0;\n    int len = slice_bits(domain);\n    int need_break = 0;\n    do {\n        need_break = i == len;\n        if (~ need_break) {\n            int char = domain~load_uint(8);\n            ;; we can do it because additional UTF-8 character's octets >= 128 -- https://www.ietf.org/rfc/rfc3629.txt\n            int is_hyphen = (char == 45);\n            int valid_char = (is_hyphen & (i > 0) & (i < len - 8)) | ((char >= 48) & (char <= 57)) | ((char >= 97) & (char <= 122)); ;; '-' or 0-9 or a-z\n\n            need_break = ~ valid_char;\n            if (~ need_break) {\n                i += 8;\n            }\n        }\n    } until (need_break);\n    return i == len;\n}\n\n(int, int) get_min_price_config(int domain_char_count) {\n    if (domain_char_count == 4) {\n        return (1000, 100);\n    }\n    if (domain_char_count == 5) {\n        return (500, 50);\n    }\n    if (domain_char_count == 6) {\n        return (400, 40);\n    }\n    if (domain_char_count == 7) {\n        return (300, 30);\n    }\n    if (domain_char_count == 8) {\n        return (200, 20);\n    }\n    if (domain_char_count == 9) {\n        return (100, 10);\n    }\n    if (domain_char_count == 10) {\n        return (50, 5);\n    }\n    return (10, 1);\n}\n\nint get_min_price(int domain_bits_length, int now_time) {\n    (int start_min_price, int end_min_price) = get_min_price_config(domain_bits_length / 8);\n    start_min_price *= one_ton;\n    end_min_price *= one_ton;\n    int seconds = now_time - auction_start_time;\n    int months = seconds / one_month;\n    if (months > 21) {\n        return end_min_price;\n    }\n    repeat (months) {\n        start_min_price = start_min_price * 90 / 100;\n    }\n    return start_min_price;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "nft-item.fc",
        "content": ";; Domain smart contract (implement NFT item interface)\n\nint min_tons_for_storage() asm \"1000000000 PUSHINT\"; ;; 1 TON\n\nconst auction_start_duration = 604800; ;; 1 week = 60 * 60 * 24 * 7; in testnet 5 min\nconst auction_end_duration = 3600; ;; 1 hour = 60 * 60; in testnet 1 min\nconst auction_prolongation = 3600; ;; 1 hour = 60 * 60; in testnet 1 min\n\n;;  MsgAddressInt max_bid_address\n;;  Coins max_bid_amount\n;;  int auction_end_time\n(slice, int, int) unpack_auction(cell auction) {\n    if (cell_null?(auction)) {\n        return (null(), 0, 0);\n    } else {\n        slice ds = auction.begin_parse();\n        return (ds~load_msg_addr(), ds~load_coins(), ds~load_uint(64));\n    }\n}\n\ncell pack_auction(slice max_bid_address, int max_bid_amount, int auction_end_time) {\n    return begin_cell()\n            .store_slice(max_bid_address)\n            .store_coins(max_bid_amount)\n            .store_uint(auction_end_time, 64)\n            .end_cell();\n}\n\n;;\n;;  Storage\n;;\n;;  uint256 index\n;;  MsgAddressInt collection_address\n;;  MsgAddressInt owner_address\n;;  cell content\n;;  cell domain - e.g contains \"alice\" (without ending \\0) for \"alice.ton\" domain\n;;  cell auction - auction info\n;;  int last_fill_up_time\n\n(int, int, slice, slice, cell, cell, cell, int) load_data() {\n    slice ds = get_data().begin_parse();\n    var (index, collection_address) = (ds~load_uint(256), ds~load_msg_addr());\n    if (ds.slice_bits() > 0) {\n        return (-1, index, collection_address, ds~load_msg_addr(), ds~load_ref(), ds~load_ref(), ds~load_dict(), ds~load_uint(64));\n    } else {\n        return (0, index, collection_address, null(), null(), null(), null(), 0); ;; nft not initialized yet\n    }\n}\n\n() store_data(int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) impure {\n    set_data(\n            begin_cell()\n                    .store_uint(index, 256)\n                    .store_slice(collection_address)\n                    .store_slice(owner_address)\n                    .store_ref(content)\n                    .store_ref(domain)\n                    .store_dict(auction)\n                    .store_uint(last_fill_up_time, 64)\n                    .end_cell()\n    );\n}\n\n() send_msg(slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {\n    var msg = begin_cell()\n            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000\n            .store_slice(to_address)\n            .store_coins(amount)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op, 32)\n            .store_uint(query_id, 64);\n\n    if (~ builder_null?(payload)) {\n        msg = msg.store_builder(payload);\n    }\n\n    send_raw_message(msg.end_cell(), send_mode);\n}\n\n() transfer_ownership(int my_balance, int index, slice collection_address, slice owner_address, cell content, slice sender_address, int query_id, slice in_msg_body, int fwd_fees, cell domain, cell auction) impure inline {\n    slice new_owner_address = in_msg_body~load_msg_addr();\n    force_chain(new_owner_address);\n    slice response_destination = in_msg_body~load_msg_addr();\n    in_msg_body~load_int(1); ;; this nft don't use custom_payload\n    int forward_amount = in_msg_body~load_coins();\n\n    int rest_amount = my_balance - min_tons_for_storage();\n    if (forward_amount) {\n        rest_amount -= (forward_amount + fwd_fees);\n    }\n    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00\n    if (need_response) {\n        rest_amount -= fwd_fees;\n    }\n\n    throw_unless(402, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response\n\n    if (forward_amount) {\n        send_msg(new_owner_address, forward_amount, op::ownership_assigned(), query_id, begin_cell().store_slice(owner_address).store_slice(in_msg_body), 1); ;; paying fees, revert on errors\n    }\n    if (need_response) {\n        force_chain(response_destination);\n        send_msg(response_destination, rest_amount, op::excesses(), query_id, null(), 1); ;; paying fees, revert on errors\n    }\n\n    store_data(index, collection_address, new_owner_address, content, domain, auction, now());\n}\n\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    int my_balance = pair_first(get_balance());\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n\n    cs~load_msg_addr(); ;; skip dst\n    cs~load_coins(); ;; skip value\n    cs~skip_bits(1); ;; skip extracurrency collection\n    cs~load_coins(); ;; skip ihr_fee\n    int fwd_fee = cs~load_coins(); ;; we use message fwd_fee for estimation of forward_payload costs\n\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    if (~ init?) {\n        throw_unless(405, equal_slices(collection_address, sender_address));\n        slice from_address = in_msg_body~load_msg_addr();\n        cell domain = in_msg_body~load_ref();\n\n        cell content = begin_cell().store_uint(0, 8).store_dict(new_dict()).end_cell();\n\n        int seconds = now() - auction_start_time;\n        int months = seconds / one_month;\n        if (months > 12) {\n            months = 12;\n        }\n        int duration = auction_start_duration - (auction_start_duration - auction_end_duration) * months / 12;\n\n        int auction_end_time = now() + duration;\n        store_data(index, collection_address, zero_address(), content, domain, pack_auction(from_address, msg_value, auction_end_time), now());\n        return ();\n    }\n\n    if (init? & equal_slices(collection_address, sender_address)) {\n        slice from_address = in_msg_body~load_msg_addr();\n        send_msg(from_address, 0, 0, cur_lt(), null(), 64); ;; carry all the remaining value of the inbound message\n        return ();\n    }\n\n    int op = in_msg_body.slice_empty?() ? 0 : in_msg_body~load_uint(32);\n\n    (slice max_bid_address, int max_bid_amount, int auction_end_time) = unpack_auction(auction);\n\n    int auction_complete = now() > auction_end_time;\n\n    if (op == 0) {\n        if (auction_complete) {\n            throw_unless(406, equal_slices(sender_address, owner_address)); ;; only owner can fill-up balance, prevent coins lost right after the auction\n            ;; if owner send bid right after auction he can restore it by transfer resonse message\n            store_data(index, collection_address, owner_address, content, domain, auction, now());\n        } else {\n            throw_unless(407, msg_value >= muldiv(max_bid_amount, 105, 100)); ;; 5% greater then previous bid\n            int amount_to_send = (max_bid_amount > my_balance - min_tons_for_storage()) ? (my_balance - min_tons_for_storage()) : max_bid_amount;\n            if (amount_to_send > 0) {\n                send_msg(max_bid_address, amount_to_send, op::outbid_notification, cur_lt(), null(), 1); ;; pay transfer fees separately\n            }\n            max_bid_amount = msg_value;\n            max_bid_address = sender_address;\n            int delta_time = auction_prolongation - (auction_end_time - now());\n            if (delta_time > 0) {\n                auction_end_time += delta_time;\n            }\n            store_data(index, collection_address, owner_address, content, domain, pack_auction(max_bid_address, max_bid_amount, auction_end_time), now());\n        }\n\n        return ();\n    }\n\n    int query_id = in_msg_body~load_uint(64);\n\n    if ((auction_complete) & (~ cell_null?(auction))) { ;; take domain after auction\n        int balance_without_msg = my_balance - msg_value;\n        int amount_to_send = (max_bid_amount > balance_without_msg - min_tons_for_storage()) ? (balance_without_msg - min_tons_for_storage()) : max_bid_amount;\n        if (amount_to_send > 0) {\n            send_msg(collection_address, amount_to_send, op::fill_up, query_id, null(), 2); ;; ignore errors\n            my_balance -= amount_to_send;\n        }\n        owner_address = max_bid_address;\n        auction = null();\n        store_data(index, collection_address, owner_address, content, domain, auction, last_fill_up_time);\n    }\n\n    if (op == op::transfer()) {\n        throw_unless(401, equal_slices(sender_address, owner_address));\n        transfer_ownership(my_balance, index, collection_address, owner_address, content, sender_address, query_id, in_msg_body, fwd_fee, domain, auction);\n        return ();\n    }\n    if (op == op::edit_content()) { ;; owner can change content and dns records\n        throw_unless(410, equal_slices(sender_address, owner_address));\n        store_data(index, collection_address, owner_address, in_msg_body~load_ref(), domain, auction, now());\n        return ();\n    }\n    if (op == op::change_dns_record) { ;; change dns record\n        throw_unless(411, equal_slices(sender_address, owner_address));\n        int key = in_msg_body~load_uint(256);\n        int has_value = in_msg_body.slice_refs() > 0;\n\n        slice cs = content.begin_parse();\n        throw_unless(412, cs~load_uint(8) == 0); ;; data onchain tag\n        cell keyvalue_map = cs~load_dict();\n\n        if (has_value) {\n            cell value = in_msg_body~load_ref();\n\n            keyvalue_map~udict_set_ref(256, key, value);\n        } else {\n            keyvalue_map~udict_delete?(256, key);\n        }\n\n        content = begin_cell().store_uint(0, 8).store_dict(keyvalue_map).end_cell();\n\n        store_data(index, collection_address, owner_address, content, domain, auction, now());\n        return ();\n    }\n    if (op == op::process_governance_decision) { ;; governance\n        throw_unless(413, cell_null?(auction));\n        slice cs = config_param(dns_config_id).begin_parse();\n        cell config = cs~load_dict();\n        (slice config_value, int found) = config.udict_get?(256, index);\n        throw_unless(415, found);\n        int config_op = config_value~load_uint(8);\n        throw_unless(416, (config_op == 0) | (config_op == 1));\n        if (config_op == 0) { ;; transfer\n            transfer_ownership(my_balance, index, collection_address, owner_address, content, sender_address, query_id, config_value, fwd_fee, domain, auction);\n        }\n        if (config_op == 1) { ;; destroy\n            send_msg(collection_address, 0, op::fill_up, query_id, null(), 128 + 32); ;; carry all the remaining balance + destroy\n        }\n        return ();\n    }\n    if (op == op::dns_balance_release) { ;; release domain\n        throw_unless(414, (now() - last_fill_up_time > one_year) & (cell_null?(auction)));\n        int min_price = get_min_price(domain.begin_parse().slice_bits(), now());\n        throw_unless(407, msg_value >= min_price);\n        int balance_without_msg = my_balance - msg_value;\n        int amount_to_send = balance_without_msg - min_tons_for_storage();\n        if (amount_to_send > 0) {\n            send_msg(owner_address, amount_to_send, op::dns_balance_release, query_id, null(), 2); ;; ignore errors\n        }\n        max_bid_amount = msg_value;\n        max_bid_address = sender_address;\n        auction_end_time = now() + auction_start_duration; ;; always 1 week\n        owner_address = zero_address();\n        auction = pack_auction(max_bid_address, max_bid_amount, auction_end_time);\n        store_data(index, collection_address, owner_address, content, domain, auction, now());\n        return ();\n    }\n    if (op == op::get_static_data()) {\n        send_msg(sender_address, 0, op::report_static_data(), query_id, begin_cell().store_uint(index, 256).store_slice(collection_address), 64); ;; carry all the remaining value of the inbound message\n        return ();\n    }\n    throw(0xffff);\n}\n\n;;\n;;  GET Methods\n;;\n\n(int, int, slice, slice, cell) get_nft_data() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    return (init?, index, collection_address, owner_address, content);\n}\n\nslice get_editor() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    return owner_address;\n}\n\nslice get_domain() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    return domain.begin_parse();\n}\n\n(slice, int, int) get_auction_info() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    return unpack_auction(auction);\n}\n\nint get_last_fill_up_time() method_id {\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell domain, cell auction, int last_fill_up_time) = load_data();\n    return last_fill_up_time;\n}\n\n(int, cell) dnsresolve(slice subdomain, int category) method_id {\n    int subdomain_bits = slice_bits(subdomain);\n\n    throw_unless(70, mod(subdomain_bits, 8) == 0);\n\n    (int init?, int index, slice collection_address, slice owner_address, cell content, cell my_domain_cell, cell auction, int last_fill_up_time) = load_data();\n\n    slice cs = content.begin_parse();\n    throw_unless(412, cs~load_uint(8) == 0); ;; data onchain tag\n    cell keyvalue_map = cs~load_dict();\n\n    int starts_with_zero_byte = subdomain.preload_int(8) == 0;\n    throw_unless(413, starts_with_zero_byte);\n\n    if (subdomain_bits > 8) { ;; more than \".\" requested\n        category = \"dns_next_resolver\"H;\n    }\n\n    if (category == 0) { ;;  all categories are requested\n        return (8, keyvalue_map);\n    }\n\n    (cell value, int found) = keyvalue_map.udict_get_ref?(256, category);\n    return (8, value);\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}