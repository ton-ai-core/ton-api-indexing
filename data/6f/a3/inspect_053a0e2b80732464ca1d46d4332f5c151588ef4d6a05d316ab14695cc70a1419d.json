{
  "code": "b5ee9c7201020f01000393000114ff00f4a413f4bcf2c80b0102016202030202cd04050201200d0e02f7d00e8698180b8d8492f82707d201876a2686980698ffd207d207d207d006a698fe99f9818382985638060004a9885698f85ef10e1804a1805699fc708c5b31b0b731b2b64166382c939996f2805f115e000c92f877012eba4e10116408115dd15e0009159d8d829e4e382d87181156000f968ca164108363610405d4060701d166084017d7840149828148c2fbcb87089343e903e803e903e800c14e4a848685421e845a814a4087e9116dc20043232c15400f3c5807e80b2dab25c7ec00970800975d27080ac2386d411487e9116dc20043232c15400f3c5807e80b2dab25c7ec00408e48d0d3896a0c006430316cb2d430d0d307218020b0f2d19522c3008e14810258f8235341a1bc04f82302a0b913b0f2d1969132e201d43001fb0004f053c7c705b08e5d135f03323737373704fa00fa00fa00305321a121a1c101f2d19805d0fa40fa00fa40fa003030c83202cf1658fa0201cf165004fa02c97020104810371045103408c8cb0017cb1f5005cf165003cf1601cf1601fa02cccb1fcb3fc9ed54e0b3e30230313728c003e30228c000e30208c00208090a0b0086353b3b5374c705925f0be05173c705f2e1f4821005138d9118baf2e1f5fa403010481037553208c8cb0017cb1f5005cf165003cf1601cf1601fa02cccb1fcb3fc9ed5400e23839821005f5e10018bef2e1c95346c7055152c70515b1f2e1ca702082105fcc3d14218010c8cb0528cf1621fa02cb6acb1f15cb3f27cf1627cf1614ca0023fa0213ca00c98306fb0071705417005e331034102308c8cb0017cb1f5005cf165003cf1601cf1601fa02cccb1fcb3fc9ed54001836371038476514433070f005002098554410241023f005e05f0a840ff2f000ec21fa445b708010c8cb055003cf1601fa02cb6ac971fb00702082105fcc3d14c8cb1f5230cb3f24cf165004cf1613ca008209c9c380fa0212ca00c9718018c8cb0527cf1670fa02cb6acc25fa445bc98306fb00715560f8230108c8cb0017cb1f5005cf165003cf1601cf1601fa02cccb1fcb3fc9ed540087bce1676a2686980698ffd207d207d207d006a698fe99f982de87d207d007d207d001829a15090d0e080f968cc93fd222d937d222d91fd222dc1082324ac28056000aac040081bee5ef6a2686980698ffd207d207d207d006a698fe99f9801687d207d007d207d001829b15090d0e080f968cd14fd222d947d222d91fd222d85e00085881aaa894",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            SWAP\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  4 BLKDROP\n            }>\n            LDMSGADDR\n            DROP\n            c4 PUSH\n            CTOS\n            1 LDU\n            32 LDU\n            LDMSGADDR\n            LDMSGADDR\n            LDMSGADDR\n            LDGRAMS\n            LDREF\n            32 LDU\n            64 LDU\n            DROP\n            DROP\n            0 PUSHINT\n            s0 s10 PUSH2\n            SEMPTY\n            0 EQINT\n            IF:<{\n                  NIP\n                  s0 s10 XCHG\n                  32 LDU\n                  s0 s11 XCHG\n            }>\n            OVER\n            0 NEQINT\n            IF:<{\n                  DROP\n                  s0 s10 XCHG\n                  64 LDU\n            }>ELSE<{\n                  x{63616E63656C} PUSHSLICE\n                  s12 PUSH\n                  SDEQ\n                  IF:<{\n                        3 PUSHINT\n                        s2 POP\n                  }>\n                  s0 s11 XCHG2\n            }>\n            s11 PUSH\n            1 EQINT\n            IFJMP:<{\n                  14 BLKDROP\n            }>\n            s5 PUSH\n            SBITS\n            2 GTINT\n            s12 PUSH\n            555 PUSHINT\n            EQUAL\n            s11 PUSH\n            1 EQINT\n            s2 PUSH\n            NOT\n            OR\n            AND\n            s12 s9 PUSH2\n            SDEQ\n            AND\n            IFJMP:<{\n                  DROP\n                  NIP\n                  11 2 BLKDROP2\n                  LDREF\n                  DROP\n                  CTOS\n                  8 LDU\n                  OVER\n                  32 PUSHINT\n                  AND\n                  405 THROWIF\n                  s2 PUSH\n                  0 NEQINT\n                  IF:<{\n                        600 PUSHINT\n                        NOW\n                        s4 s1 PUSH2\n                        SUB\n                        GREATER\n                        s0 s4 XCHG\n                        NOW\n                        s0 s2 XCHG\n                        ADD\n                        LESS\n                        s1 s3 XCHG\n                        AND\n                        406 THROWIF\n                  }>ELSE<{\n                        s2 POP\n                  }>\n                  SWAP\n                  LDREF\n                  DROP\n                  SWAP\n                  SENDRAWMSG\n            }>\n            s10 PUSH\n            1 EQINT\n            404 THROWIF\n            s12 PUSH\n            1819025536 PUSHINT\n            EQUAL\n            s12 s7 PUSH2\n            SDEQ\n            AND\n            IFJMP:<{\n                  s1 s3 XCHG\n                  3 BLKDROP\n                  s2 POP\n                  s7 POP\n                  s7 POP\n                  s7 POP\n                  s7 POP\n                  s0 s4 XCHG\n                  LDGRAMS\n                  LDGRAMS\n                  LDGRAMS\n                  DROP\n                  s2 s1 PUSH2\n                  SUB\n                  OVER\n                  SUB\n                  1 LESSINT\n                  408 THROWIF\n                  s0 s5 XCHG\n                  CTOS\n                  LDMSGADDR\n                  LDGRAMS\n                  LDMSGADDR\n                  LDGRAMS\n                  DROP\n                  DROP\n                  NEWC\n                  s2 POP\n                  s0 s2 XCHG\n                  STSLICER\n                  ROT\n                  STGRAMS\n                  SWAP\n                  STSLICER\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ENDC\n                  0 PUSHINT\n                  DUP\n                  s4 s8 XCHG\n                  s3 s7 XCHG\n                  s4 s5 XCHG\n                  s3 s4 XCHG\n                  s0 s8 XCHG\n                  NEWC\n                  1 STU\n                  s1 s7 XCHG\n                  32 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s0 s3 XCHG2\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STGRAMS\n                  STREF\n                  32 STU\n                  64 STU\n                  ENDC\n                  c4 POP\n            }>\n            NOT\n            IFJMP:<{\n                  s5 POP\n                  s11 POP\n                  s11 POP\n                  s7 s4 PUSH2\n                  SDEQ\n                  IFJMP:<{\n                        11 BLKDROP\n                  }>\n                  s7 s3 XCPU\n                  SDEQ\n                  500 THROWIFNOT\n                  85167505 PUSHINT\n                  s1 s8 XCHG\n                  EQUAL\n                  501 THROWIFNOT\n                  LDMSGADDR\n                  DROP\n                  s4 s8 XCHG\n                  s3 s7 XCHG\n                  4 3 BLKSWAP\n                  s0 s8 XCHG\n                  NEWC\n                  1 STU\n                  s1 s7 XCHG\n                  32 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s0 s3 XCHG2\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STGRAMS\n                  STREF\n                  32 STU\n                  64 STU\n                  ENDC\n                  c4 POP\n            }>\n            DROP\n            NIP\n            s7 POP\n            s8 PUSH\n            3 EQINT\n            IFJMP:<{\n                  s8 POP\n                  s9 POP\n                  100000000 PUSHINT\n                  s1 s8 XCHG\n                  GEQ\n                  457 THROWIFNOT\n                  s4 s6 PUSH2\n                  SDEQ\n                  s5 s2 XCPU\n                  SDEQ\n                  s1 s5 XCHG\n                  OR\n                  458 THROWIFNOT\n                  0 PUSHINT\n                  DUP\n                  1607220500 PUSHINT\n                  OVER\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s8 PUSH\n                  STSLICER\n                  OVER\n                  STGRAMS\n                  107 STU\n                  32 STU\n                  s1 s5 XCHG\n                  64 STU\n                  s7 PUSH\n                  STSLICER\n                  s7 PUSH\n                  STSLICER\n                  s1 s4 XCHG\n                  1 STI\n                  s3 PUSH\n                  STGRAMS\n                  s1 s3 XCHG\n                  1 STI\n                  ENDC\n                  7 PUSHPOW2\n                  SENDRAWMSG\n                  1 PUSHINT\n                  0 PUSHINT\n                  s7 s0 s0 XC2PU\n                  5 3 REVERSE\n                  s3 s4 XCHG\n                  s2 s3 XCHG\n                  s0 s8 XCHG\n                  NEWC\n                  1 STU\n                  s1 s7 XCHG\n                  32 STU\n                  s0 s5 XCHG2\n                  STSLICER\n                  s0 s3 XCHG2\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  SWAP\n                  STGRAMS\n                  STREF\n                  32 STU\n                  64 STU\n                  ENDC\n                  c4 POP\n            }>\n            s8 PUSH\n            0 EQINT\n            IFJMP:<{\n                  s6 POP\n                  s7 POP\n                  s3 s8 XCHG\n                  s7 s6 s5 XCHG3\n                  s1 s4 XCHG\n                  s3 s3 s0 XCHG3\n                  0 PUSHINT\n                  5 CALLDICT\n            }>\n            s0 s8 XCHG\n            2 EQINT\n            IFJMP:<{\n                  5 5 BLKSWAP\n                  s2 s4 XCHG\n                  s2 s3 XCHG\n                  5 CALLDICT\n            }>\n            10 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      5 => <{\n            100000000 PUSHINT\n            s6 s(-1) PUXC\n            ADD\n            s3 s(-1) PUXC\n            GEQ\n            450 THROWIFNOT\n            s4 PUSH\n            CTOS\n            LDMSGADDR\n            LDGRAMS\n            LDMSGADDR\n            LDGRAMS\n            DROP\n            s9 s2 PUSH2\n            SUB\n            OVER\n            SUB\n            s8 s7 XCHG2\n            SUB\n            s1 s6 XCHG\n            ADD\n            s9 s(-1) PUXC\n            OVER\n            REWRITESTDADDR\n            2DROP\n            0 PUSHINT\n            16 PUSHINT\n            NEWC\n            6 STU\n            s0 s3 XCHG2\n            STSLICER\n            SWAP\n            STGRAMS\n            107 STU\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n            s5 PUSH\n            0 GTINT\n            s5 PUSH\n            SBITS\n            2 GTINT\n            AND\n            IF:<{\n                  s4 s5 XCHG2\n                  OVER\n                  REWRITESTDADDR\n                  2DROP\n                  0 PUSHINT\n                  16 PUSHINT\n                  NEWC\n                  6 STU\n                  s0 s3 XCHG2\n                  STSLICER\n                  SWAP\n                  STGRAMS\n                  107 STU\n                  ENDC\n                  1 PUSHINT\n                  SENDRAWMSG\n                  s2 s3 XCHG\n            }>ELSE<{\n                  s4 POP\n                  s4 POP\n            }>\n            2SWAP\n            OVER\n            REWRITESTDADDR\n            2DROP\n            0 PUSHINT\n            16 PUSHINT\n            NEWC\n            6 STU\n            s0 s3 XCHG2\n            STSLICER\n            SWAP\n            STGRAMS\n            107 STU\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n            0 PUSHINT\n            DUP\n            1607220500 PUSHINT\n            NEWC\n            32 STU\n            s3 s(-1) PUXC\n            64 STU\n            s4 PUSH\n            STSLICER\n            s0 s4 XCHG2\n            STSLICER\n            s1 s3 XCHG\n            1 STI\n            30000000 PUSHINT\n            STGRAMS\n            s1 s2 XCHG\n            1 STI\n            ENDC\n            1 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            s7 PUSH\n            STSLICER\n            0 PUSHINT\n            STGRAMS\n            107 STU\n            STREF\n            s5 PUSH\n            REWRITESTDADDR\n            2DROP\n            ENDC\n            7 PUSHPOW2\n            SENDRAWMSG\n            1 PUSHINT\n            7 1 BLKSWAP\n            NOW\n            SWAP\n            s0 s8 XCHG\n            NEWC\n            1 STU\n            s1 s7 XCHG\n            32 STU\n            s0 s5 XCHG2\n            STSLICER\n            s0 s3 XCHG2\n            STSLICER\n            SWAP\n            STSLICER\n            SWAP\n            STGRAMS\n            STREF\n            32 STU\n            64 STU\n            ENDC\n            c4 POP\n      }>\n      72748 => <{\n            c4 PUSH\n            CTOS\n            1 LDU\n            32 LDU\n            LDMSGADDR\n            LDMSGADDR\n            LDMSGADDR\n            LDGRAMS\n            LDREF\n            32 LDU\n            64 LDU\n            DROP\n            2DROP\n            CTOS\n            LDMSGADDR\n            LDGRAMS\n            LDMSGADDR\n            LDGRAMS\n            DROP\n            s4 s2 PUSH2\n            SUB\n            OVER\n            SUB\n            1 LESSINT\n            409 THROWIF\n            s7 PUSH\n            REWRITESTDADDR\n            2DROP\n            s6 PUSH\n            REWRITESTDADDR\n            2DROP\n            s3 PUSH\n            REWRITESTDADDR\n            2DROP\n            1179211856 PUSHINT\n            s0 s10 XCHG\n            1 EQINT\n            9 1 BLKSWAP\n      }>\n      122045 => <{\n            c4 PUSH\n            CTOS\n            1 LDU\n            32 LDU\n            LDMSGADDR\n            LDMSGADDR\n            LDMSGADDR\n            LDGRAMS\n            LDREF\n            32 LDU\n            64 LDU\n            DROP\n            s0 s2 XCHG\n            CTOS\n            LDMSGADDR\n            LDGRAMS\n            LDMSGADDR\n            LDGRAMS\n            DROP\n            s6 s2 PUSH2\n            SUB\n            OVER\n            SUB\n            1 LESSINT\n            410 THROWIF\n            s9 PUSH\n            REWRITESTDADDR\n            2DROP\n            s8 PUSH\n            REWRITESTDADDR\n            2DROP\n            s3 PUSH\n            REWRITESTDADDR\n            2DROP\n            s0 s11 XCHG\n            1 EQINT\n            s0 s11 XCHG\n            s3 s5 XCHG\n            2 3 BLKSWAP\n      }>\n}\n11 THROWARG",
  "code_hash": "24221fa571e542e055c77bedfdbf527c7af460cfdc7f344c450787b4cfa1eb4d",
  "methods": [
    {
      "id": 72748,
      "method": "get_sale_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "nft-fixprice-sale-v3r3.fc",
        "content": ";; NFT sale smart contract v3r3\n;; It's a v3r2 but with returning query_id, handling code 32, allow change price\n;; see https://github.com/getgems-io/nft-contracts\n\n#include \"imports/stdlib.fc\";\n#include \"op-codes.fc\";\n\nint min_gas_amount() asm \"100000000 PUSHINT\"; ;; 0.1 TON\nslice msg::cancel_msg() asm \"<b 124 word cancel| $, b> <s PUSHSLICE\";\n() check_std_addr(slice s) impure asm \"REWRITESTDADDR\" \"DROP2\";\n\n_ load_data() inline {\n  var ds = get_data().begin_parse();\n  return (\n    ds~load_uint(1), ;; is_complete\n    ds~load_uint(32), ;; created_at\n    ds~load_msg_addr(), ;; marketplace_address\n    ds~load_msg_addr(), ;; nft_address\n    ds~load_msg_addr(), ;; nft_owner_address\n    ds~load_coins(), ;; full_price\n    ds~load_ref(), ;; fees_cell\n    ds~load_uint(32), ;; sold_at\n    ds~load_uint(64)    ;; query_id\n  );\n}\n\n_ load_fees(cell fees_cell) inline {\n  var ds = fees_cell.begin_parse();\n  return (\n    ds~load_msg_addr(), ;; marketplace_fee_address\n    ds~load_coins(), ;; marketplace_fee,\n    ds~load_msg_addr(), ;; royalty_address\n    ds~load_coins()     ;; royalty_amount\n  );\n}\n\n() save_data(int is_complete, int created_at, slice marketplace_address, slice nft_address, slice nft_owner_address, int full_price, cell fees_cell, int sold_at, int query_id) impure inline {\n  set_data(\n    begin_cell()\n    .store_uint(is_complete, 1)\n    .store_uint(created_at, 32)\n    .store_slice(marketplace_address)\n    .store_slice(nft_address)\n    .store_slice(nft_owner_address)\n    .store_coins(full_price)\n    .store_ref(fees_cell)\n    .store_uint(sold_at, 32)\n    .store_uint(query_id, 64)\n    .end_cell()\n  );\n}\n\n() send_money(slice address, int amount) impure inline {\n  check_std_addr(address);\n  var msg = begin_cell()\n  .store_uint(0x10, 6) ;; nobounce\n  .store_slice(address)\n  .store_coins(amount)\n  .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n  .end_cell();\n\n  send_raw_message(msg, 1);\n}\n\n() buy(var args) impure {\n\n  (\n    int created_at,\n    slice marketplace_address,\n    slice nft_address,\n    slice nft_owner_address,\n    int full_price,\n    cell fees_cell,\n\n    int my_balance,\n    int msg_value,\n    slice sender_address,\n    int query_id\n  ) = args;\n\n  throw_unless(450, msg_value >= full_price + min_gas_amount());\n\n  var (\n    marketplace_fee_address,\n    marketplace_fee,\n    royalty_address,\n    royalty_amount\n  ) = load_fees(fees_cell);\n\n  ;; Owner message\n  send_money(\n    nft_owner_address,\n    full_price - marketplace_fee - royalty_amount + (my_balance - msg_value)\n  );\n\n  ;; Royalty message\n  if ((royalty_amount > 0) & (royalty_address.slice_bits() > 2)) {\n    send_money(\n      royalty_address,\n      royalty_amount\n    );\n  }\n\n  ;; Marketplace fee message\n  send_money(\n    marketplace_fee_address,\n    marketplace_fee\n  );\n\n  builder nft_transfer = begin_cell()\n  .store_uint(op::transfer(), 32)\n  .store_uint(query_id, 64)\n  .store_slice(sender_address) ;; new_owner_address\n  .store_slice(sender_address) ;; response_address\n  .store_int(0, 1) ;; empty custom_payload\n  .store_coins(30000000) ;; forward amount to new_owner_address 0.03 TON\n  .store_int(0, 1); ;; empty forward_payload\n  var nft_msg = begin_cell()\n  .store_uint(0x18, 6)\n  .store_slice(nft_address)\n  .store_coins(0)\n  .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n  .store_ref(nft_transfer.end_cell());\n\n\n  check_std_addr(nft_address);\n  send_raw_message(nft_msg.end_cell(), 128);\n\n  ;; Set sale as complete\n  save_data(\n    1,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    fees_cell,\n    now(),\n    query_id\n  );\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n\n  if (flags & 1) {\n    ;; ignore all bounced messages\n    return ();\n  }\n\n  slice sender_address = cs~load_msg_addr();\n\n  var (\n    is_complete,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    fees_cell,\n    sold_at,\n    query_id\n  ) = load_data();\n\n  int op = 0;\n  int query_id = 0;\n\n  if (in_msg_body.slice_empty?() == false) {\n    op = in_msg_body~load_uint(32);\n  }\n\n  if (op != 0) {\n    query_id = in_msg_body~load_uint(64);\n  } else {\n    if (equal_slices(msg::cancel_msg(), in_msg_body)) {\n      op = 3;\n    }\n  }\n\n  if (op == 1) {\n    ;; just accept coins\n    return ();\n  }\n\n  var is_initialized = nft_owner_address.slice_bits() > 2; ;; not initialized if null address\n\n  if ((op == 555) & ((is_complete == 1) | (~ is_initialized)) & equal_slices(sender_address, marketplace_address)) {\n    ;; way to fix unexpected troubles with sale contract\n    ;; for example if some one transfer nft to this contract\n    var msg = in_msg_body~load_ref().begin_parse();\n    var mode = msg~load_uint(8);\n\n    throw_if(405, mode & 32);\n\n    if (sold_at != 0) {\n      int ten_min = 10 * 60;\n      throw_if(406, (now() > (sold_at - ten_min)) & (now() < (sold_at + ten_min)));\n    }\n\n    send_raw_message(msg~load_ref(), mode);\n    return ();\n  }\n\n  ;; Throw if sale is complete\n  throw_if(404, is_complete == 1);\n\n  if ((op == 0x6c6c2080) & equal_slices(sender_address, nft_owner_address)) {\n    var (new_full_price, new_marketplace_fee, new_royalty_amount) = (in_msg_body~load_coins(), in_msg_body~load_coins(), in_msg_body~load_coins());\n    int profit_price = new_full_price - new_marketplace_fee - new_royalty_amount;\n    throw_if(408, profit_price < 1);\n\n    var (\n      marketplace_fee_address,\n      marketplace_fee,\n      royalty_address,\n      royalty_amount\n    ) = load_fees(fees_cell);\n\n    var new_fees_cell = begin_cell()\n    .store_slice(marketplace_fee_address)\n    .store_coins(new_marketplace_fee)\n    .store_slice(royalty_address)\n    .store_coins(new_royalty_amount)\n    .end_cell();\n\n    save_data(\n      is_complete,\n      created_at,\n      marketplace_address,\n      nft_address,\n      nft_owner_address,\n      new_full_price,\n      new_fees_cell,\n      0,\n      0\n    );\n    return ();\n  }\n\n  if (~ is_initialized) {\n\n    if (equal_slices(sender_address, marketplace_address)) {\n      return (); ;; just accept coins on deploy\n    }\n\n    throw_unless(500, equal_slices(sender_address, nft_address));\n    throw_unless(501, op == op::ownership_assigned());\n    slice prev_owner_address = in_msg_body~load_msg_addr();\n\n    save_data(\n      is_complete,\n      created_at,\n      marketplace_address,\n      nft_address,\n      prev_owner_address,\n      full_price,\n      fees_cell,\n      sold_at,\n      query_id\n    );\n\n    return ();\n  }\n\n  if (op == 3) {\n    ;; cancel sale\n    throw_unless(457, msg_value >= min_gas_amount());\n    throw_unless(458, equal_slices(sender_address, nft_owner_address) | equal_slices(sender_address, marketplace_address));\n\n    var msg = begin_cell()\n    .store_uint(0x10, 6) ;; nobounce\n    .store_slice(nft_address)\n    .store_coins(0)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(op::transfer(), 32)\n    .store_uint(query_id, 64)\n    .store_slice(nft_owner_address) ;; new_owner_address\n    .store_slice(nft_owner_address) ;; response_address;\n    .store_int(0, 1) ;; empty custom_payload\n    .store_coins(0) ;; forward amount to new_owner_address\n    .store_int(0, 1); ;; empty forward_payload\n\n    send_raw_message(msg.end_cell(), 128);\n\n    save_data(\n      1,\n      created_at,\n      marketplace_address,\n      nft_address,\n      nft_owner_address,\n      full_price,\n      fees_cell,\n      0,\n      0\n    );\n    return ();\n  }\n\n  if (op == 0) {\n    buy(\n      created_at,\n      marketplace_address,\n      nft_address,\n      nft_owner_address,\n      full_price,\n      fees_cell,\n\n      my_balance,\n      msg_value,\n      sender_address,\n      0\n    );\n    return ();\n  }\n\n  if (op == 2) {\n    ;; buy\n    buy(\n      created_at,\n      marketplace_address,\n      nft_address,\n      nft_owner_address,\n      full_price,\n      fees_cell,\n\n      my_balance,\n      msg_value,\n      sender_address,\n      query_id\n    );\n    return ();\n  }\n\n  throw(0xffff);\n}\n\n(int, int, int, slice, slice, slice, int, slice, int, slice, int) get_sale_data() method_id {\n  var (\n    is_complete,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    fees_cell,\n    sold_at,\n    query_id\n  ) = load_data();\n\n  var (\n    marketplace_fee_address,\n    marketplace_fee,\n    royalty_address,\n    royalty_amount\n  ) = load_fees(fees_cell);\n\n  int profit_price = full_price - marketplace_fee - royalty_amount;\n  throw_if(409, profit_price < 1);\n  check_std_addr(marketplace_address);\n  check_std_addr(nft_address);\n  check_std_addr(marketplace_fee_address);\n\n  return (\n    0x46495850, ;; fix price sale (\"FIXP\")\n    is_complete == 1,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    marketplace_fee_address,\n    marketplace_fee,\n    royalty_address,\n    royalty_amount\n  );\n}\n\n(int, int, slice, slice, slice, int, slice, int, slice, int, int, int) get_fix_price_data() method_id {\n  var (\n    is_complete,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    fees_cell,\n    sold_at,\n    query_id\n  ) = load_data();\n\n  var (\n    marketplace_fee_address,\n    marketplace_fee,\n    royalty_address,\n    royalty_amount\n  ) = load_fees(fees_cell);\n\n  int profit_price = full_price - marketplace_fee - royalty_amount;\n  throw_if(410, profit_price < 1);\n  check_std_addr(marketplace_address);\n  check_std_addr(nft_address);\n  check_std_addr(marketplace_fee_address);\n\n  return (\n    is_complete == 1,\n    created_at,\n    marketplace_address,\n    nft_address,\n    nft_owner_address,\n    full_price,\n    marketplace_fee_address,\n    marketplace_fee,\n    royalty_address,\n    royalty_amount,\n    sold_at,\n    query_id\n  );\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}