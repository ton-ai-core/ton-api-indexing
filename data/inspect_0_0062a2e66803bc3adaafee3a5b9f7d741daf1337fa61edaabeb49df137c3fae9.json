{
  "code": "b5ee9c7201021101000317000114ff00f4a413f4bcf2c80b0102016202030202cc0405001ba0f605da89a1f401f481f481a8610201200607020120080900b7d106380792000e8698180b8d84a89af81f806707d207d2018fd0018b8eb90fd0018fd001801698fc10807c53f52a9105d4a989a2cf804f041080bc6a28ca9105d4b1899a019f805701ac1082caf83de5d49acf805f02f824207f978400116be910c1c2ebcb85360201200a0b0083d40106b90f6a2687d007d207d206a1802698fc1080bc6a28ca9105d41083deecbef09dd0958f97162e99f98fd001809d02811e428027d012c678b00e78b6664f6aa401f5503d33ffa00fa4021f006ed44d0fa00fa40fa40d4305136a1522ac705f2e2c128c2fff2e2c254344270542013541403c85004fa0258cf1601cf16ccc922c8cb0112f400f400cb00c920f9007074c8cb02ca07cbffc9d004fa40f40431fa00778018c8cb055008cf1670fa0217cb6b13cc8210178d4519c8cb1f1980c0201200d0e008ecb3f5007fa0222cf165006cf1625fa025003cf16c95005cc07aa0013a08208989680aa008208989680a0a014bcf2e2c504c98040fb001023c85004fa0258cf1601cf16ccc9ed5402f13b51343e803e903e90350c01f4cffe80145468017e903e9014d6b1c1551cdb1c150804d50500f214013e809633c58073c5b33248b232c044bd003d0032c0327e401c1d3232c0b281f2fff274140331c146ec7cb8b0c27e8020822625a020822625a02806a8486544124e17c138c34975c2c070c00930802c200f1000db3b51343e803e903e90350c01f4cffe803e900c145468549271c17cb8b049f0bffcb8b0a0822625a02a8005a805af3cb8b0e0841ef765f7b232c7c572cfd400fe8088b3c58073c5b25c60043232c14933c59c3e80b2dab33260103ec01004f214013e809633c58073c5b3327b5520006c5219a018a182107362d09cc8cb1f5240cb3f5003fa0201cf165007cf16c9718018c8cb0525cf165007fa0216cb6a15ccc971fb00103400828e2a820898968072fb028210d53276db708010c8cb055008cf165005fa0216cb6a13cb1f13cb3fc972fb0058926c33e25502c85004fa0258cf1601cf16ccc9ed54",
  "code_hash": "ec7c309191cab37164fafdcd871985aad7aa6ac429c3cb27580e1345d1cbb8db",
  "methods": [
    {
      "id": 97026,
      "method": "get_wallet_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "btn-jwallet.func",
        "content": ";; This code was verified by @gosunov\n;; subscribe to my channel @gosunov_ch\n;; buy $SLOW\n\n;;  _           _ _   \n;; | |         | | |  \n;; | |__   ___ | | |_ \n;; | '_ \\ / _ \\| | __|\n;; | |_) | (_) | | |_ \n;; |_.__/ \\___/|_|\\__|\n\n;;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\nint min_tons_for_storage() asm \"10000000 PUSHINT\"; ;; 0.01 TON\nint gas_consumption() asm \"10000000 PUSHINT\"; ;; 0.01 TON\n\n\n(int, slice, slice, cell) load_data() inline {\n  slice ds = get_data().begin_parse();\n  return (ds~load_grams(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref());\n}\n\n() save_data (int balance, slice owner_addr, slice jmaster_addr, cell jwall_code) impure inline {\n  set_data(pack_jwall_data(balance, owner_addr, jmaster_addr, jwall_code));\n}\n\n{-\n  transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\n           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\n           = InternalMsgBody;\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell) \n                     = InternalMsgBody;\n-}\n\n() send_tokens (slice in_msg_body, slice sender_addr, int msg_value, int fwd_fee) impure {\n    int query_id = in_msg_body~load_uint(64);\n    int jetton_amount = in_msg_body~load_grams();\n    slice to_owner_addr = in_msg_body~load_msg_addr();\n    force_chain(to_owner_addr);\n    (int balance, slice owner_addr, slice jmaster_addr, cell jwall_code) = load_data();\n    balance -= jetton_amount;\n\n    throw_unless(705, extlib::slice_data_equal?(owner_addr, sender_addr));\n    throw_unless(706, balance >= 0);\n\n    cell state_init = jwall_state_init(to_owner_addr, jmaster_addr, jwall_code);\n    slice to_wallet_address = jwall_state_addr(state_init);\n    slice response_address = in_msg_body~load_msg_addr();\n    cell custom_payload = in_msg_body~load_dict();\n    int forward_ton_amount = in_msg_body~load_grams();\n    slice either_forward_payload = in_msg_body;\n\n    builder msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(to_wallet_address)\n        .store_grams(0)\n        .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n        .store_ref(state_init);\n\n    cell msg_body = begin_cell()\n        .store_uint(op::internal_transfer(), 32)\n        .store_uint(query_id, 64)\n        .store_grams(jetton_amount)\n        .store_slice(owner_addr)\n        .store_slice(response_address)\n        .store_grams(forward_ton_amount)\n        .store_slice(either_forward_payload)\n        .end_cell();\n\n    msg = msg.store_ref(msg_body);\n    throw_unless(709, msg_value >\n        forward_ton_amount +\n        ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response\n        ;; but last one is optional (it is ok if it fails)\n        2 * fwd_fee +\n        (2 * gas_consumption() + min_tons_for_storage()));\n        ;; universal message send fee calculation may be activated here\n        ;; by using this instead of fwd_fee\n        ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)\n\n    send_raw_message(msg.end_cell(), 64); ;; revert on errors\n    save_data(balance, owner_addr, jmaster_addr, jwall_code);\n}\n\n{-\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell) \n                     = InternalMsgBody;\n-}\n\n() receive_tokens (slice in_msg_body, slice sender_addr, int my_ton_balance, int fwd_fee) impure {\n    ;; NOTE we can not allow fails in action phase since in that case there will be\n    ;; no bounce. Thus check and throw in computation phase.\n    (int balance, slice owner_addr, slice jmaster_addr, cell jwall_code) = load_data();\n    int query_id = in_msg_body~load_uint(64);\n    int jetton_amount = in_msg_body~load_grams();\n    balance += jetton_amount;\n    slice from_addr = in_msg_body~load_msg_addr();\n    slice response_address = in_msg_body~load_msg_addr();\n\n    throw_unless(707,\n        extlib::slice_data_equal?(jmaster_addr, sender_addr) |\n        extlib::slice_data_equal?(\n            jwall_addr_by_owner(from_addr, jmaster_addr, jwall_code), sender_addr\n        )\n    );\n\n    int fwd_grams = in_msg_body~load_grams(); ;; forward_ton_amount\n\n    my_ton_balance -= (min_tons_for_storage() + gas_consumption());\n    if(fwd_grams) {\n        my_ton_balance -= (fwd_grams + fwd_fee);\n        slice either_forward_payload = in_msg_body;\n\n        var msg_body = begin_cell()\n            .store_uint(op::transfer_notification(), 32)\n            .store_uint(query_id, 64)\n            .store_grams(jetton_amount)\n            .store_slice(from_addr)\n            .store_slice(either_forward_payload)\n            .end_cell();\n\n        var msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(owner_addr)\n            .store_grams(fwd_grams)\n            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_ref(msg_body);\n\n        send_raw_message(msg.end_cell(), 1);\n    }\n\n    if ((response_address.preload_uint(2) != 0) & (my_ton_balance > 0)) {\n        raw_reserve(min_tons_for_storage(), 2);\n        var msg = begin_cell()\n            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n            .store_slice(response_address)\n            .store_grams(my_ton_balance)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n        send_raw_message(msg.end_cell(), 2);\n    }\n\n    save_data(balance, owner_addr, jmaster_addr, jwall_code);\n}\n\n() burn_tokens (slice in_msg_body, slice sender_addr, int msg_value, int fwd_fee) impure {\n    ;; NOTE we can not allow fails in action phase since in that case there will be\n    ;; no bounce. Thus check and throw in computation phase.\n    (int balance, slice owner_addr, slice jmaster_addr, cell jwall_code) = load_data();\n    int query_id = in_msg_body~load_uint(64);\n    int jetton_amount = in_msg_body~load_grams();\n    slice response_address = in_msg_body~load_msg_addr();\n    ;; ignore custom payload\n    ;; slice custom_payload = in_msg_body~load_dict();\n    balance -= jetton_amount;\n    throw_unless(705, extlib::slice_data_equal?(owner_addr, sender_addr));\n    throw_unless(706, balance >= 0);\n    throw_unless(707, msg_value > fwd_fee + 2 * gas_consumption());\n\n    var msg_body = begin_cell()\n        .store_uint(op::burn_notification(), 32)\n        .store_uint(query_id, 64)\n        .store_grams(jetton_amount)\n        .store_slice(owner_addr)\n        .store_slice(response_address)\n        .end_cell();\n\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n        .store_slice(jmaster_addr)\n        .store_grams(0)\n        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_ref(msg_body);\n\n    send_raw_message(msg.end_cell(), 64);\n\n    save_data(balance, owner_addr, jmaster_addr, jwall_code);\n}\n\n() on_bounce (slice in_msg_body) impure {\n    in_msg_body~skip_bits(32); ;; 0xFFFFFFFF\n    (int balance, slice owner_addr, slice jmaster_addr, cell jwall_code) = load_data();\n    int op = in_msg_body~load_uint(32);\n    throw_unless(709, (op == op::internal_transfer()) | (op == op::burn_notification()));\n    int query_id = in_msg_body~load_uint(64);\n    int jetton_amount = in_msg_body~load_grams();\n    balance += jetton_amount;\n    save_data(balance, owner_addr, jmaster_addr, jwall_code);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    ;; istead of if (in_msg_body.slice_empty?()) { return (); }\n    throw_if(0, in_msg_body.slice_empty?());\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {\n        on_bounce(in_msg_body);\n        return ();\n    }\n\n    slice sender_addr = cs~load_msg_addr();\n    cs~load_msg_addr(); ;; skip dst\n    cs~load_grams(); ;; skip value\n    cs~skip_bits(1); ;; skip extracurrency collection\n    cs~load_grams(); ;; skip ihr_fee\n    int fwd_fee = cs~load_grams(); ;; we use message fwd_fee for estimation of forward_payload costs\n\n    int op = in_msg_body~load_uint(32);\n\n    if (op == op::transfer()) { ;; outgoing transfer\n        send_tokens(in_msg_body, sender_addr, msg_value, fwd_fee);\n        return ();\n    }\n\n    if (op == op::internal_transfer()) { ;; incoming transfer\n        receive_tokens(in_msg_body, sender_addr, my_balance, fwd_fee);\n        return ();\n    }\n\n    if (op == op::burn()) { ;; burn\n        burn_tokens(in_msg_body, sender_addr, msg_value, fwd_fee);\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, slice, slice, cell) get_wallet_data() method_id {\n    return load_data();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "lib/extlib.func",
        "content": ";;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\n;;\n;; extension for FunC standard library (stdlib.fc)\n;;\n\nint     extlib::1ton()                                 asm \"1000000000 PUSHINT\";\n\nint     extlib::tuple_len(tuple t)                      asm \"TLEN PUSHINT\";\nint     extlib::slice_data_equal?(slice s1, slice s2)   asm \"SDEQ\";\nslice   extlib::empty_slice()                           asm \"<b b> <s PUSHSLICE\";\nslice   extlib::addr_none()                             asm \"<b b{00} s, b> <s PUSHSLICE\";\n\n;;  addr_std$10 anycast:(## 1) {anycast = 0}\n;;      workchain_id:int8 address:bits256 = MsgAddrSmpl;\nslice extlib::addrsmpl_start()  asm \"<b b{100} s, b> <s PUSHSLICE\";\n\nint extlib::is_addrsmpl(slice addr) inline {\n    return extlib::slice_data_equal?(\n        addr.preload_bits(3),\n        extlib::addrsmpl_start()\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils/op-codes.func",
        "content": ";;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\nint op::transfer()              asm \"0xf8a7ea5 PUSHINT\";\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\nint op::internal_transfer()     asm \"0x178d4519 PUSHINT\";\nint op::excesses()              asm \"0xd53276db PUSHINT\";\nint op::burn()                  asm \"0x595f07bc PUSHINT\";\nint op::burn_notification()     asm \"0x7bdd97de PUSHINT\";\n\n;; ---- minter-ico ----\n\nint op::mint()        asm \"0x318f361 PUSHINT\";\nint op::buy_tokens()  asm \"0x71b69969 PUSHINT\";\nint op::withdraw()    asm \"0x35de5f9e PUSHINT\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils/jetton-utils.func",
        "content": ";;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\nint workchain() asm \"0 PUSHINT\";\n\ncell pack_jwall_data(\n    int balance,\n    slice owner_addr,\n    slice jmaster_addr,\n    cell jwallet_code\n) inline {\n    return begin_cell()\n        .store_grams(balance)\n        .store_slice(owner_addr)\n        .store_slice(jmaster_addr)\n        .store_ref(jwallet_code)\n        .end_cell();\n}\n\ncell jwall_state_init(\n    slice owner_addr,\n    slice jmaster_addr,\n    cell jwallet_code\n) inline {\n    return begin_cell()\n        .store_uint(0, 2)\n        .store_dict(jwallet_code)\n        .store_dict(pack_jwall_data(0, owner_addr, jmaster_addr, jwallet_code))\n        .store_uint(0, 1)\n        .end_cell();\n}\n\nslice jwall_state_addr(cell state_init) inline {\n    return begin_cell()\n        .store_uint(4, 3)\n        .store_int(workchain(), 8)\n        .store_uint(cell_hash(state_init), 256)\n        .end_cell()\n        .begin_parse();\n}\n\nslice jwall_addr_by_owner(slice owner_addr, slice jmaster_addr, cell jwall_code) inline {\n    return jwall_state_addr(jwall_state_init(\n        owner_addr, jmaster_addr, jwall_code\n    ));\n}\n\n() force_chain(slice addr) impure {\n    (int wc, _) = parse_std_addr(addr);\n    throw_unless(333, wc == workchain());\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils/exit-codes.func",
        "content": ";;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\n;; basic exit codes\nint ext_code::err_auth()                asm \"1000 PUSHINT\";\nint ext_code::err_addr_format()         asm \"1001 PUSHINT\";\nint ext_code::err_not_enough_balance()  asm \"1002 PUSHINT\";\nint ext_code::invalid_jwall_addr()      asm \"1003 PUSHINT\";\nint ext_code::max_supply_limit()        asm \"1004 PUSHINT\";\n\n;; \"op::buy_tokens()\" exit codes\nint ext_code::supply_more_than_liq_cap()    asm \"2000 PUSHINT\";\nint ext_code::ico_end()                     asm \"2001 PUSHINT\";\nint ext_code::err_buy_amount()              asm \"2002 PUSHINT\";\n\n;; system exit codes\nint ext_code::zero() asm \"0 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils/text.func",
        "content": ";;\n;;  btn-token-smc – smart contracts collection for Biton token\n;;\n;;  Copyright (C) 2022 BITON <https://github.com/BITONdev>\n;;\n;;  This file is part of btn-token-smc.\n;;\n;;  btn-token-smc is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU General Public License as published by\n;;  the Free Software Foundation, either version 3 of the License, or\n;;  (at your option) any later version.\n;;\n;;  btn-token-smc is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU General Public License for more details.\n;;\n;;  You should have received a copy of the GNU General Public License\n;;  along with btn-token-smc.  If not, see <https://www.gnu.org/licenses/>.\n;;\n\n;;\n;; set of texts that the smc uses\n;;\n\nslice text::ico_profit_withdraw()   asm \"<b 124 word withdraw profit from ICO| $, b> <s PUSHSLICE\";\nslice text::ico_biton_profit()      asm \"<b 124 word $BOLT ICO fees| $, b> <s PUSHSLICE\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "lib/stdlib.func",
        "content": ";;\n;;  Standard library for funC\n;;\n\n;;\n;;  This file is part of TON Blockchain Library.\n;;\n;;  TON Blockchain Library is free software: you can redistribute it and/or modify\n;;  it under the terms of the GNU Lesser General Public License as published by\n;;  the Free Software Foundation, either version 2 of the License, or\n;;  (at your option) any later version.\n;;\n;;  TON Blockchain Library is distributed in the hope that it will be useful,\n;;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;;  GNU Lesser General Public License for more details.\n;;\n;;  You should have received a copy of the GNU Lesser General Public License\n;;  along with TON Blockchain Library.  If not, see <http://www.gnu.org/licenses/>.\n;;\n;;  Copyright 2017-2020 Telegram Systems LLP\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}