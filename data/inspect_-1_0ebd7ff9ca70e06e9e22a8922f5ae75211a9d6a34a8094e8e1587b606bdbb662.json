{
  "code": "b5ee9c7201022f010004c1000114ff00f4a413f4bcf2c80b01020120020302014804050106f2db3c080202cc0607020120161704e5d9063804741aded9e7041846b8c107c8080e983ed9e7c1190de795311e0000a50a9c13c7a0737d0f94fed9e2a0de5fc88795003fa02107c8080e98fa88cdd7955699fb82980f80680e10400c1855e58f934298a40207a0737d0904c07d2106105793387effc11d50fa9a05cf930aa11d9a9a7c082e120902012010110220db3c03f265f8005045710403db3ced542e1c049edb3c5610ae5320b0f26212b102a425b3531db9b0258100e1aa23a028bcb0f2690597021111023f3f308e90011110011111db3c40e878f44310ce06e254156c5473f6561153eddb3c54710b547bcd2d0a130c0b016c018e1a30d20001f2a3d307d3075003d70120f90105f90115baf2a45003e06c212120d74ac00121d749c008b0f2abdb3c5f04705420130f04cadb3ced5470256e537abeb1953f50dc5f068f1d30542403504edb3c5044a04650104a103b4c0b537cdb3c7f4818507706e28325a18e2c278040f4966fa52094305303b9de208e16393a3a09d2000197d3073017f00a069130e27f090806926c31e2b3e630071c210c0d029a5230be8f2e5f03db3cf828fa443105db3c01c0ff05ba14b05026bd15b1945003fb00923032e270c8ca0040148040f44302f00a8e1771c8cb0014cb0712cb0758cf0158cf1640138040f44301e20e0f01568e8b10561045035024db3ced54925f07e2d074d721fa4030708018c8cb0558cf1621fa02cb6ac98042fb001c004a8048f833206e953080b8f833de206e93307020e0d020d7498308b993307020e0d3ffd3ff300022d307d43020d0d30331fa4031fa4030fa440223694c05e3d039be84c36cf2976cf009e3d10e12130201201415000ad3ffd30730000c01c8cbffcb07002d502a422d74912a09322d74a9702d401d013f00de86c128004f4216e9131e0206e9130e001d020d74ac3009ad402f00ec858cf16ccc9e071d723c801cf16f400c98020120181902012022230201201a1b0201481d1e010db4b1bb678d8c302e0117b7db2da882ae0088627b67901c002c01c8cb1f12cb0712cb0712cb3f12f40012f400cb1fc90201201f200173b11d7420c235c6083e404074c1e08075313b50f614c81e3d039be87ca7f5c2ffd78c7e443ca82b807d01085ba4d6dc4cb83e405636cf0069006021003daeda80e800e800fa02017a0211fc8080fc80dd794ff807647a0000e78b64c00015ae19574100d56676a1ec400060708e2903d08308d718d307f40430531678f40e6fa1f2a5d70bff544544f910f2a6ae5220b15203bd14a1236ee66c2232020120242502012026270153b7255b67860626466a4610081e81cdf431c24d845a4000331a61e62e005ae0261c0b6fee1c0b77746e102e0187b5599b67828be0864fedb1c68a2270081e8f8df4a411c4605a400031c34410021ae424bae064f613990039e2ca840090081e886052261c52261c52265c4036625ccd88302e02012028290157b4dabb67828be0864b30081e81cdf431c2da400033d0021ae4203ae06035d6122ffc0e1c0be06ffc0be06e102e0201202a2b020399382c2d0111ac1a6d9e2f823609402e0015adf94100cc9576a1ec1840010fa936cf040997c1a02e0015addc2ce0806ab33b50f6200024ed44d0d31fd307d307d33ff404f404d31fd1",
  "code_hash": "6979b2ec29b0cfc4f0f0806dcb6ddc71b37d7fcab29a8bf431c9777089d3024f",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "multisig-code.fc",
        "content": ";; Simple wallet smart contract\n\n(int, int) get_bridge_config() impure inline_ref {\n  cell bridge_config = config_param(72);\n  if (bridge_config.cell_null?()) {\n    bridge_config = config_param(-72);\n  }\n  if (bridge_config.cell_null?()) {\n    return (0, 0);\n  }\n  slice ds = bridge_config.begin_parse();\n  if (ds.slice_bits() < 512) {\n    return (0, 0);\n  }\n  ;; wc always equals to -1\n  int bridge_address = ds~load_uint(256);\n  int oracles_address = ds~load_uint(256);\n  return (bridge_address, oracles_address);\n}\n\n_ unpack_state() inline_ref {\n  var ds = begin_parse(get_data());\n  var res = (ds~load_uint(32), ds~load_uint(8), ds~load_uint(8), ds~load_uint(64), ds~load_dict(), ds~load_dict(), ds~load_uint(32));\n  ds.end_parse();\n  return res;\n}\n\n_ pack_state(cell pending_queries, cell owner_infos, int last_cleaned, int k, int n, int wallet_id, int spend_delay) inline_ref {\n  return begin_cell()\n    .store_uint(wallet_id, 32)\n    .store_uint(n, 8)\n    .store_uint(k, 8)\n    .store_uint(last_cleaned, 64)\n    .store_dict(owner_infos)\n    .store_dict(pending_queries)\n    .store_uint(spend_delay,32)\n  .end_cell();\n}\n\n_ pack_owner_info(int public_key, int flood) inline_ref {\n  return begin_cell()\n    .store_uint(public_key, 256)\n    .store_uint(flood, 8);\n}\n\n_ unpack_owner_info(slice cs) inline_ref {\n  return (cs~load_uint(256), cs~load_uint(8));\n}\n\n(int, int) check_signatures(cell public_keys, cell signatures, int hash, int cnt_bits) inline_ref {\n  int cnt = 0;\n\n  do {\n    slice cs = signatures.begin_parse();\n    slice signature = cs~load_bits(512);\n\n    int i = cs~load_uint(8);\n    signatures = cs~load_dict();\n\n    (slice public_key, var found?) = public_keys.udict_get?(8, i);\n    throw_unless(37, found?);\n    throw_unless(38, check_signature(hash, signature, public_key.preload_uint(256)));\n\n    int mask = (1 << i);\n    int old_cnt_bits = cnt_bits;\n    cnt_bits |= mask;\n    int should_check = cnt_bits != old_cnt_bits;\n    cnt -= should_check;\n  } until (cell_null?(signatures));\n\n  return (cnt, cnt_bits);\n}\n\n(int, cell, int, int) parse_msg(slice in_msg) inline_ref {\n  int mode = in_msg~load_uint(8);\n  var msg = in_msg~load_ref();\n  var msg' = msg.begin_parse();\n  msg'~load_uint(4); ;; flags\n  msg'~load_msg_addr(); ;; src\n  (int wc, int addr) = parse_std_addr(msg'~load_msg_addr()); ;; dest\n  return (mode, msg, wc, addr);\n}\n\n() check_proposed_query(slice in_msg) impure inline {\n  throw_unless(43, (slice_refs(in_msg) == 1) & (slice_bits(in_msg) == 8));\n  (_, _, int wc, _) = parse_msg(in_msg);\n  wc~impure_touch();\n}\n\n(int, int, int, slice) unpack_query_data(slice in_msg, int n, slice query, var found?, int root_i) inline_ref {\n  if (found?) {\n    throw_unless(35, query~load_int(1));\n    (int creator_i, int cnt, int cnt_bits, slice msg) = (query~load_uint(8), query~load_uint(8), query~load_uint(n), query);\n    throw_unless(36, slice_hash(msg) == slice_hash(in_msg));\n    return (creator_i, cnt, cnt_bits, msg);\n  }\n  check_proposed_query(in_msg);\n\n  return (root_i, 0, 0, in_msg);\n}\n\n(cell, ()) dec_flood(cell owner_infos, int creator_i) {\n  (slice owner_info, var found?) = owner_infos.udict_get?(8, creator_i);\n  (int public_key, int flood) = unpack_owner_info(owner_info);\n  owner_infos~udict_set_builder(8, creator_i, pack_owner_info(public_key, flood - 1));\n  return (owner_infos, ());\n}\n\n() try_init() impure inline_ref {\n  ;; first query without signatures is always accepted\n  (int wallet_id, int n, int k, int last_cleaned, cell owner_infos, cell pending_queries, int spend_delay) = unpack_state();\n  throw_if(37, last_cleaned);\n  accept_message();\n  set_data(pack_state(pending_queries, owner_infos, 1, k, n, wallet_id, spend_delay));\n}\n\n() recv_external() {\n  try_init();\n}\n\n(cell, cell) update_pending_queries(cell pending_queries, cell owner_infos, slice msg, int query_id, int creator_i, int cnt, int cnt_bits, int n, int k) impure inline_ref {\n  if (cnt >= k) {\n    (int bridge_address, int oracles_address) = get_bridge_config();\n    (_, int my_addr) = parse_std_addr(my_address());\n    var (mode, msg', wc, addr) = parse_msg(msg);\n    if ( ((wc == -1) & (addr == bridge_address)) | (oracles_address != my_addr) ) {\n       send_raw_message(msg', mode);\n    }\n    pending_queries~udict_set_builder(64, query_id, begin_cell().store_int(0, 1));\n    owner_infos~dec_flood(creator_i);\n  } else {\n    pending_queries~udict_set_builder(64, query_id, begin_cell()\n      .store_uint(1, 1)\n      .store_uint(creator_i, 8)\n      .store_uint(cnt, 8)\n      .store_uint(cnt_bits, n)\n      .store_slice(msg));\n  }\n  return (pending_queries, owner_infos);\n}\n\n(int, int) calc_boc_size(int cells, int bits, slice root) {\n  cells += 1;\n  bits += root.slice_bits();\n\n  while (root.slice_refs()) {\n    (cells, bits) = calc_boc_size(cells, bits, root~load_ref().begin_parse());\n  }\n\n  return (cells, bits);\n}\n\n() recv_internal(cell in_msg_cell, slice in_msg) impure {\n  ;; empty message triggers init\n  if (slice_empty?(in_msg)) {\n    return try_init();\n  }\n\n  ;; Check root signature\n  slice root_signature = in_msg~load_bits(512);\n  int root_hash = slice_hash(in_msg);\n  int root_i = in_msg~load_uint(8);\n\n  (int wallet_id, int n, int k, int last_cleaned, cell owner_infos, cell pending_queries, int spend_delay) = unpack_state();\n\n  throw_unless(38, now() > spend_delay);\n  last_cleaned -= last_cleaned == 0;\n\n  (slice owner_info, var found?) = owner_infos.udict_get?(8, root_i);\n  throw_unless(31, found?);\n  (int public_key, int flood) = unpack_owner_info(owner_info);\n  throw_unless(32, check_signature(root_hash, root_signature, public_key));\n\n  cell signatures = in_msg~load_dict();\n\n  var hash = slice_hash(in_msg);\n  int query_wallet_id = in_msg~load_uint(32);\n  throw_unless(42, query_wallet_id == wallet_id);\n\n  int query_id = in_msg~load_uint(64);\n\n  (int cnt, int bits) = calc_boc_size(0, 0, in_msg);\n  throw_if(40, (cnt > 8) | (bits > 2048));\n\n  (slice query, var found?) = pending_queries.udict_get?(64, query_id);\n\n  ifnot (found?) {\n    flood += 1;\n    throw_if(39, flood > 10);\n  }\n\n  var bound = (now() << 32);\n  throw_if(33, query_id < bound);\n\n  (int creator_i, int cnt, int cnt_bits, slice msg) = unpack_query_data(in_msg, n, query, found?, root_i);\n  int mask = 1 << root_i;\n  throw_if(34, cnt_bits & mask);\n  cnt_bits |= mask;\n  cnt += 1;\n\n  throw_if(41, ~ found? & (cnt < k) & (bound + ((60 * 60) << 32) > query_id));\n\n  ifnot (found?) {\n    owner_infos~udict_set_builder(8, root_i, pack_owner_info(public_key, flood));\n  }\n\n  (pending_queries, owner_infos) = update_pending_queries(pending_queries, owner_infos, msg, query_id, creator_i, cnt, cnt_bits, n, k);\n  set_data(pack_state(pending_queries, owner_infos, last_cleaned, k, n, wallet_id, spend_delay));\n\n  int need_save = 0;\n  ifnot (cell_null?(signatures) | (cnt >= k)) {\n    (int new_cnt, cnt_bits) = check_signatures(owner_infos, signatures, hash, cnt_bits);\n    cnt += new_cnt;\n    (pending_queries, owner_infos) = update_pending_queries(pending_queries, owner_infos, msg, query_id, creator_i, cnt, cnt_bits, n, k);\n    need_save = -1;\n  }\n\n  bound -= (64 << 32);   ;; clean up records expired more than 64 seconds ago\n  int old_last_cleaned = last_cleaned;\n  do {\n    var (pending_queries', i, query, f) = pending_queries.udict_delete_get_min(64);\n    f~touch();\n    if (f) {\n      f = (i < bound);\n    }\n    if (f) {\n      if (query~load_int(1)) {\n        owner_infos~dec_flood(query~load_uint(8));\n      }\n      pending_queries = pending_queries';\n      last_cleaned = i;\n      need_save = -1;\n    }\n  } until (~ f);\n\n  if (need_save) {\n    set_data(pack_state(pending_queries, owner_infos, last_cleaned, k, n, wallet_id, spend_delay));\n  }\n\n  var cs = in_msg_cell.begin_parse();\n  cs~skip_bits(4);\n  slice s_addr = cs~load_msg_addr();\n  var msg = begin_cell().store_uint(0x18, 6)\n                        .store_slice(s_addr)\n                        .store_grams(0)\n                        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .end_cell();\n  send_raw_message(msg, 64 + 2);\n}\n\n\n;; Get methods\n;; returns -1 for processed queries, 0 for unprocessed, 1 for unknown (forgotten)\n(int, int) get_query_state(int query_id) method_id {\n  (_, int n, _, int last_cleaned, _, cell pending_queries, _) = unpack_state();\n  (slice cs, var found) = pending_queries.udict_get?(64, query_id);\n  if (found) {\n    if (cs~load_int(1)) {\n      cs~load_uint(8 + 8);\n      return (0, cs~load_uint(n));\n    } else {\n      return (-1, 0);\n    }\n  }  else {\n    return (-(query_id <= last_cleaned), 0);\n  }\n}\n\nint processed?(int query_id) method_id {\n  (int x, _) = get_query_state(query_id);\n  return x;\n}\n\ncell create_init_state(int wallet_id, int n, int k, cell owners_info, int spend_delay) method_id {\n  return pack_state(new_dict(), owners_info, 0, k, n, wallet_id, spend_delay);\n}\n\ncell merge_list(cell a, cell b) {\n  if (cell_null?(a)) {\n    return b;\n  }\n  if (cell_null?(b)) {\n    return a;\n  }\n  slice as = a.begin_parse();\n  if (as.slice_refs() != 0) {\n    cell tail = merge_list(as~load_ref(), b);\n    return begin_cell().store_slice(as).store_ref(tail).end_cell();\n  }\n\n  as~skip_last_bits(1);\n  ;; as~skip_bits(1);\n  return begin_cell().store_slice(as).store_dict(b).end_cell();\n\n}\n\ncell get_public_keys() method_id {\n  (_, _, _, _, cell public_keys, _, _) = unpack_state();\n  return public_keys;\n}\n\n(int, int) check_query_signatures(cell query) method_id {\n  slice cs = query.begin_parse();\n  slice root_signature = cs~load_bits(512);\n  int root_hash = slice_hash(cs);\n  int root_i = cs~load_uint(8);\n\n  cell public_keys = get_public_keys();\n  (slice public_key, var found?) = public_keys.udict_get?(8, root_i);\n  throw_unless(31, found?);\n  throw_unless(32, check_signature(root_hash, root_signature, public_key.preload_uint(256)));\n\n  int mask = 1 << root_i;\n\n  cell signatures = cs~load_dict();\n  if (cell_null?(signatures)) {\n    return (1, mask);\n  }\n  (int cnt, mask) = check_signatures(public_keys, signatures, slice_hash(cs), mask);\n  return (cnt + 1, mask);\n}\n\nint message_signed_by_id?(int id, int query_id) method_id {\n  (_, int n, _, _, _, cell pending_queries, _) = unpack_state();\n  (var cs, var f) = pending_queries.udict_get?(64, query_id);\n  if (f) {\n    if (cs~load_int(1)) {\n      int cnt_bits = cs.skip_bits(8 + 8).preload_uint(n);\n      if (cnt_bits & (1 << id)) {\n        return -1;\n      }\n      return 0;\n    }\n    return -1;\n  }\n  return 0;\n}\n\ncell messages_by_mask(int mask) method_id {\n  (_, int n, _, _, _, cell pending_queries, _) = unpack_state();\n  int i = -1;\n  cell a = new_dict();\n  do {\n    (i, var cs, var f) = pending_queries.udict_get_next?(64, i);\n    if (f) {\n      if (cs~load_int(1)) {\n        int cnt_bits = cs.skip_bits(8 + 8).preload_uint(n);\n        if (cnt_bits & mask) {\n          a~udict_set_builder(64, i, begin_cell().store_slice(cs));\n        }\n      }\n    }\n  } until (~ f);\n  return a;\n}\n\ncell get_messages_unsigned_by_id(int id) method_id {\n  return messages_by_mask(1 << id);\n}\n\ncell get_messages_unsigned() method_id {\n  return messages_by_mask(~ 0);\n}\n\n(int, int) get_n_k() method_id {\n  (_, int n, int k, _, _, _, _) = unpack_state();\n  return (n, k);\n}\n\ncell merge_inner_queries(cell a, cell b) method_id {\n  slice ca = a.begin_parse();\n  slice cb = b.begin_parse();\n  cell list_a = ca~load_dict();\n  cell list_b = cb~load_dict();\n  throw_unless(31, slice_hash(ca) == slice_hash(cb));\n  return begin_cell()\n    .store_dict(merge_list(list_a, list_b))\n    .store_slice(ca)\n  .end_cell();\n}\n\nint get_lock_timeout() method_id {\n  (_, _, _, _, _, _, int spend_delay) = unpack_state();\n  return spend_delay;\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}