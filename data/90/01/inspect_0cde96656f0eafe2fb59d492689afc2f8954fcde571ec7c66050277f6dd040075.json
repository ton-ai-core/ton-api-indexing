{
  "code": "b5ee9c7201022301000882000114ff00f4a413f4bcf2c80b01020120020302014804050274f2db3cd31fd33f30018210f373ace5ba8ea28103f7f844c000f2f28103edf842c0fff2f28103f2f823f853b9f2f2f8587f58db3ce030840ff2f00f160202cc060703fba1c209b679b678a8e642470424a817c800a840282a41800126be06e1255309c4a8860641800126be06e1255309c4b3420343820322e122e3c5800126fff0edbdf0a1840129e01ff0d9bdf089f085f0a7f087f0b3f0b1f0a1f09ff09df09bf099f08bf0a3f08df0a9f0a5f095f097f0adf0aa2226223222262224223022250f180e0497d80e8698180b8d879207d20186d9e7c2ca9086382c78bb6117c216000474180ed9e474480e99ffd2018096d9e7170382981638060004f9881698f90e1804a9981699f89ef01ef10c08115dd40f081d09006dffc24c709fc287c275332403210600049af81b84954c271707c28410802faf080507c287c275332403210600049af81b84954c2715b04c015c318103e9f858d749c202f2f28103ea01d31f821005138d9112ba12f2f48040d721fa4030f87870f8627ff864db3c2003f88eee5b6c228103ecf842c0fff844c000b1f2f4f843c705f2e193d430d0d3078103f4228020b0f2f28102588103f5f823f85323a1bcf823f85324a0b9b0f2f2f851c3008e178103f5f823f85123a1bcf823f8515004a013b912b0f2f29130e2d43001fb00f842c3ff8e857ff862db3cdee0218210b820e9c2bae30221200a0b01923132338103edf823f853bef2f28103edf842c0fff2f28103f7f844c000f2f28103f002821005f5e100b912f2f28103f1f850c200f2f2f8585220c705f8435230c705b1f2e19301db3c1703f48210f373ace5ba8ed63132338103edf842c0fff2f28103f7f844c000f2f2f849c0ff9682100ee6b28096821005f5e100e28103f05033b912f2f28103f2f823f853b9f2f2f8585220c705f8435230c705b1f84f5230c705b1f2e1937001db3ce02182109af07447ba925f06e02182102bee0192bae30221c00022160c0d019a5b6c228103eef855c000f2f28103f1f850c200f2f2018308d71820f901f8554130f910f2a3f84a12c705f2e193fa4001f86ad1f84afa4430c000f2a470c8f84acf16f84bcf16cb00c9f877db3c20025a8210344ef025bab18e923132338103f9f849c000f2f454122020db3ce082107362d09c12bae3025f05840ff2f0131200581111111711111110111611100f11150f0e11140e0d11130d0c11120c0b11110b0d11100d10bf10de10cd10bc02eaf8416edded44d0d20001f862d20001f866fa4001f86ffa0001f870d31f01f871d31f01f873fa4001f878f858d749c202f864d33f01f872d401f867d401f868f848d0fa4001f863fa0001f86cfa0001f86dd30601f86ed31001f874fa4001f879d31f30f865d30070f87570f86901c001e30f7ff8611011007ad430f877f857d0fa4001f86afa4001f86bf84ad749c202f86970f876f84bd749c202f849c000b0937ff876ded30001c00198d3ff30f8757ff8769130e20018308b02f86a8b02f86b70f87603b221fa4430c000f2e1c402fa00fa4030f849c000f84a5240c705c000b18e8a6c338103f951217fdb3ce0543212ed41ed43ed44ed45ed478e863151217fdb3ced67ed65ed64ed63ed61737fed118e844034db3ced41edf101f2ff21211303f6f844c000975f058103f7f2f0e0f856c0ff975f058103f8f2f0e0f842c0fff823f853beb1975f058103edf2f0e0f853f823a18103f60182081a5e00bcf2f2f84d5230bef84dc200b0e302f853f854a1f823b997f853f854a0f873def8508e975b8103e8f84c5220b9f2f2f870f86ff823f871f872db3ce1f00f5230142015027a32f849c0ff9d8103f00182100ee6b280b9f2f28e108103f0f84d821005f5e100a012b9f2f2e2546220db3c20f86ff84df870f823f87121f8727058db3c1f160262b9975f058103e8f2f0e0f849c0ff9d8103f002820afaf080b912f2f29131e2546330db3c01f86ff870f823f871f872db3c1f2003e2f850c0008eaa01c0ff8e21f8276f22308103e8f849c0ff9682100ee6b28096821005f5e100e212b9f2f2f800de01db3ce0db3cf850f849c0008e23f8276f2230f849c0ff9682100ee6b28096821005f5e100e2a1b6088103f021c200f2f4de5420141520c000935f037092a984e25443031718190218f858db3c7ff8627ff866db3c1d200020f847d0fa40fa40d31fd31fd31fd31f3002fe20c000935f037092a984e25121a122a106c0ff8e5ef849c0008e32258103e8f849c0ff9682100ee6b28096821005f5e100e212b9f2f2f800f849c0ff9682100ee6b28096821005f5e100e216a18e22f8276f22308103e8f849c0ff9682100ee6b28096821005f5e100e212b9f2f2f80005e205de20c200923032e30d21c2001a1b010c54130427db3c1c04528e85543124db3c915be221c2008e88f85854102224db3c9131e2f84f12db3c7ff86270f866f823f8731c1c1d1e014cf849c0ff8e89f84a4414503371db3c8e145b708010c8cb055003cf1601fa02cb6ac972fb00e2210066702082105fcc3d14c8cb1f15cb3f58cf1658cf1612cb0071fa02cb00c9718018c8cb05f859cf1670fa02cb6accc9810082fb000104db3c20023af850c101925f03e0f849c0ff8e8d30f84af84ff85041040371db3ce30e2122005cf857f848f847f852f853f851f846f842c8ca00ca00f84fcf16f850fa02cb1fcb1ff858cf16cb3fccccf400c9ed5400b622c101925f06e07021c0ff935b707fde702082100f8a7ea5c8cb1f18cb3f5005fa025005cf1658cf1614ca0023fa02cb00c9718010c8cb055005cf162292337098820a625a005004a0e213fa0213cb6accc9019280429173e2fb0000dc6c21812ba170f836f85001a1218208989680a15210bc97308208989680a19131e220c2008e4570208018c8cb05f84fcf165003fa0212cb6acb1f8d0a165bdd5c88189a59081a185cc81899595b881bdd5d189a5908189e48185b9bdd1a195c881d5cd95ca0cf16c972fb009130e2",
  "code_hash": "ce5a78534eaaa6ceed8dafd486d076eb60a9b0d6dbfb53676f662649c0689956",
  "methods": [
    {
      "id": 123140,
      "method": "get_auction_data_v4"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\nint op::fix_price_v4_deploy_jetton() asm \"0xfb5dbf47 PUSHINT\";\nint op::fix_price_v4_deploy_blank() asm \"0x664c0905 PUSHINT\";\nint op::fix_price_v4_cancel() asm \"0x3 PUSHINT\";\nint op::fix_price_v4_change_price() asm \"0xfd135f7b PUSHINT\";\nint op::fix_price_v4_buy() asm \"0x2 PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";\n\nint jetton::transfer_notification() asm \"0x7362d09c PUSHINT\";\nint jetton::transfer() asm \"0xf8a7ea5 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "nft-auction-v4r1.func",
        "content": "#include \"./stdlib.fc\";\n#include \"op-codes.fc\";\n\n\n;; auction for jettons/tons\n;; see https://github.com/getgems-io/nft-contracts\n\n;;\n;;  custom TVM exit codes\n;;\n\nint exit::low_bid()             asm \"1000 PUSHINT\";\nint exit::auction_init()        asm \"1001 PUSHINT\";\nint exit::no_transfer()         asm \"1002 PUSHINT\";\nint exit::not_cancel()          asm \"1004 PUSHINT\";\nint exit::auction_end()         asm \"1005 PUSHINT\";\nint exit::already_activated()   asm \"1006 PUSHINT\";\nint exit::low_amount()          asm \"1008 PUSHINT\";\nint exit::cant_cancel_bid()     asm \"1009 PUSHINT\";\nint exit::cant_stop_time()      asm \"1010 PUSHINT\";\nint exit::bad_mode()            asm \"1012 PUSHINT\";\nint exit::last_bid_too_close()  asm \"1013 PUSHINT\";\nint exit::its_too_long_auc()     asm \"1014 PUSHINT\";\nint exit::not_activated_yet()   asm \"1015 PUSHINT\";\nint exit::broken_state()   asm \"1016 PUSHINT\";\nint exit::wrong_currency()   asm \"1017 PUSHINT\";\n\n\nconst int op::finish_acution = \"finish_auction\"c;\nconst int op::cancel_acution = \"cancel_auction\"c;\nconst int op::set_jetton_wallet = \"set_jetton_wallet\"c;\nconst int op::process_ton_bid = \"process_ton_bid\"c;\nconst int op::deploy_auction = \"deploy_auction\"c;\n\nconst int TON_FOR_NFT_PROCESS = 100000000; ;; 0.1 TON\nconst int TON_FOR_JETTON = 50000000; ;; 0.05 TON\nconst int TON_FOR_END_JETTON_AUC = TON_FOR_JETTON + TON_FOR_JETTON + TON_FOR_JETTON + TON_FOR_NFT_PROCESS;\nconst int TON_FOR_END_TON_AUC = TON_FOR_NFT_PROCESS;\n\nforall X -> int cast_to_int(X x) asm \"NOP\";\nslice null_addr() asm \"b{00} PUSHSLICE\";\nint get_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEE\";\n\n;;\n;;  persistant and runtime storage description\n;;\n\nglobal int      init?; ;; init_data safe check\nglobal int      end?; ;; end auction or not\nglobal slice    mp_addr; ;; the address of the marketplace from which the contract is deployed\nglobal int      activated?; ;; contract is activated by external message or by nft transfer\nglobal int      created_at?; ;; timestamp of created acution\nglobal int      is_canceled?; ;; auction was cancelled by owner\n\nglobal cell fees_cell;\nglobal cell constant_cell;\n\nglobal int      is_jetton_mode; ;;\nglobal slice    jetton_wallet; ;; jetton wallet address or null\nglobal slice    jetton_master; ;; jetton master address or null for detect jettons\nglobal int      min_bid; ;; minimal bid\nglobal int      max_bid; ;; maximum bid\nglobal int      min_step; ;; minimum step (can be 0)\nglobal slice    last_member; ;; last member address\nglobal int      last_bid; ;; last bid amount\nglobal int      last_bid_at; ;; timestamp of last bid\nglobal int      last_query_id; ;; last processed query id\nglobal int      end_time; ;; unix end time\nglobal int      step_time; ;; by how much the time increases with the new bid (e.g. 30)\nglobal int      public_key; ;; public key for jetton mode\nglobal int      is_broken_state; ;; broken state\nglobal cell     jt_cell;\n\n;; nft info cell (ref)\nglobal slice    nft_owner; ;; nft owner addres (should be sent nft if auction canceled or money from auction)\nglobal slice    nft_addr; ;; nft address\n\n;;\n;;  math utils\n;;\nint math::get_percent(int a, int percent, int factor) inline {\n    if (factor == 0) {\n        return 0;\n    } else {\n        return muldiv(a, percent, factor);\n    }\n}\n\nint math::check_profitable(int mp_fee_factor, int mp_fee_base, int royalty_fee_factor, int royalty_fee_base) inline {\n    int amount = 10000000000;\n    int mp_fee = math::get_percent(amount, mp_fee_factor, mp_fee_base);\n    int royalty_fee = math::get_percent(amount, royalty_fee_factor, royalty_fee_base);\n    int profit = amount - mp_fee - royalty_fee;\n    if (profit < 1) {\n        return 0;\n    }\n    return 1;\n}\n\n\n() send_jettons(slice jetton_wallet_address, int query_id, slice address, int amount, slice response_address, int fwd_amount) impure inline_ref {\n    if (amount <= 0) {\n        return ();\n    }\n\n    int should_carry_gas = false;\n    if (fwd_amount == -1) {\n        fwd_amount = 0;\n        should_carry_gas = true;\n    }\n\n    var msg_payload = begin_cell()\n        .store_uint(jetton::transfer(), 32) ;; transfer\n        .store_uint(query_id, 64)\n        .store_coins(amount)\n        .store_slice(address)\n        .store_slice(response_address)\n        .store_int(0, 1)\n        .store_coins(fwd_amount)\n        .store_uint(0, 1)\n        .end_cell();\n\n    var msg = begin_cell()\n        .store_uint(0x10, 6) ;; nobounce\n        .store_slice(jetton_wallet_address)\n        .store_coins(should_carry_gas ? 0 : (40000000 + fwd_amount)) ;; 0.04 TON or zero\n        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_ref(msg_payload)\n        .end_cell();\n\n    int flag = should_carry_gas ? (64 + 2) : (1 + 2);\n    send_raw_message(msg, flag);\n}\n\n() pack_data() impure inline_ref {\n    set_data(\n        begin_cell()\n            .store_int(end?, 1) ;;              1\n            .store_int(is_canceled?, 1) ;;      1\n            .store_slice(last_member) ;;            267 ($10 with Anycast = 0)\n            .store_coins(last_bid) ;;               127\n            .store_uint(last_bid_at, 32) ;;     32\n            .store_uint(end_time, 32) ;;        32\n            .store_slice(nft_owner) ;;              267\n            .store_uint(last_query_id, 64) ;;   64\n            .store_ref(fees_cell) ;; + ref\n            .store_ref(constant_cell) ;; + ref\n            .store_maybe_ref(jt_cell) ;; +1\n            .end_cell() ;; total 1+1+267+127+32+32+267+64+1 = 792\n    );\n}\n\n() init_data() impure inline_ref {- save for get methods -} {\n    ifnot (null?(init?)) {\n        return ();\n    }\n\n    slice ds = get_data().begin_parse();\n    end? = ds~load_int(1);\n    is_canceled? = ds~load_int(1);\n    last_member = ds~load_msg_addr();\n    last_bid = ds~load_coins();\n    last_bid_at = ds~load_uint(32);\n    end_time = ds~load_uint(32);\n    nft_owner = ds~load_msg_addr();\n    activated? = nft_owner.slice_bits() > 2;\n    last_query_id = ds~load_uint(64);\n\n    fees_cell = ds~load_ref();\n    constant_cell = ds~load_ref();\n    slice constants = constant_cell.begin_parse();\n    mp_addr = constants~load_msg_addr(); ;; 267\n    min_bid = constants~load_coins(); ;; 127\n    max_bid = constants~load_coins(); ;; 127\n    min_step = constants~load_uint(7); ;;7\n    step_time = constants~load_uint(17); ;;17\n    nft_addr = constants~load_msg_addr(); ;; 267\n    created_at? = constants~load_uint(32); ;; 32\n    ;; total 267+127+127+7+17+267+32=844\n\n    int has_jetton_data = ds~load_uint(1);\n    public_key = 0;\n    is_jetton_mode = false;\n    if (has_jetton_data == 1) {\n        jt_cell = ds~load_ref();\n        slice jt_slice = jt_cell.begin_parse();\n\n        jetton_wallet = jt_slice~load_msg_addr(); ;; 267\n        jetton_master = jt_slice~load_msg_addr(); ;; 267\n        is_jetton_mode = jetton_wallet.slice_bits() > 2;\n\n        is_broken_state = false;\n        if ((jetton_master.slice_bits() > 2) & (is_jetton_mode == false)) {\n            is_broken_state = true;\n        }\n\n        int has_public_key = jt_slice~load_uint(1);\n        if (has_public_key == 1) {\n            public_key = jt_slice~load_uint(256);\n            is_broken_state = true;\n        }\n    } else {\n        jetton_wallet = null_addr();\n        jetton_master = null_addr();\n        is_broken_state = false;\n    }\n\n\n\n\n    init? = true;\n}\n\n(slice, slice, int, int, int, int) get_fees_addresses() inline_ref {\n    slice fees = fees_cell.begin_parse();\n    slice mp_fee_addr = fees~load_msg_addr();\n    slice royalty_fee_addr = fees~load_msg_addr();\n    int mp_fee_factor = fees~load_uint(32);\n    int mp_fee_base = fees~load_uint(32);\n    int royalty_fee_factor = fees~load_uint(32);\n    int royalty_fee_base = fees~load_uint(32);\n    return (\n        mp_fee_addr,\n        royalty_fee_addr,\n        mp_fee_factor,\n        mp_fee_base,\n        royalty_fee_factor,\n        royalty_fee_base\n    );\n}\n\n{-\n    SHOULD\n    [+] check init auction or not\n    [+] check op\n    [+] change nft owner\n    [+] change auction status\n-}\n() handle::try_init_auction(slice sender_addr, slice in_msg_body) impure inline_ref {\n    throw_if(exit::auction_init(), nft_owner.slice_bits() > 2); ;; throw if auction already init\n    throw_unless(exit::no_transfer(), in_msg_body~load_uint(32) == op::ownership_assigned()); ;; throw if it`s not ownership assigned\n    in_msg_body~skip_bits(64); ;; query id\n    nft_owner = in_msg_body~load_msg_addr();\n    end? = false;\n    activated? = true;\n    pack_data();\n}\n\n() return_nft(int query_id, slice fee_pay_address, slice new_owner) impure inline_ref {\n    builder nft_transfer_body = begin_cell()\n        .store_uint(op::transfer(), 32)\n        .store_uint(query_id, 64) ;; query id\n        .store_slice(new_owner) ;; return nft no creator\n        .store_slice(fee_pay_address) ;; response_destination\n        .store_uint(0, 1) ;; custom payload\n        .store_coins(1) ;; forward amount\n        .store_uint(0, 1); ;; forward payload\n\n    builder nft_return_msg = begin_cell()\n        .store_uint(0x18, 6)\n        .store_slice(nft_addr)\n        .store_coins(0)\n        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n        .store_ref(nft_transfer_body.end_cell());\n\n    send_raw_message(nft_return_msg.end_cell(), 130);  ;; 128 +2 for ignoring errors\n}\n\n() handle::cancel(int query_id, slice sender_addr) impure inline_ref {\n    return_nft(query_id, sender_addr, nft_owner);\n    end? = true;\n    is_canceled? = true;\n    pack_data();\n}\n\n() send_founds(slice to_address, int amonut, int query_id, slice fee_pay_address) impure inline_ref {\n    if (is_jetton_mode == true) {\n        send_jettons(jetton_wallet, query_id, to_address, amonut, fee_pay_address, 1);\n    } else {\n        builder transfer = begin_cell()\n            .store_uint(0x10, 6) ;; 0 (int_msg_info) 1 (ihr_disabled) 1 (no bounces) 00 (address)\n            .store_slice(to_address)\n            .store_coins(amonut)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n\n        send_raw_message(transfer.end_cell(), 2);\n    }\n}\n\nint get_price_for_end_auction() inline {\n    if (is_jetton_mode == true) {\n        return TON_FOR_END_JETTON_AUC;\n    } else {\n        return TON_FOR_END_TON_AUC;\n    }\n}\n\n() check_ok_balance(int my_balance) impure inline {\n    throw_if(exit::low_bid(), my_balance < get_price_for_end_auction());\n    accept_message();\n}\n\n() handle::end_auction(slice sender_addr, int from_external, int query_id) impure inline_ref {\n    if (last_bid == 0) {\n        ;; just return nft\n\n        if (from_external == true) {\n            [int my_balance, _] = get_balance();\n            check_ok_balance(my_balance);\n        }\n\n        handle::cancel(query_id, sender_addr);\n        return ();\n    }\n\n    var (\n        mp_fee_addr,\n        royalty_fee_addr,\n        mp_fee_factor,\n        mp_fee_base,\n        royalty_fee_factor,\n        royalty_fee_base\n    ) = get_fees_addresses();\n\n    int last_bid_avaliable_profit = last_bid;\n    if (is_jetton_mode == false) {\n        [int my_balance, _] = get_balance();\n        last_bid_avaliable_profit = min(last_bid_avaliable_profit, (my_balance - get_price_for_end_auction()));\n        throw_unless(exit::low_amount(), last_bid_avaliable_profit > 0);\n    }\n\n\n    int mp_fee = math::get_percent(last_bid_avaliable_profit, mp_fee_factor, mp_fee_base);\n    int royalty_fee = math::get_percent(last_bid_avaliable_profit, royalty_fee_factor, royalty_fee_base);\n    int profit = last_bid_avaliable_profit - mp_fee - royalty_fee;\n\n    if (from_external == true) {\n        if (is_jetton_mode == false) {\n            check_ok_balance(profit);\n            profit = profit - get_price_for_end_auction();\n        } else {\n            [int my_balance, _] = get_balance();\n            check_ok_balance(my_balance);\n        }\n    }\n\n    if (mp_fee > 0) {\n        send_founds(mp_fee_addr, mp_fee, query_id, sender_addr);\n    }\n\n    if (royalty_fee > 0) {\n        send_founds(royalty_fee_addr, royalty_fee, query_id, sender_addr);\n    }\n\n    if (profit > 0) {\n        send_founds(nft_owner, profit, query_id, sender_addr);\n    }\n\n\n    return_nft(query_id, sender_addr, last_member);\n    end? = true;\n    is_canceled? = false;\n    end_time = now();\n    pack_data();\n}\n\n;;\n;;  main code\n;;\n\n() return_last_bid(int query_id, slice fee_pay_address, int my_balance) impure inline_ref {\n    if (last_bid <= 0) {\n        return ();\n    }\n    if (is_jetton_mode == true) {\n        send_jettons(jetton_wallet, query_id, last_member, last_bid, fee_pay_address, 1);\n    } else {\n        int magic_gas_price = get_compute_fee(false, 11169);\n        int return_bid_amount = last_bid - magic_gas_price;\n        if (return_bid_amount > (my_balance - 10000000)) {\n            ;; - 0.01 TON\n            return_bid_amount = my_balance - 10000000;\n        }\n        if (return_bid_amount > 0) {\n            builder return_prev_bid = begin_cell()\n                .store_uint(0x18, 6)\n                .store_slice(last_member)\n                .store_coins(return_bid_amount)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_uint(0, 32)\n                .store_slice(\"Your bid has been outbid by another user\");\n\n            send_raw_message(return_prev_bid.end_cell(), 2);\n        }\n    }\n}\n\nint get_next_min_bid() {\n    if (is_jetton_mode) {\n        return math::get_percent(last_bid, 100 + min_step, 100);\n    } else {\n        return max(\n            last_bid + 100000000, ;; 0.1 ton\n            math::get_percent(last_bid, 100 + min_step, 100)\n        );\n    }\n}\n\n() process_new_bid(int query_id, slice sender_addr, int bid_value, int ton_value, int my_balance) impure inline_ref {\n    if (activated? == false) {\n        throw(exit::not_activated_yet());\n        return ();\n    }\n\n    if (is_broken_state == true) {\n        throw(exit::broken_state());\n        return ();\n    }\n\n    if ((end? == true) | (now() >= end_time)) {\n        throw(exit::auction_end());\n        return ();\n    }\n\n    ;; auction large than 20 days not allowed\n    int duration = end_time - now();\n    throw_if(exit::its_too_long_auc(), duration > 60 * 60 * 24 * 20);\n\n    ;; max bid buy nft\n    if ((bid_value >= max_bid) & (max_bid > 0)) {\n        if (is_jetton_mode == true) {\n            throw_if(exit::low_amount(), ton_value < TON_FOR_END_JETTON_AUC);\n        } else {\n            throw_if(exit::low_amount(), ton_value < (max_bid + TON_FOR_END_TON_AUC));\n        }\n\n        return_last_bid(query_id, sender_addr, my_balance);\n        last_member = sender_addr;\n        last_bid = max_bid;\n        last_bid_at = now();\n        last_query_id = query_id;\n        handle::end_auction(sender_addr, false, query_id);\n        return ();\n    }\n\n    ;; prevent bid at last second\n    if ((end_time - step_time) < now()) {\n        end_time += step_time;\n    }\n\n    ifnot (last_bid) {\n        throw_if(exit::low_bid(), bid_value < min_bid);\n        last_bid = bid_value;\n        last_member = sender_addr;\n        last_bid_at = now();\n        last_query_id = query_id;\n        pack_data();\n        return ();\n    }\n\n    int new_min_bid = get_next_min_bid();\n    if (bid_value < new_min_bid) {\n        throw(exit::low_bid());\n        return ();\n    }\n\n    if (is_jetton_mode == true) {\n        throw_if(exit::low_amount(), ton_value < TON_FOR_JETTON);\n    }\n    return_last_bid(query_id, sender_addr, my_balance);\n\n    last_member = sender_addr;\n    last_bid = bid_value;\n    last_bid_at = now();\n    last_query_id = query_id;\n\n    pack_data();\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_cell, slice in_msg_body) impure {\n    slice cs = in_msg_cell.begin_parse();\n    throw_if(0, cs~load_uint(4) & 1);\n\n    slice sender_addr = cs~load_msg_addr();\n    init_data();\n\n    if (equal_slices(sender_addr, nft_addr)) {\n        if (end? == false) {\n            handle::try_init_auction(sender_addr, in_msg_body);\n        } else {\n            int query_id = in_msg_body~load_uint(64); ;; query id\n            slice old_nft_owner = in_msg_body~load_msg_addr();\n            return_nft(query_id, sender_addr, old_nft_owner);\n        }\n        return ();\n    }\n\n    int op = 0;\n    int query_id = 0;\n    if (slice_empty?(in_msg_body) == false) {\n        op = in_msg_body~load_uint(32);\n        if (op != 0) {\n            query_id = in_msg_body~load_uint(64);\n        }\n    }\n\n\n    if (op == 555) {\n        throw_unless(exit::not_cancel(), ((end? == true) | (activated? == false)));\n        throw_unless(403, equal_slices(sender_addr, mp_addr));\n        ;; way to fix unexpected troubles with auction contract\n        ;; for example if some one transfer nft to this contract\n        var msg = in_msg_body~load_ref().begin_parse();\n        var mode = msg~load_uint(8);\n        throw_if(exit::bad_mode(), mode & 32);\n\n        int ten_min = 10 * 60;\n        throw_if(exit::last_bid_too_close(), (now() > (end_time - ten_min)) & (now() < (end_time + ten_min)));\n        if (last_bid_at != 0) {\n            throw_if(exit::last_bid_too_close(), (now() > (last_bid_at - ten_min)) & (now() < (last_bid_at + ten_min)));\n        }\n\n        send_raw_message(msg~load_ref(), mode);\n        if (end? != true) {\n            end? = true;\n            pack_data();\n        }\n        return ();\n    }\n\n    if (op == op::cancel_acution) {\n        ;; cancel command, return nft if no bid yet\n        throw_if(exit::auction_end(), now() >= end_time); ;; after timeout can't cancel\n        throw_if(exit::auction_end(), end? == true); ;; already canceled/ended\n        throw_if(exit::not_activated_yet(), activated? == false);\n        throw_if(exit::low_amount(), msg_value < TON_FOR_NFT_PROCESS);\n        throw_if(exit::cant_cancel_bid(), last_bid > 0); ;; can't cancel if someone already placed a bid\n        throw_unless(403, equal_slices(sender_addr, nft_owner) | equal_slices(sender_addr, mp_addr));\n        handle::cancel(query_id, sender_addr);\n        return ();\n    }\n\n    if (op == op::finish_acution) {\n        ;; stop auction\n        throw_if(exit::auction_end(), end? == true); ;; end = true mean this action already executed\n        throw_if(exit::not_activated_yet(), activated? == false);\n        int price_for_end = get_price_for_end_auction();\n        throw_if(exit::low_amount(), msg_value < price_for_end);\n        throw_if(exit::cant_stop_time(), now() < end_time); ;; can't end auction in progress, only after end time\n        throw_unless(403, equal_slices(sender_addr, nft_owner) | equal_slices(sender_addr, mp_addr) | equal_slices(sender_addr, last_member));\n        handle::end_auction(sender_addr, false, query_id);\n        return ();\n    }\n\n    if (op == op::deploy_auction) {\n        ;; just accept coins\n        return ();\n    }\n\n    if (op == op::set_jetton_wallet) {\n        throw_if(exit::already_activated(), public_key == 0);\n        throw_if(exit::cant_cancel_bid(), last_bid > 0);\n\n        var signature = in_msg_body~load_bits(512);\n        var payload = slice_hash(in_msg_body);\n        throw_unless(35, check_signature(payload, signature, public_key));\n        ;; check than update from expected address\n        throw_unless(403, equal_slices(sender_addr, jetton_wallet));\n\n        jetton_wallet = in_msg_body~load_msg_addr();\n        in_msg_body.end_parse();\n        var (wc, hash) = parse_std_addr(jetton_wallet);\n        throw_unless(36, wc == 0);\n\n        jt_cell = begin_cell()\n            .store_slice(jetton_wallet)\n            .store_slice(jetton_master)\n            .store_uint(0, 1)\n            .end_cell();\n\n        pack_data();\n        return ();\n    }\n\n    ;; bid process\n\n    if ((op == 0) | (op == op::process_ton_bid)) {\n        throw_unless(exit::wrong_currency(), is_jetton_mode == false);\n        process_new_bid(query_id, sender_addr, msg_value, msg_value, msg_value);\n        return ();\n    }\n\n    if (op == jetton::transfer_notification()) {\n        var (wc, addr_hash) = parse_std_addr(sender_addr);\n\n        ;; check workchain\n        throw_unless(452, wc == 0);\n\n        ;; load amount\n        var jetton_amount = in_msg_body~load_coins();\n        var buyer_address = in_msg_body~load_msg_addr();\n\n        if ((is_jetton_mode == false) | (equal_slices(sender_addr, jetton_wallet) == false)) {\n            send_jettons(sender_addr, exit::wrong_currency(), buyer_address, jetton_amount, buyer_address, -1);\n            return ();\n        }\n\n        try {\n            process_new_bid(query_id, buyer_address, jetton_amount, msg_value, my_balance);\n        }  catch (__, error_code) {\n            send_jettons(sender_addr, error_code, buyer_address, jetton_amount, buyer_address, -1);\n        }\n\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n() recv_external(slice in_msg) impure {\n    init_data();\n\n    int op = in_msg~load_uint(32);\n    int query_id = in_msg~load_uint(64);\n\n    if (op == op::finish_acution) {\n        throw_if(exit::not_activated_yet(), activated? == false);\n        throw_if(exit::auction_end(), end? == true); ;; end = true mean this action already executed\n        throw_if(exit::cant_stop_time(), now() < end_time); ;; can't end auction in progress, only after end time\n        handle::end_auction(nft_owner, true, query_id);\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int, int, int, slice, slice, int, int) get_auction_data_v4() method_id {\n    init_data();\n\n    var (\n        mp_fee_addr,\n        royalty_fee_addr,\n        mp_fee_factor,\n        mp_fee_base,\n        royalty_fee_factor,\n        royalty_fee_base\n    ) = get_fees_addresses();\n\n    var profitable = math::check_profitable(mp_fee_factor, mp_fee_base, royalty_fee_factor, royalty_fee_base);\n    if (profitable == 0) {\n        is_broken_state = true;\n    }\n\n    if (last_bid > 0) {\n        min_bid = get_next_min_bid();\n    }\n\n    return (\n        activated?, ;;1\n        end?, ;; 2\n        end_time, ;; 3\n        mp_addr, ;; 4\n        nft_addr, ;; 5\n        nft_owner, ;; 6\n        last_bid, ;; 7\n        last_member, ;; 8\n        min_step, ;; 9 min step\n        mp_fee_addr, ;; 10\n        mp_fee_factor, mp_fee_base, ;; 11, 12\n        royalty_fee_addr, ;; 13\n        royalty_fee_factor, royalty_fee_base, ;; 14, 15\n        max_bid, ;; 16\n        min_bid, ;; 17\n        created_at?, ;; 18\n        last_bid_at, ;; 19\n        is_canceled?, ;; 20\n        step_time, ;; 21\n        last_query_id, ;; 22\n        jetton_wallet, ;; 23\n        jetton_master, ;; 24\n        is_broken_state, ;; 25\n        public_key ;; 26\n    );\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}