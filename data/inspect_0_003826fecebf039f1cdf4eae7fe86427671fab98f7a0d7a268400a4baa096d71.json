{
  "code": "b5ee9c7201020b010001ed000114ff00f4a413f4bcf2c80b0102016202030202cc040502037a60090a03efd9910e38048adf068698180b8d848adf07d201800e98fe99ff6a2687d007d206a6a18400aa9385d47181a9aa8aae382f9702480fd207d006a18106840306b90fd001812881a28217804502a906428027d012c678b666664f6aa7041083deecbef29385d71811a92e001f1811802600271812f82c207f97840607080093dfc142201b82a1009aa0a01e428027d012c678b00e78b666491646580897a007a00658064907c80383a6465816503e5ffe4e83bc00c646582ac678b28027d0109e5b589666664b8fd80400fe3603fa00fa40f82854120870542013541403c85004fa0258cf1601cf16ccc922c8cb0112f400f400cb00c9f9007074c8cb02ca07cbffc9d05008c705f2e04a12a1035024c85004fa0258cf16ccccc9ed5401fa403020d70b01c3008e1f8210d53276db708010c8cb055003cf1622fa0212cb6acb1fcb3fc98042fb00915be200303515c705f2e049fa403059c85004fa0258cf16ccccc9ed54002e5143c705f2e049d43001c85004fa0258cf16ccccc9ed54007dadbcf6a2687d007d206a6a183618fc1400b82a1009aa0a01e428027d012c678b00e78b666491646580897a007a00658064fc80383a6465816503e5ffe4e840001faf16f6a2687d007d206a6a183faa9040",
  "disassembled_code": "0 SETCP\n19 (xC_) DICTPUSHCONST\nDICTIGETJMPZ {\n      0 => <{\n            s2 POP\n            OVER\n            SEMPTY\n            IFJMP:<{\n                  2DROP\n            }>\n            CTOS\n            4 LDU\n            SWAP\n            1 PUSHINT\n            AND\n            IFJMP:<{\n                  2DROP\n            }>\n            LDMSGADDR\n            DROP\n            SWAP\n            32 LDU\n            64 LDU\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            21 PUSHINT\n            s7 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s5 POP\n                  s5 POP\n                  s5 s5 XCPU\n                  SDEQ\n                  73 THROWIFNOT\n                  SWAP\n                  LDMSGADDR\n                  LDGRAMS\n                  LDREF\n                  DROP\n                  DUP\n                  CTOS\n                  96 PUSHINT\n                  SDSKIPFIRST\n                  LDGRAMS\n                  DROP\n                  s5 PUSH\n                  s3 s4 XCHG\n                  s4 s2 XCHG2\n                  8 CALLDICT\n                  ADD\n                  3 1 BLKSWAP\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            2078119902 PUSHINT\n            s7 s(-1) PUXC\n            EQUAL\n            IFJMP:<{\n                  s6 POP\n                  s0 s3 XCHG\n                  LDGRAMS\n                  LDMSGADDR\n                  MYADDR\n                  s2 s0 s8 XC2PU\n                  0 PUSHINT\n                  s0 s1 s2 XCPUXC\n                  s4 s0 s3 XC2PU\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  SWAP\n                  STSLICER\n                  STREF\n                  ENDC\n                  s2 PUSH\n                  NEWC\n                  2 STU\n                  s1 s2 XCHG\n                  STDICT\n                  STDICT\n                  1 STU\n                  ENDC\n                  HASHCU\n                  0 PUSHINT\n                  4 PUSHINT\n                  NEWC\n                  3 STU\n                  8 STI\n                  256 STU\n                  ENDC\n                  CTOS\n                  s0 s8 XCHG2\n                  SDEQ\n                  74 THROWIFNOT\n                  s1 s2 XCHG\n                  SUB\n                  s0 s3 XCHG\n                  s2 s4 XCHG2\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n                  SWAP\n                  LDMSGADDR\n                  DROP\n                  DUP\n                  2 PLDU\n                  0 NEQINT\n                  IF:<{\n                        3576854235 PUSHINT\n                        0 PUSHINT\n                        16 PUSHINT\n                        NEWC\n                        6 STU\n                        s0 s3 XCHG2\n                        STSLICER\n                        s2 PUSH\n                        STGRAMS\n                        s1 s2 XCHG\n                        107 STU\n                        32 STU\n                        64 STU\n                        ENDC\n                        66 PUSHINT\n                        SENDRAWMSG\n                  }>ELSE<{\n                        2DROP\n                  }>\n            }>\n            s5 POP\n            s5 PUSH\n            3 EQINT\n            IFJMP:<{\n                  s5 POP\n                  s1 s5 XCHG\n                  SDEQ\n                  73 THROWIFNOT\n                  LDMSGADDR\n                  DROP\n                  ROTREV\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            DROP\n            s0 s4 XCHG\n            4 EQINT\n            IFJMP:<{\n                  s4 s3 XCPU\n                  SDEQ\n                  73 THROWIFNOT\n                  LDREF\n                  DROP\n                  SWAP\n                  NEWC\n                  s0 s4 XCHG2\n                  STGRAMS\n                  ROT\n                  STSLICER\n                  STREF\n                  STREF\n                  ENDC\n                  c4 POP\n            }>\n            5 BLKDROP\n            16 PUSHPOW2DEC\n            THROWANY\n      }>\n      8 => <{\n            MYADDR\n            s4 s0 s3 XCHG3\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            DUP\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n            7 PUSHINT\n            24 PUSHINT\n            NEWC\n            6 STU\n            ROT\n            STSLICER\n            s0 s4 XCHG2\n            STGRAMS\n            s1 s3 XCHG\n            108 STU\n            s1 s2 XCHG\n            STREF\n            STREF\n            ENDC\n            1 PUSHINT\n            SENDRAWMSG\n      }>\n      103289 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            3 1 BLKDROP2\n            MYADDR\n            SWAP\n            0 PUSHINT\n            s0 s1 s2 XCPUXC\n            s4 s0 s3 XC2PU\n            NEWC\n            s0 s4 XCHG2\n            STGRAMS\n            ROT\n            STSLICER\n            SWAP\n            STSLICER\n            STREF\n            ENDC\n            s2 PUSH\n            NEWC\n            2 STU\n            s1 s2 XCHG\n            STDICT\n            STDICT\n            1 STU\n            ENDC\n            HASHCU\n            0 PUSHINT\n            4 PUSHINT\n            NEWC\n            3 STU\n            8 STI\n            256 STU\n            ENDC\n            CTOS\n      }>\n      106029 => <{\n            c4 PUSH\n            CTOS\n            LDGRAMS\n            LDMSGADDR\n            LDREF\n            LDREF\n            DROP\n            -1 PUSHINT\n            3 1 BLKSWAP\n      }>\n}\n11 THROWARG",
  "code_hash": "f95ba0330b38cdf3459b1e811e5fc6fa6cfee566d7b764455c0468140365a737",
  "methods": [
    {
      "id": 103289,
      "method": "get_wallet_address"
    },
    {
      "id": 106029,
      "method": "get_jetton_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0xf8a7ea5 PUSHINT\";\r\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\r\nint op::internal_transfer() asm \"0x178d4519 PUSHINT\";\r\nint op::excesses() asm \"0xd53276db PUSHINT\";\r\nint op::burn() asm \"0x595f07bc PUSHINT\";\r\nint op::burn_notification() asm \"0x7bdd97de PUSHINT\";\r\n\r\n;; Minter\r\nint op::mint() asm \"21 PUSHINT\";\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\r\n;;\r\n\r\n{-\r\n    This file is part of TON FunC Standard Library.\r\n\r\n    FunC Standard Library is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU Lesser General Public License as published by\r\n    the Free Software Foundation, either version 2 of the License, or\r\n    (at your option) any later version.\r\n\r\n    FunC Standard Library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU Lesser General Public License for more details.\r\n\r\n-}\r\n\r\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\r\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\r\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\r\nforall X -> X car(tuple list) asm \"CAR\";\r\ntuple cdr(tuple list) asm \"CDR\";\r\ntuple empty_tuple() asm \"NIL\";\r\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> [X] single(X x) asm \"SINGLE\";\r\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\r\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\r\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\r\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\r\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\r\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\r\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\r\nforall X -> X first(tuple t) asm \"FIRST\";\r\nforall X -> X second(tuple t) asm \"SECOND\";\r\nforall X -> X third(tuple t) asm \"THIRD\";\r\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\r\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\r\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\r\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\r\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\r\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\r\nforall X -> X null() asm \"PUSHNULL\";\r\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\r\n\r\nint now() asm \"NOW\";\r\nslice my_address() asm \"MYADDR\";\r\n[int, cell] get_balance() asm \"BALANCE\";\r\nint cur_lt() asm \"LTIME\";\r\nint block_lt() asm \"BLOCKLT\";\r\n\r\nint cell_hash(cell c) asm \"HASHCU\";\r\nint slice_hash(slice s) asm \"HASHSU\";\r\nint string_hash(slice s) asm \"SHA256U\";\r\n\r\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\r\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\r\n\r\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\r\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\r\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n\r\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\r\n\r\n() dump_stack() impure asm \"DUMPSTK\";\r\n\r\ncell get_data() asm \"c4 PUSH\";\r\n() set_data(cell c) impure asm \"c4 POP\";\r\ncont get_c3() impure asm \"c3 PUSH\";\r\n() set_c3(cont c) impure asm \"c3 POP\";\r\ncont bless(slice s) impure asm \"BLESS\";\r\n\r\n() accept_message() impure asm \"ACCEPT\";\r\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\r\n() commit() impure asm \"COMMIT\";\r\n() buy_gas(int gram) impure asm \"BUYGAS\";\r\n\r\nint min(int x, int y) asm \"MIN\";\r\nint max(int x, int y) asm \"MAX\";\r\n(int, int) minmax(int x, int y) asm \"MINMAX\";\r\nint abs(int x) asm \"ABS\";\r\n\r\nslice begin_parse(cell c) asm \"CTOS\";\r\n() end_parse(slice s) impure asm \"ENDS\";\r\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\r\ncell preload_ref(slice s) asm \"PLDREF\";\r\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\r\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\r\n;; int preload_int(slice s, int len) asm \"PLDIX\";\r\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\r\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\r\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\r\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\r\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\r\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\r\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\r\ncell preload_dict(slice s) asm \"PLDDICT\";\r\nslice skip_dict(slice s) asm \"SKIPDICT\";\r\n\r\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\r\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\r\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\r\n\r\nint cell_depth(cell c) asm \"CDEPTH\";\r\n\r\nint slice_refs(slice s) asm \"SREFS\";\r\nint slice_bits(slice s) asm \"SBITS\";\r\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\r\nint slice_empty?(slice s) asm \"SEMPTY\";\r\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\r\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\r\nint slice_depth(slice s) asm \"SDEPTH\";\r\n\r\nint builder_refs(builder b) asm \"BREFS\";\r\nint builder_bits(builder b) asm \"BBITS\";\r\nint builder_depth(builder b) asm \"BDEPTH\";\r\n\r\nbuilder begin_cell() asm \"NEWC\";\r\ncell end_cell(builder b) asm \"ENDC\";\r\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\r\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\r\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\r\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\r\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\r\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\r\n\r\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\r\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\r\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\r\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\r\n\r\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\r\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\r\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\r\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\r\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\r\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\r\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\r\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\r\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\r\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\r\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\r\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\r\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\r\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\r\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\r\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\r\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\ncell new_dict() asm \"NEWDICT\";\r\nint dict_empty?(cell c) asm \"DICTEMPTY\";\r\n\r\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\r\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\r\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\r\n\r\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\r\nint cell_null?(cell c) asm \"ISNULL\";\r\n\r\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\r\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\r\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\r\n() set_code(cell new_code) impure asm \"SETCODE\";\r\n\r\nint random() impure asm \"RANDU256\";\r\nint rand(int range) impure asm \"RAND\";\r\nint get_seed() impure asm \"RANDSEED\";\r\nint set_seed() impure asm \"SETRAND\";\r\n() randomize(int x) impure asm \"ADDRAND\";\r\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\r\n\r\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\r\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\r\n\r\nint equal_slices (slice a, slice b) asm \"SDEQ\";\r\nint builder_null?(builder b) asm \"ISNULL\";\r\nbuilder store_builder(builder to, builder from) asm \"STBR\";\r\n\r\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "jetton-minter.fc",
        "content": "#include \"imports/stdlib.fc\";\r\n#include \"jetton-utils.fc\"; \r\n#include \"params.fc\"; \r\n#include \"op-codes.fc\"; \r\n\r\n\r\n(int, slice, cell, cell) load_data() inline {\r\n  slice ds = get_data().begin_parse();\r\n  return (\r\n      ds~load_coins(), ;; total_supply\r\n      ds~load_msg_addr(), ;; admin_address\r\n      ds~load_ref(), ;; content\r\n      ds~load_ref()  ;; jetton_wallet_code\r\n  );\r\n}\r\n\r\n() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {\r\n  set_data(begin_cell()\r\n            .store_coins(total_supply)\r\n            .store_slice(admin_address)\r\n            .store_ref(content)\r\n            .store_ref(jetton_wallet_code)\r\n           .end_cell()\r\n          );\r\n}\r\n\r\n() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {\r\n  cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);\r\n  slice to_wallet_address = calculate_jetton_wallet_address(state_init);\r\n  var msg = begin_cell()\r\n    .store_uint(0x18, 6)\r\n    .store_slice(to_wallet_address)\r\n    .store_coins(amount)\r\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\r\n    .store_ref(state_init)\r\n    .store_ref(master_msg);\r\n  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\r\n}\r\n\r\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\r\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\r\n        return ();\r\n    }\r\n    slice cs = in_msg_full.begin_parse();\r\n    int flags = cs~load_uint(4);\r\n\r\n    if (flags & 1) { ;; ignore all bounced messages\r\n        return ();\r\n    }\r\n    slice sender_address = cs~load_msg_addr();\r\n  \r\n    int op = in_msg_body~load_uint(32);\r\n    int query_id = in_msg_body~load_uint(64);\r\n\r\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\r\n\r\n    if (op == op::mint()) {\r\n        throw_unless(73, equal_slices(sender_address, admin_address));\r\n        slice to_address = in_msg_body~load_msg_addr();\r\n        int amount = in_msg_body~load_coins();\r\n        cell master_msg = in_msg_body~load_ref();\r\n        slice master_msg_cs = master_msg.begin_parse();\r\n        master_msg_cs~skip_bits(32 + 64); ;; op + query_id\r\n        int jetton_amount = master_msg_cs~load_coins();\r\n        mint_tokens(to_address, jetton_wallet_code, amount, master_msg);\r\n        save_data(total_supply + jetton_amount, admin_address, content, jetton_wallet_code);\r\n        return ();\r\n    }\r\n\r\n    if (op == op::burn_notification()) {\r\n        int jetton_amount = in_msg_body~load_coins();\r\n        slice from_address = in_msg_body~load_msg_addr();\r\n        throw_unless(74,\r\n            equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address)\r\n        );\r\n        save_data(total_supply - jetton_amount, admin_address, content, jetton_wallet_code);\r\n        slice response_address = in_msg_body~load_msg_addr();\r\n        if (response_address.preload_uint(2) != 0) {\r\n          var msg = begin_cell()\r\n            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\r\n            .store_slice(response_address)\r\n            .store_coins(0)\r\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n            .store_uint(op::excesses(), 32)\r\n            .store_uint(query_id, 64);\r\n          send_raw_message(msg.end_cell(), 2 + 64);\r\n        }\r\n        return ();\r\n    }\r\n\r\n    if (op == 3) { ;; change admin\r\n        throw_unless(73, equal_slices(sender_address, admin_address));\r\n        slice new_admin_address = in_msg_body~load_msg_addr();\r\n        save_data(total_supply, new_admin_address, content, jetton_wallet_code);\r\n        return ();\r\n    }\r\n\r\n    if (op == 4) { ;; change content, delete this for immutable tokens\r\n        throw_unless(73, equal_slices(sender_address, admin_address));\r\n        save_data(total_supply, admin_address, in_msg_body~load_ref(), jetton_wallet_code);\r\n        return ();\r\n    }\r\n\r\n    throw(0xffff);\r\n}\r\n\r\n(int, int, slice, cell, cell) get_jetton_data() method_id {\r\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\r\n    return (total_supply, -1, admin_address, content, jetton_wallet_code);\r\n}\r\n\r\nslice get_wallet_address(slice owner_address) method_id {\r\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\r\n    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);\r\n}\r\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "jetton-utils.fc",
        "content": "#include \"params.fc\"; \r\n\r\n\r\ncell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\r\n   return  begin_cell()\r\n            .store_coins(balance)\r\n            .store_slice(owner_address)\r\n            .store_slice(jetton_master_address)\r\n            .store_ref(jetton_wallet_code)\r\n           .end_cell();\r\n}\r\n\r\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\r\n  return begin_cell()\r\n          .store_uint(0, 2)\r\n          .store_dict(jetton_wallet_code)\r\n          .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\r\n          .store_uint(0, 1)\r\n         .end_cell();\r\n}\r\n\r\nslice calculate_jetton_wallet_address(cell state_init) inline {\r\n  return begin_cell().store_uint(4, 3)\r\n                     .store_int(workchain(), 8)\r\n                     .store_uint(cell_hash(state_init), 256)\r\n                     .end_cell()\r\n                     .begin_parse();\r\n}\r\n\r\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\r\n  return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\r\n}\r\n\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\r\n\r\n() force_chain(slice addr) impure {\r\n  (int wc, _) = parse_std_addr(addr);\r\n  throw_unless(333, wc == workchain());\r\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}