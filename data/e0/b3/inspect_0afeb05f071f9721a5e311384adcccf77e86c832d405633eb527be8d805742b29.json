{
  "code": "b5ee9c7201021501000447000114ff00f4a413f4bcf2c80b01020120020302014804050156f2ed44d0d300d31fd31ffa40fa40fa40fa00d4d300303007c001f2d194f82325bee3025f088200fffef2f0140202cc06070083a1461fda89a1a601a63fa63ff481f481f481f401a9a6006061a1f481a63fa63ff481a63fa63e60a8ec21e006a8eea9e006a50542034304309e8c8c8aa41d8002ab81020148080901f7db61111687d20698fe98ffd20698fe98f9814acf801aa2421f801a9b85091d0c5b283937b334ba413acb8104008646582a802e78b2801fd0109e5b5658f80e78b64b8fd80116100116ba4e101584712c5ba937bcb0b63a3cc09b8104008646582a802e78b2801fd0109e5b5658f80e78b64b8fd80493610f11061004120201200a0b020120101101f7007434c0c05c6c2497c1383e900c3b513434c034c7f4c7fe903e903e903e803534c00c300063894c4dcdce154cc49c023232c005f2c7c572c7d400f3c58073c58073c5807e80b332c0327b55381fcab1c0700023868c0274c7c8700022d98d85b98d95b2148831c16c249cccb7942ab78820408aee8a70006c14e9a00c001320840ee6b280006a612002d0c705b09e10ac5f0cd430d0d307d43001fb00e0821005138d915210bae3023c27c001f2d1942bc0005393c705b08e2b3838395076a0103746504403027008c8cb0017cb1f15cb1f5003cf1601cf1601cf1601fa02cccb00c9ed54e0373909c003e3025f09840ff2f00d0e00c63009d33ffa40305394c70509c00019b02b82103b9aca00beb09e38105a104910384715034464f0088e38395f063333702082105fcc3d14c8cb1f13cb3f23cf165003cf16ca0021fa02ca00c9718018c8cb055003cf1670fa0212cb6accc98040fb00e201ac5358c7055362c705b1f2e1ca82080f424070fb025151c7058e1435708010c8cb0528cf1621fa02cb6ac98306fb00e30d71471750660504037008c8cb0017cb1f15cb1f5003cf1601cf1601cf1601fa02cccb00c9ed540f00b605fa002182101dcd6500bc9782101dcd650032de8d0413d999995c8818d85b98d95b081999596054473370208010c8cb055005cf165003fa0213cb6acb1f01cf16c971fb00d430718010c8cb0529cf1670fa02cb6accc98306fb00001120840ee6b2802a6120001d08300024d7c0dc38167c00807c006001e28e2c8bf4d61726b6574706c61636520666565870208010c8cb055005cf165003fa0213cb6acb1f01cf16c971fb00915be2702082105fcc3d14c8cb1f13cb3f26cf165003cf16ca008208989680fa02ca00c9718018c8cb0526cf1670fa02cb6acc82080f424070fb02c98306fb0071556013003c7008c8cb0017cb1f15cb1f5003cf1601cf1601cf1601fa02cccb00c9ed5400ce07d31f810fa302c30012f2f2810fa421d74ac300f2f2810fa521d7498101f4bcf2f2f80082080f424070fb0270208010c8cb0524cf1621fa02cb6acb1f01cf16c98306fb00710755057008c8cb0017cb1f15cb1f5003cf1601cf1601cf1601fa02cccb00c9ed54",
  "code_hash": "cb98a1f42ebea2ad491e518038e01bc8a73927c762cd55db7f9c29c611d04140",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "nft-offer-v1r2.fc",
        "content": ";; NFT offer contract v1r2\n;; mark outgoing transactions Marketplace fee,Royalty,Profit\n\nslice msg::cancel() asm \"<b 124 word cancel| $, b> <s PUSHSLICE\";\nslice msg::profit() asm \"<b 124 word Profit| $, b> <s PUSHSLICE\";\nslice msg::royalties() asm \"<b 124 word Royalty| $, b> <s PUSHSLICE\";\nslice msg::fee() asm \"<b 124 word Marketplace fee| $, b> <s PUSHSLICE\";\nslice msg::cancel_fee() asm \"<b 124 word Offer cancel fee| $, b> <s PUSHSLICE\";\n\nint division(int a, int b) { ;; division with factor\n    return muldiv(a, 1000000000 {- 1e9 -}, b);\n}\n\nint multiply(int a, int b) { ;; multiply with factor\n    return muldiv (a, b, 1000000000 {- 1e9 -});\n}\n\nint get_percent(int a, int percent, int factor) {\n    if (factor == 0) {\n        return 0;\n    } else {\n        return division(multiply(a, percent), factor);\n    }\n}\n\n_ load_data() inline {\n    var ds = get_data().begin_parse();\n    return (\n            ds~load_uint(1),    ;; is_complete 1\n            ds~load_uint(32),   ;; created_at 32\n            ds~load_uint(32),   ;; finish_at 32\n            ds~load_msg_addr(), ;; marketplace_address  267\n            ds~load_msg_addr(), ;; nft_address 267\n            ds~load_msg_addr(), ;; offer_owner_address 267\n            ds~load_coins(),    ;; full_price 127\n            ds~load_ref(),      ;; fees_cell\n            ds~load_uint(1)     ;; can_deploy\n    );\n}\n\n_ load_fees(cell fees_cell) inline {\n    var ds = fees_cell.begin_parse();\n    return (\n            ds~load_msg_addr(), ;; marketplace_fee_address\n            ds~load_uint(32),    ;; marketplace_factor,\n            ds~load_uint(32),    ;; marketplace_base,\n            ds~load_msg_addr(), ;; royalty_address\n            ds~load_uint(32),    ;; royalty_factor,\n            ds~load_uint(32)    ;; royalty_base,\n    );\n}\n\n() save_data(int is_complete, int created_at, int finish_at, slice marketplace_address, slice nft_address, slice offer_owner_address, int full_price, cell fees_cell) impure inline {\n    set_data(\n            begin_cell()\n                    .store_uint(is_complete, 1)\n                    .store_uint(created_at, 32)\n                    .store_uint(finish_at, 32)\n                    .store_slice(marketplace_address)\n                    .store_slice(nft_address)\n                    .store_slice(offer_owner_address)\n                    .store_coins(full_price)\n                    .store_ref(fees_cell)\n                    .store_uint(0, 1) ;; can_deploy\n                    .end_cell()\n    );\n}\n\n() send_money(slice address, int amount, slice msg) impure inline {\n    var msg = begin_cell()\n            .store_uint(0x10, 6) ;; nobounce\n            .store_slice(address)\n            .store_coins(amount)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(0, 32)\n            .store_slice(msg)\n            .end_cell();\n\n    send_raw_message(msg, 1);\n}\n\n() swap_nft(var args) impure {\n\n    (\n            int created_at,\n            int finish_at,\n            slice marketplace_address,\n            slice nft_address,\n            slice offer_owner_address,\n            int full_price,\n            cell fees_cell,\n\n            int my_balance,\n            int msg_value,\n            slice nft_owner_address,\n            int query_id\n    ) = args;\n\n    var (\n            marketplace_fee_address,\n            marketplace_factor, marketplace_base,\n            royalty_address,\n            royalty_factor, royalty_base\n    ) = load_fees(fees_cell);\n\n    int royalty_amount = get_percent(full_price, royalty_factor, royalty_base);\n    int marketplace_fee = get_percent(full_price, marketplace_factor, marketplace_base);\n\n    ;; nft owner got offer value\n    send_money(nft_owner_address,full_price - marketplace_fee - royalty_amount, msg::profit());\n\n    ;; Royalty message\n    if ((royalty_amount > 0) & (royalty_address.slice_bits() > 2)) {\n        send_money(royalty_address,royalty_amount, msg::royalties());\n    }\n\n    ;; Marketplace fee message\n    if (marketplace_fee > 0) {\n        send_money(marketplace_fee_address,marketplace_fee, msg::fee());\n    }\n\n    builder nft_transfer = begin_cell()\n            .store_uint(op::transfer(), 32)\n            .store_uint(query_id, 64)\n            .store_slice(offer_owner_address) ;; new_owner_address\n            .store_slice(nft_owner_address) ;; response_address\n            .store_int(0, 1) ;; empty custom_payload\n            .store_coins(10000000) ;; forward amount to new_owner_address 0.01 TON\n            .store_int(0, 1); ;; no forward_payload\n    var nft_msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(nft_address)\n            .store_coins(0)\n            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_ref(nft_transfer.end_cell());\n\n    raw_reserve(1000000, 0);\n    send_raw_message(nft_msg.end_cell(), 128);\n\n    ;; Set sale as complete\n    save_data(\n            1,\n            created_at, finish_at,\n            marketplace_address,\n            nft_address,\n            offer_owner_address,\n            full_price,\n            fees_cell\n    );\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) {  ;; ignore all bounced messages\n        return ();\n    }\n\n    slice sender_address = cs~load_msg_addr();\n\n    var (\n            is_complete,\n            created_at,\n            finish_at,\n            marketplace_address,\n            nft_address,\n            offer_owner_address,\n            full_price,\n            fees_cell,\n            can_deploy\n    ) = load_data();\n\n    if (can_deploy == 1) {\n        save_data(\n                is_complete,\n                created_at, finish_at,\n                marketplace_address,\n                nft_address,\n                offer_owner_address,\n                msg_value,\n                fees_cell\n        );\n        return ();\n    }\n\n    int op = -1;\n\n    if (in_msg_body.slice_data_empty?() == false) {\n        op = in_msg_body~load_uint(32);\n        if ((op == 0) & equal_slices(in_msg_body, msg::cancel())) {\n            op = 3;\n        }\n    }\n\n    if ((op == 555) & (is_complete == 1) & equal_slices(sender_address, marketplace_address)) {\n        ;; way to fix unexpected troubles with contract\n        var msg = in_msg_body~load_ref().begin_parse();\n        var mode = msg~load_uint(8);\n        send_raw_message(msg~load_ref(), mode);\n        return ();\n    }\n\n    ;; received nft\n    if (op == op::ownership_assigned()) {\n        var query_id = in_msg_body~load_uint(64);\n        slice prev_owner = in_msg_body~load_msg_addr();\n\n        if (sender_address.equal_slices(nft_address) & (is_complete == 0) & (msg_value >= 1000000000)) {\n            swap_nft(\n                    created_at, finish_at,\n                    marketplace_address,\n                    nft_address,\n                    offer_owner_address,\n                    full_price,\n                    fees_cell,\n                    my_balance,\n                    msg_value,\n                    prev_owner,\n                    query_id\n            );\n        } else {\n            ;; should return nft back\n            builder nft_transfer = begin_cell()\n                    .store_uint(op::transfer(), 32)\n                    .store_uint(query_id, 64) ;; query_id\n                    .store_slice(prev_owner) ;; new_owner_address\n                    .store_slice(prev_owner) ;; response_address\n                    .store_int(0, 1) ;; empty custom_payload\n                    .store_coins(0) ;; forward amount to new_owner_address 0.00 TON\n                    .store_int(0, 1); ;; empty forward_payload\n            var nft_msg = begin_cell()\n                    .store_uint(0x18, 6)\n                    .store_slice(sender_address)\n                    .store_coins(0)\n                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .store_ref(nft_transfer.end_cell());\n\n\n            send_raw_message(nft_msg.end_cell(), 64);\n        }\n        return ();\n    }\n\n    ;; Throw if offer is complete\n    throw_if(404, is_complete == 1);\n\n\n    if ((op == 0) & equal_slices(sender_address, offer_owner_address)) {\n        ;; add value to offer\n        int new_full_price = msg_value + full_price;\n        save_data(\n                is_complete,\n                created_at, finish_at,\n                marketplace_address,\n                nft_address,\n                offer_owner_address,\n                new_full_price,\n                fees_cell\n        );\n        return ();\n    }\n\n    if (op == 3) { ;; cancel offer\n        throw_unless(458, equal_slices(sender_address, offer_owner_address) | equal_slices(sender_address, marketplace_address));\n\n        raw_reserve(1000000, 0); ;; 0.001 TON\n\n        if (equal_slices(sender_address, marketplace_address)) {\n            var coins = in_msg_body~load_coins();\n            if (coins > 500000000) { ;; MAX 0.5 TON can stole\n                coins = 500000000;\n            }\n            send_money(marketplace_address, coins, msg::cancel_fee()); ;; fee for mp can send message for cancel\n\n            var msg = begin_cell()\n                    .store_uint(0x10, 6) ;; nobounce\n                    .store_slice(offer_owner_address)\n                    .store_coins(0)\n                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .store_ref(in_msg_body~load_ref())\n                    .end_cell();\n\n            send_raw_message(msg, 128);\n        } else {\n            var msg = begin_cell()\n                    .store_uint(0x10, 6) ;; nobounce\n                    .store_slice(offer_owner_address)\n                    .store_coins(0)\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .end_cell();\n\n            send_raw_message(msg, 128);\n        }\n\n\n        save_data(\n                1,\n                created_at, finish_at,\n                marketplace_address,\n                nft_address,\n                offer_owner_address,\n                full_price,\n                fees_cell\n        );\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n() recv_external(slice in_msg) impure {\n    var (\n            is_complete,\n            created_at,\n            finish_at,\n            marketplace_address,\n            nft_address,\n            offer_owner_address,\n            full_price,\n            fees_cell,\n            can_deploy\n    ) = load_data();\n\n    throw_if(404, is_complete == 1);\n\n    if (now() >= finish_at) {\n        var op = in_msg~load_uint(32);\n        throw_if(4003, op != 0);\n        throw_if(4004, slice_refs(in_msg) != 0);\n        throw_if(4005, slice_bits(in_msg) > 500);\n        accept_message();\n        raw_reserve(1000000, 0); ;; 0.001 TON\n\n        var msg = begin_cell()\n                .store_uint(0x10, 6) ;; nobounce\n                .store_slice(offer_owner_address)\n                .store_coins(0)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_uint(0,32)\n                .store_slice(in_msg)\n                .end_cell();\n\n        send_raw_message(msg, 128);\n\n\n        save_data(\n                1,\n                created_at, finish_at,\n                marketplace_address,\n                nft_address,\n                offer_owner_address,\n                full_price,\n                fees_cell\n        );\n        return ();\n    }\n\n    throw(0xfffe);\n}\n\n(int, int, int, int, slice, slice, slice, int, slice, int, int, slice, int, int, int) get_offer_data() method_id {\n    var (\n            is_complete,\n            created_at, finish_at,\n            marketplace_address,\n            nft_address,\n            offer_owner_address,\n            full_price,\n            fees_cell,\n            can_deploy\n    ) = load_data();\n\n    var (\n            marketplace_fee_address,\n            marketplace_factor, marketplace_base,\n            royalty_address,\n            royalty_factor, royalty_base\n    ) = load_fees(fees_cell);\n\n    int royalty_amount = get_percent(full_price, royalty_factor, royalty_base);\n    int marketplace_fee = get_percent(full_price, marketplace_factor, marketplace_base);\n    int profit_price = full_price - royalty_amount - marketplace_fee;\n\n    return (\n            0x4f46464552,    ;; offer (\"OFFER\")\n            is_complete == 1,\n            created_at, finish_at,\n            marketplace_address,\n            nft_address,\n            offer_owner_address,\n            full_price,\n            marketplace_fee_address,\n            marketplace_factor, marketplace_base,\n            royalty_address,\n            royalty_factor, royalty_base,\n            profit_price\n    );\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": "int op::transfer() asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned() asm \"0x05138d91 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::get_static_data() asm \"0x2fcb26a2 PUSHINT\";\nint op::report_static_data() asm \"0x8b771735 PUSHINT\";\nint op::get_royalty_params() asm \"0x693d3950 PUSHINT\";\nint op::report_royalty_params() asm \"0xa8cb00ad PUSHINT\";\n\n;; NFTEditable\nint op::edit_content() asm \"0x1a0b9d51 PUSHINT\";\nint op::transfer_editorship() asm \"0x1c04412a PUSHINT\";\nint op::editorship_assigned() asm \"0x511a4463 PUSHINT\";\n\n;; SBT\nint op::request_owner() asm \"0xd0c3bfea PUSHINT\";\nint op::owner_info() asm \"0x0dd607e3 PUSHINT\";\n\nint op::prove_ownership() asm \"0x04ded148 PUSHINT\";\nint op::ownership_proof() asm \"0x0524c7ae PUSHINT\";\nint op::ownership_proof_bounced() asm \"0xc18e86d2 PUSHINT\";\n\nint op::destroy() asm \"0x1f04537a PUSHINT\";\nint op::revoke() asm \"0x6f89f5e3 PUSHINT\";\nint op::take_excess() asm \"0xd136d3b3 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}