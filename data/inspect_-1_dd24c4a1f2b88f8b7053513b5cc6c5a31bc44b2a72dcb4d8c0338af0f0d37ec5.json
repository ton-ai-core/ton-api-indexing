{
  "code": "b5ee9c7201021801000341000114ff00f4a413f4bcf2c80b0102016202030202cc0405011ba1a973b67807f488aa4009024e211702014806070201200b0c02012008090079401d30f01813078baf2e14920d749ab02705204aa008e21aa0302f00113a003a45301ba8e1122d74ac0019a5bd430d020d749ab0270dede03e4316c12801a1007434c0c05c6c2497c0f83e900c0871c03cb44ac074c7f6cf0c093e9100703fd66eac08f001264ccd007cb84c563c03b80c7cb44c887000250c567c037834cfc0b000e64074e7cc15481c3c033817c1200a004f34c1c069b40830bffcb852483042b729be4830bffcb8524830443729b80830bfc870442c3cb8526000348047f833206e953080b9f833de206ef2d29ad0d3ffd3fff40430002ff28995090d09061007970c82801d44093885482015000d040201200d0e0201200f10039f4db3c07d30721c0008e3d31363704d3ffd20fd207d3ffd33f3054708a2cf00b5171a120c2fff2e13b07a170748010c8cb05cb0214ca0712cbff01fa02cb6a12cbffcb0fc970fb00e30e45134004db3c817141504cf36cf095c6c3cb454d51e4848fc02c6a84830803cb84c94512820843011c333c2f232e7c572cff274069c20c1dc60033232c0f2c072c204f2ffc4b2d84073c5b25c3ec0040d5005140dc636cf0063a28c6084017d78401cf6cf3820804000d61c2084017d78401ce017151112005908b1c008f5d2b0006c2540b50c3400b780b4cdc0608a1cddd85c151bc8eebcb85220053c008074409c1ffc0320003e814f4b70208018c8cb055006cf165004fa0214cb6a12cb1f12cb0fc901fb000104db3c130044708018c8cb055007cf1658fa0215cb6a13cb1fcb3f21c2ff92cbff9131e2c901fb0001e621c003983135353602d307308ee121c0048e573720c0058e233035228218174876e800a072fb02708018c8cb055008cf1627fa0217cb6ac98306fb008e293827c0069d5b343401fa00fa00d30d5520338e1107c007953103fa40309134e24414503305e2445302e21035e30d103502e210350216004005c8cb075004fa0258cf16502320812710bcf2d1875afa0258fa02cb0dc9ed5400445b378200f00d707f748018c8cb05cb02ca0717cbff24fa0216cb6a15cb1fc971fb000026ed44d0d307fa00fa40fa00fa00d30d55206c13",
  "code_hash": "0f33a6d40f06e818c0722bdb88cdf7b2fdfea380e33e38101dc156e23e993d57",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "message_utils.fc",
        "content": "() send_receipt_message(addr, ans_tag, query_id, body, grams, mode) impure inline_ref {\n  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n  var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(addr)\n    .store_grams(grams)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(ans_tag, 32)\n    .store_uint(query_id, 64);\n  if (body >= 0) {\n    msg~store_uint(body, 256);\n  }\n  send_raw_message(msg.end_cell(), mode);\n}\n\n() send_text_receipt_message(addr, grams, mode) impure inline_ref {\n  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n  var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(addr)\n    .store_grams(grams)\n    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n    .store_uint(0, 32)\n    .store_uint(0x4f4b, 16); ;; \"OK\"\n  send_raw_message(msg.end_cell(), mode);\n}\n\n() emit_log_simple (int event_id, slice data) impure inline {\n  var msg = begin_cell()\n                        .store_uint (12, 4) ;; ext_out_msg_info$11 src:MsgAddressInt ()\n                        .store_uint (1, 2)\n                        .store_uint (256, 9)\n                        .store_uint(event_id, 256)\n                        .store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n                        .store_slice(data)\n           .end_cell();\n  send_raw_message(msg, 0);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "text_utils.fc",
        "content": "(slice, (int)) ~load_hex_symbol(slice comment) {\n  int n = comment~load_uint(8);\n  n = n - 48;\n  throw_unless( 329, n >= 0);\n  if (n < 10) {\n    return (comment, (n));\n  }\n  n = n - 7;\n  throw_unless( 329, n >= 0);\n  if (n < 16) {\n    return (comment, (n));\n  }\n  n = n - 32;\n  throw_unless( 329, (n >= 0) & (n < 16));\n  return (comment, (n));\n}\n\n(slice, (int)) ~load_text_hex_number(slice comment, int byte_length) {\n  throw_unless(329, comment~load_uint(16) == 12408); ;; \"0x\"\n  int current_slice_length = comment.slice_bits() / 8;\n  int result = 0;\n  int counter = 0;\n  repeat (2 * byte_length) {\n    result = result * 16 + comment~load_hex_symbol();\n    counter = counter + 1;\n    if(counter == current_slice_length) {\n      if (comment.slice_refs() == 1) {\n        cell _cont = comment~load_ref();\n        comment = _cont.begin_parse();\n        current_slice_length = comment.slice_bits() / 8;\n        counter = 0;\n      }\n    }\n  }\n  return (comment, (result));\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "bridge_code.fc",
        "content": "(slice, (int, int, int)) load_fees(slice s) inline {\n    var fees = (s~load_grams(), s~load_grams(), s~load_uint(14));\n    return (s, fees);\n}\n\nbuilder store_fees(builder b, (int, int, int) fees) inline {\n  (int flat_reward, int network_fee, int factor) = fees;\n  throw_if(391, factor > 10000);\n  return b.store_grams(flat_reward).store_grams(network_fee).store_uint(factor, 14);\n}\n\n(int, int, slice, (int, int, int)) load_data() inline_ref {\n  var ds = get_data().begin_parse();\n  return (ds~load_uint(8), ds~load_grams(), ds~load_msg_addr(), ds~load_fees());\n}\n\n() save_data(int state_flags, int total_locked, slice collector_address, fees) impure inline_ref {\n  var st = begin_cell().store_uint(state_flags, 8)\n                       .store_grams(total_locked)\n                       .store_slice(collector_address)\n                       .store_fees(fees)\n                       .end_cell();\n  set_data(st);\n}\n\nint calculate_fee(int msg_value, fees)  {\n    (int flat_reward, int network_fee, int factor) = fees;\n    int remain = msg_value - flat_reward - network_fee;\n    throw_unless(400, remain > 0);\n    int percent_fee = remain * factor / 10000;\n    return flat_reward + network_fee + percent_fee;\n}\n\n;; create swap to external chain to destination address\n() create_swap_from_ton(int destination_address, int amount, slice s_addr, int query_id, int is_text) impure {\n    (int state_flags, int total_locked, slice collector_address, var fees) = load_data();\n    throw_if(339, state_flags & 1);\n    int fee = calculate_fee(amount, fees);\n    amount -= fee;\n    throw_unless(306, amount > 0);\n    total_locked += amount;\n    emit_log_simple(0xc0470ccf, begin_cell().store_uint(destination_address, 160).store_uint(amount, 64).end_cell().begin_parse());\n    save_data(state_flags, total_locked, collector_address, fees);\n    if(is_text) {\n      return send_text_receipt_message(s_addr, 100000000, 3);\n    } else {\n      return send_receipt_message(s_addr, 0x10000 + 3, query_id, 0, 100000000, 3);\n    }\n}\n\n() process_comment_api_request (slice in_msg, int msg_value, slice s_addr) impure {\n    if (in_msg.slice_empty?() & (in_msg.slice_refs() == 1)) {\n      cell _cont = in_msg~load_ref();\n      in_msg = _cont.begin_parse();\n    }\n    int command = in_msg~load_uint(56);\n    throw_unless(328, command == 32500882701840163); ;; \"swapTo#\" other commands are unsupported\n    int destination_address = in_msg~load_text_hex_number(20);\n    in_msg.end_parse();\n    return create_swap_from_ton(destination_address, msg_value, s_addr, 0, true);\n}\n\n() execute_voting (slice s_addr, slice voting_data, int bridge_address) impure {\n  (int state_flags, int total_locked, slice collector_address, var fees) = load_data();\n\n  int operation = voting_data~load_uint(8);\n  if (operation == 0) { ;; swap\n\n    (int ext_chain_hash,\n     int internal_index,\n     int wc,\n     int addr_hash,\n     int swap_amount) = (voting_data~load_uint(256),\n                         voting_data~load_int(16),\n                         voting_data~load_int(8),\n                         voting_data~load_uint(256),\n                         voting_data~load_uint(64));\n    int fee = calculate_fee(swap_amount, fees);\n    total_locked -= swap_amount;\n    throw_unless(315, total_locked >= 0);\n    swap_amount -= fee;\n\n    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n    var msg = begin_cell()\n      .store_uint(0x10, 6) ;; #int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt = 0 1 0 0 0 00\n      .store_uint(4, 3).store_int(wc, 8).store_uint(addr_hash, 256)\n      .store_grams(swap_amount)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(ext_chain_hash, 256)\n      .store_uint(internal_index, 16);\n    send_raw_message(msg.end_cell(), 0);\n\n  } elseif (operation == 3) { ;; update state flags\n\n    state_flags = voting_data~load_uint(8);\n\n  } elseif (operation == 4) { ;; migrate\n\n    var msg = begin_cell()\n      .store_uint(0x18, 6) ;; #int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt = 0 1 1 0 00\n      .store_uint(4, 3).store_int(-1, 8).store_uint(bridge_address, 256)\n      .store_grams(total_locked)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n      .store_uint(0xf00d, 32); ;; new bridge contract should recognize this opcode\n    send_raw_message(msg.end_cell(), 1);\n\n  } elseif (operation == 5) { ;; get reward\n\n    ;; reserve total_locked + 100 Toncoins for storage fees\n    raw_reserve(total_locked + 100000000000, 2);\n    var msg = begin_cell()\n      .store_uint(0x18, 6) ;; #int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt = 0 1 1 0 00\n      .store_slice(s_addr)\n      .store_grams(0)\n      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n    send_raw_message(msg.end_cell(), 128); ;; send all the remainings\n\n  } elseif (operation == 6) { ;; change fees\n\n    fees = voting_data~load_fees();\n\n  } elseif (operation == 7) { ;; change collector\n\n    collector_address = voting_data~load_msg_addr();\n\n  }\n\n  save_data(state_flags, total_locked, collector_address, fees);\n}\n\n() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {\n  var cs = in_msg_cell.begin_parse();\n  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n  if (flags & 1) {\n    ;; ignore all bounced messages\n    return ();\n  }\n  slice s_addr = cs~load_msg_addr();\n  throw_if(299, in_msg.slice_empty?()); ;; inbound message has empty body\n  \n  int op = in_msg~load_uint(32);\n  (int bridge_address, int oracles_address, _) = get_bridge_config();\n  (int wc, int addr) = parse_std_addr(s_addr);\n  var is_oracles = (wc == -1) & (oracles_address == addr);\n\n  if (op == 4) {\n    throw_unless(305, is_oracles);\n    return execute_voting(s_addr, in_msg, bridge_address);\n  }\n  throw_if(306, is_oracles); ;; don't allow to create swaps from oracles multisig\n  if (op == 0) {\n    return process_comment_api_request(in_msg, msg_value, s_addr);\n  }\n  int query_id = in_msg~load_uint(64);\n  if (op == 3) {\n    int destination_address = in_msg~load_uint(160);\n    return create_swap_from_ton(destination_address, msg_value, s_addr, query_id, false);\n  }\n}\n\n;; get methods\n\n_ get_bridge_data() method_id {\n    (int state_flags, int total_locked, slice collector_address_slice, var fees) = load_data();\n    (int flat_reward, int network_fee, int factor) = fees;\n    (int wc, int addr) = parse_std_addr(collector_address_slice);\n    return (state_flags, total_locked, wc, addr, flat_reward, network_fee, factor, 10000);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "bridge-config.fc",
        "content": "(int, int, cell) get_bridge_config() impure inline_ref {\n  cell bridge_config = config_param(71);\n  if (bridge_config.cell_null?()) {\n    bridge_config = config_param(-71);\n  }\n  throw_if(666, bridge_config.cell_null?());\n  slice ds = bridge_config.begin_parse();\n  ;; wc always equals to -1\n  int bridge_address = ds~load_uint(256);\n  int oracles_address = ds~load_uint(256);\n  cell oracles = ds~load_dict();\n  return (bridge_address, oracles_address, oracles);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}