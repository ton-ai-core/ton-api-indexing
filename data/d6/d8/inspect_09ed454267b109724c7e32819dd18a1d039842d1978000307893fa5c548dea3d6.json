{
  "code": "b5ee9c7201022e010006a2000114ff00f4a413f4bcf2c80b01020120020302014804050228f230db3c8103eef844c0fff2f2f8007ff864db3c2c190202ce06070201201c1d02012008090201201a1b04f50cf434c0c05c6c3c903e900c36cf3e10d48431c17e10ac303fe3b3d6f4c7c87000234127265706561745f656e645f61756374696f6e8148831c16c23a0d6f6cf3800700023411656d657267656e63795f6d6573736167658148831c16c26b50c3434c1f50c007ec0380c383e15d48431c163a10c4076cf383e08e02c110a0b001320840ee6b280006a6120015c318103e9f856d749c202f2f28103ea01d31f821005138d9112ba12f2f48040d721fa4030f87670f8627ff864db3c190448f853be8f066c21db3cdb3ce0f842c0ff8e846c21db3ce0f8565210c705f8435220c705b11711170c04788fb8318103eb02d31f01c30013f2f28b663616e63656c85220c7058e8321db3cde8b473746f70812c705f8565220c705b08f04db3cdb3c9130e2e0320d17110e01f68103ec8b663616e63656c812c705b3f2f2f851c2008e4570208018c8cb05f850cf16f851fa02cb6acb1f8d0a565bdd5c88189a59081a185cc81899595b881bdd5d189a5908189e48185b9bdd1a195c881d5cd95c8ba0cf16c972fb00de7020f82582105fcc3d14c8cb1fcb3ff856cf16f856cf16cb0021fa02cb000f0104db3c10014cc9718018c8cb05f857cf1670fa02cb6acc82080f424070fb02c98306fb007ff8627ff866db3c1904f48103edf842c0fff2f2f853f823b98f0530db3cdb3ce0f84ec200f84e5220beb08ed5f8518e4570208018c8cb05f850cf16f851fa02cb6acb1f8d0a565bdd5c88189a59081a185cc81899595b881bdd5d189a5908189e48185b9bdd1a195c881d5cd95c8ba0cf16c972fb00de01f870f871f823f872db3ce0f853171111120292f851c0008e3c7020f82582105fcc3d14c8cb1fcb3ff856cf16f856cf16cb0021fa02cb00c9718018c8cb05f857cf1670fa02cb6acc82080f424070fb02c98306fb00e30e7ff862db3c131903fcf855a1f823b997f853f854a0f873def8518e948103e8f84d5220b9f2f2f871f870f823f872db3ce1f851f84fa05210b98e8330db3ce070208018c8cb05f850cf16f851fa02cb6acb1f8d0a565bdd5c88189a59081a185cc81899595b881bdd5d189a5908189e48185b9bdd1a195c881d5cd95c8ba0cf16c972fb0001f87019171803f87020f82582105fcc3d14c8cb1fcb3ff850cf16f856cf16cb008209c9c380fa02cb00c9718018c8cb05f857cf1682103b9aca00fa02cb6accc972fb00f851f848f849f00320c2009130e30df851f84bf84cf00320c2009130e30d82080f424070fb0270208018c8cb05f856cf1621fa02cb6acb1f89cf16c98306fb00141516007870208018c8cb05f847cf165003fa0212cb6acb1f8d07d3585c9ad95d1c1b1858d94818dbdb5b5a5cdcda5bdb881dda5d1a191c985de0cf16c973fb00007070208018c8cb05f84acf165003fa0212cb6acb1f8d06d49bde585b1d1e4818dbdb5b5a5cdcda5bdb881dda5d1a191c985de0cf16c973fb00002e50726576696f7573206f776e6572207769746864726177008870208018c8cb055003cf1621fa0212cb6acb1f8d09d65bdd5c881d1c985b9cd858dd1a5bdb881a185cc81b9bdd081899595b881858d8d95c1d19590ba0cf16c98040fb000110f871f823f872db3c1900d0f84cf84bf849f848c8f847cf16cb1fcb1ff84acf16cb1fcb1ff855f854f853f852c8f84dfa02f84efa02f84ffa02f850cf16f851fa02cb1fcb1fcb1fcb1fc8f856cf16f857cf16c901c902c9f846f845f844f842c8ca00f843cf16ca00ca1fca00cc12ccccc9ed54001120840ee6b2802a6120000d167c00807c00600201201e1f020120242502016620210125ba915db3cf856d749c103927020e0f856fa4482c0111af2eed9e7c287d22402c02012022230118aab2db3cf848f849f84bf84c2c015ea82cdb3c8208415543f842f853f843f857f856f851f850f84ff847f848f849f84af84bf84cf84ef84df845f852f8462c020120262702016e2a2b011db7efbb679f09bf09df09ff0a3f0a702c02012028290111b0c9b6cf3e12be91202c0111b196f6cf3e11fe91202c0111af2b6d9e7c21fd22402c0125acaded9e7c2beba4e081c93810707c2bfd22402c01f6f8416edded44d0d20001f862fa4001f863d20001f864d21f01f865d20001f866d401d0fa4001f867d31f01f868d31f01f869fa4001f86ad31f01f86bd31f30f86cd401d0fa0001f86dfa0001f86efa0001f86ffa4001f870fa0001f871d31f01f872d31f01f873d31f01f874d31f30f875d430d0fa4001f876fa402d000c30f8777ff861",
  "code_hash": "fc00a29dd0205bcdcc0d3ffb9ca38cc3c8c159ec60d8aa543240a92f10592d40",
  "methods": [
    {
      "id": 72748,
      "method": "get_sale_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "struct/msg-utils.func",
        "content": ";;\n;;  text constants for msg comments\n;;\n\nslice msg::cancel_msg()     asm \"<b 124 word cancel| $, b> <s PUSHSLICE\";\nslice msg::stop_msg()       asm \"<b 124 word stop| $, b> <s PUSHSLICE\";\n\nslice msg::return_msg()     asm \"<b 124 word Your transaction has not been accepted.| $, b> <s PUSHSLICE\";\nslice msg::bid_return()     asm \"<b 124 word Your bid has been outbid by another user.| $, b> <s PUSHSLICE\";\nslice msg::mp_msg()         asm \"<b 124 word Marketplace commission withdraw| $, b> <s PUSHSLICE\";\nslice msg::royalty_msg()    asm \"<b 124 word Royalty commission withdraw| $, b> <s PUSHSLICE\";\nslice msg::profit_msg()     asm \"<b 124 word Previous owner withdraw| $, b> <s PUSHSLICE\";\n\nslice msg::repeat_end_auction()     asm \"<b 124 word repeat_end_auction| $, b> <s PUSHSLICE\";\nslice msg::emergency_message()      asm \"<b 124 word emergency_message| $, b> <s PUSHSLICE\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "imports/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "struct/math.func",
        "content": ";;\n;;  math utils\n;;\n\nint division(int a, int b) { ;; division with factor\n    return muldiv(a, 1000000000 {- 1e9 -}, b);\n}\n\nint multiply(int a, int b) { ;; multiply with factor\n    return muldiv (a, b, 1000000000 {- 1e9 -});\n}\n\nint math::get_percent(int a, int percent, int factor) {\n    return division(multiply(a, percent), factor);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "nft-auction.func",
        "content": ";;\n;;  main FunC file git@github.com:cryshado/nft-auc-contest.git\n;;\n\nint equal_slices? (slice a, slice b) asm \"SDEQ\";\n\n#include \"struct/op-codes.func\";\n#include \"struct/exit-codes.func\";\n#include \"struct/math.func\";\n#include \"struct/msg-utils.func\";\n#include \"struct/storage.func\";\n#include \"struct/handles.func\";\n#include \"struct/get-met.func\";\n\n{-\n    SHOULD\n    [+] accept coins for deploy\n    [+] accept nft and change auction statud\n    [+] return transaction if auction already end\n    [+] can cancel auction\n    [+] accept new bid -> check auction end -> end auction\n-}\n() recv_internal(int my_balance, int msg_value, cell in_msg_cell, slice in_msg_body) impure {\n    slice cs = in_msg_cell.begin_parse();\n    throw_if(0, cs~load_uint(4) & 1);\n\n    slice sender_addr = cs~load_msg_addr();\n    init_data();\n\n    if (equal_slices?(sender_addr, mp_addr) & end? == true) {\n        int op = in_msg_body~load_uint(32);\n        if ((op == 0) & equal_slices(in_msg_body, msg::repeat_end_auction())) {\n            ;; special case for repeat end_auction logic if nft not transfered from auc contract\n            handle::end_auction();\n            return ();\n        }\n        if ((op == 0) & equal_slices(in_msg_body, msg::emergency_message())) {\n            ;; way to fix unexpected troubles with auction contract\n            ;; for example if some one transfer nft to this contract\n            var msg = in_msg_body~load_ref().begin_parse();\n            var mode = msg~load_uint(8);\n            send_raw_message(msg~load_ref(), mode);\n            return ();\n        }\n        ;; accept coins for deploy\n        return ();\n    }\n\n    if (equal_slices?(sender_addr, nft_addr)) {\n        handle::try_init_auction(sender_addr, in_msg_body);\n        return ();\n    }\n\n    if (now() >= end_time) {\n        handle::return_transaction(sender_addr);\n        handle::end_auction();\n        return ();\n    }\n\n    if (end? == true) {\n        handle::return_transaction(sender_addr);\n        return ();\n    }\n\n    if (equal_slices?(sender_addr, nft_owner)) | (equal_slices?(sender_addr, mp_addr)) {\n        throw_if(;;throw if it`s not message\n                exit::not_message(),\n                in_msg_body~load_uint(32) != 0\n        );\n\n        if (equal_slices?(in_msg_body, msg::cancel_msg())) {\n            handle::try_cancel(in_msg_body);\n        }\n\n        if (equal_slices?(in_msg_body, msg::stop_msg()) & equal_slices?(sender_addr, nft_owner)) {\n            handle::return_transaction(sender_addr);\n            handle::end_auction();\n        }\n\n        return ();\n    }\n\n    handle::new_bid(sender_addr, msg_value);\n}\n\n{-\n    Message for deploy contract external\n-}\n() recv_external(slice in_msg) impure {\n    init_data();\n    throw_if(exit::already_activated(), activated? == true);\n    accept_message();\n    activated? = true;\n    pack_data();\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/storage.func",
        "content": ";;\n;;  persistant and runtime storage –≤escription\n;;\n\nglobal int      init?; ;; init_data safe check\nglobal int      end?; ;; end auction or not\nglobal slice    mp_addr; ;; the address of the marketplace from which the contract is deployed\nglobal int      activated?; ;; contract is activated by external message or by nft transfer\nglobal int      created_at?; ;; timestamp of created acution\nglobal int      is_canceled?; ;; auction was cancelled by owner\n\n;; fees cell (ref)\nglobal slice    mp_fee_addr; ;; the address of the marketplace where the commission goes\nglobal int      mp_fee_factor; ;;\nglobal int      mp_fee_base; ;;\nglobal slice    royalty_fee_addr; ;; the address of the collection owner where the commission goes\nglobal int      royalty_fee_factor; ;;\nglobal int      royalty_fee_base; ;;\n\n;; bids info cell (ref)\nglobal int      min_bid; ;; minimal bid\nglobal int      max_bid; ;; maximum bid\nglobal int      min_step; ;; minimum step (can be 0)\nglobal slice    last_member; ;; last member address\nglobal int      last_bid; ;; last bid amount\nglobal int      last_bid_at; ;; timestamp of last bid\nglobal int      end_time; ;; unix end time\nglobal int      step_time; ;; by how much the time increases with the new bid (e.g. 30)\nglobal int      try_step_time; ;; after what time to start increasing the time (e.g. 60)\n\n;; nft info cell (ref)\nglobal slice    nft_owner; ;; nft owner addres (should be sent nft if auction canceled or money from auction)\nglobal slice    nft_addr; ;; nft address\n\n\n() init_data() impure inline_ref {- save for get methods -} {\n    ifnot(null?(init?)) { return ();}\n\n    slice ds = get_data().begin_parse();\n    end? = ds~load_int(1);\n    mp_addr = ds~load_msg_addr();\n    activated? = ds~load_int(1);\n    created_at? = ds~load_int(32);\n    is_canceled? = ds~load_int(1);\n\n    slice fees_cell = ds~load_ref().begin_parse();\n    mp_fee_addr = fees_cell~load_msg_addr();\n    mp_fee_factor = fees_cell~load_uint(32);\n    mp_fee_base = fees_cell~load_uint(32);\n    royalty_fee_addr = fees_cell~load_msg_addr();\n    royalty_fee_factor = fees_cell~load_uint(32);\n    royalty_fee_base = fees_cell~load_uint(32);\n\n    slice bids_cell = ds~load_ref().begin_parse();\n    min_bid = bids_cell~load_coins();\n    max_bid = bids_cell~load_coins();\n    min_step = bids_cell~load_coins();\n    last_member = bids_cell~load_msg_addr();\n    last_bid = bids_cell~load_coins();\n    last_bid_at = bids_cell~load_uint(32);\n    end_time = bids_cell~load_uint(32);\n    step_time = bids_cell~load_uint(32);\n    try_step_time = bids_cell~load_uint(32);\n\n    slice nft_cell = ds~load_ref().begin_parse();\n    nft_owner = nft_cell~load_msg_addr();\n    nft_addr = nft_cell~load_msg_addr();\n\n    init? = true;\n}\n\n() pack_data() impure inline_ref {\n    builder fees_cell = begin_cell()\n            .store_slice(mp_fee_addr) ;; + max    267 ($10 with Anycast = 0)\n            .store_uint(mp_fee_factor, 32) ;; + stc    32\n            .store_uint(mp_fee_base, 32) ;; + stc    32\n            .store_slice(royalty_fee_addr) ;; + max    267 ($10 with Anycast = 0)\n            .store_uint(royalty_fee_factor, 32) ;; + stc    32\n            .store_uint(royalty_fee_base, 32); ;; + stc    32\n    ;; total: (267 * 2) + (32 * 4) = 662 maximum bits\n\n    builder bids_cell = begin_cell()\n            .store_coins(min_bid) ;; + max    124\n            .store_coins(max_bid) ;; + max    124\n            .store_coins(min_step) ;; + max    124\n            .store_slice(last_member) ;; + max    267 ($10 with Anycast = 0)\n            .store_coins(last_bid) ;; + max    124\n            .store_uint(last_bid_at, 32) ;; + stc    32\n            .store_uint(end_time, 32) ;; + stc    32\n            .store_uint(step_time, 32) ;; + stc    32\n            .store_uint(try_step_time, 32); ;; +stc     32\n    ;; total 32*4 + 124*4 + 267 = 891\n\n    builder nft_cell = begin_cell()\n            .store_slice(nft_owner) ;; + max    267 ($10 with Anycast = 0)\n            .store_slice(nft_addr); ;; + max    267 ($10 with Anycast = 0)\n    ;; total: 267 * 2 = 534 maximum bits\n\n    set_data(\n            begin_cell()\n                    .store_int(end?, 1) ;; + stc    1\n                    .store_slice(mp_addr) ;; + max    267 ($10 with Anycast = 0)\n                    .store_int(activated?, 1) ;; activated?\n                    .store_int(created_at?, 32)\n                    .store_int(is_canceled?, 1)\n                    .store_ref(fees_cell.end_cell()) ;; + ref\n                    .store_ref(bids_cell.end_cell()) ;; + ref\n                    .store_ref(nft_cell.end_cell()) ;; + ref\n                    .end_cell()\n    );\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "struct/get-met.func",
        "content": "(int, int) get_nft_owner() method_id {\n    init_data();\n\n    if (nft_owner.slice_bits() <= 2) { return (0, 0);}\n\n    (int wc, int addr) = parse_std_addr(nft_owner);\n    return (wc, addr);\n}\n\n(int, int) get_nft_addr() method_id {\n    init_data();\n\n    if (nft_addr.slice_bits() <= 2) { return (0, 0);}\n\n    (int wc, int addr) = parse_std_addr(nft_addr);\n    return (wc, addr);\n}\n\n(int, int) get_last_member() method_id {\n    init_data();\n    ;; trhow error of addr not std\n    (int wc, int addr) = parse_std_addr(last_member);\n    return (wc, addr);\n}\n\n(int, int) get_mp_addr() method_id {\n    init_data();\n    ;; trhow error of addr not std\n    (int wc, int addr) = parse_std_addr(mp_addr);\n    return (wc, addr);\n}\n\n(int, int) get_mp_fee_addr() method_id {\n    init_data();\n    ;; trhow error of addr not std\n    (int wc, int addr) = parse_std_addr(mp_fee_addr);\n    return (wc, addr);\n}\n\n(int, int) get_royalty_fee_addr() method_id {\n    init_data();\n    ;; trhow error of addr not std\n    (int wc, int addr) = parse_std_addr(royalty_fee_addr);\n    return (wc, addr);\n}\n\n(int, int, int, int) get_fees_info() method_id {\n    init_data();\n    return (\n            mp_fee_factor, mp_fee_base,\n            royalty_fee_factor, royalty_fee_base\n    );\n}\n\n(int, int, int, int, int) get_bid_info() method_id {\n    init_data();\n    return (\n            min_bid, max_bid, min_step,\n            last_bid, end_time\n    );\n}\n\n;; 1  2    3    4      5      6      7    8      9    10     11   12   13     14   15   16   17   18   19   20\n(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int) get_sale_data() method_id {\n    init_data();\n\n    return (\n            0x415543, ;; 1 nft aucion (\"AUC\")\n            end?, ;; 2\n            end_time, ;; 3\n            mp_addr, ;; 4\n            nft_addr, ;; 5\n            nft_owner, ;; 6\n            last_bid, ;; 7\n            last_member, ;; 8\n            min_step, ;; 9\n            mp_fee_addr, ;; 10\n            mp_fee_factor, mp_fee_base, ;; 11, 12\n            royalty_fee_addr, ;; 13\n            royalty_fee_factor, royalty_fee_base, ;; 14, 15\n            max_bid, ;; 16\n            min_bid, ;; 17\n            created_at?, ;; 18\n            last_bid_at, ;; 19\n            is_canceled? ;; 20\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "struct/exit-codes.func",
        "content": ";;\n;;  custom TVM exit codes\n;;\n\nint exit::low_bid()           asm \"1000 PUSHINT\";\nint exit::auction_init()      asm \"1001 PUSHINT\";\nint exit::no_transfer()       asm \"1002 PUSHINT\";\nint exit::not_message()       asm \"1003 PUSHINT\";\nint exit::not_cancel()        asm \"1004 PUSHINT\";\nint exit::auction_end()       asm \"1005 PUSHINT\";\nint exit::already_activated() asm \"1006 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "struct/handles.func",
        "content": ";;\n;;  function handlers\n;;\n\n() handle::return_transaction(slice sender_addr) impure inline_ref {\n    builder return_msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(sender_addr)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(0, 32)\n            .store_slice(msg::return_msg());\n    send_raw_message(return_msg.end_cell(), 64);\n}\n\n{-\n    SHOULD\n    [+] check init auction or not\n    [+] check op\n    [+] change nft owner\n    [+] change auction status\n-}\n() handle::try_init_auction(slice sender_addr, slice in_msg_body) impure inline_ref {\n    throw_if(exit::auction_init(), nft_owner.slice_bits() > 2); ;; throw if auction already init\n    throw_unless(exit::no_transfer(), in_msg_body~load_uint(32) == op::ownership_assigned()); ;; throw if it`s not ownership assigned\n    in_msg_body~skip_bits(64); ;; query id\n    nft_owner = in_msg_body~load_msg_addr();\n    end? = false;\n    activated? = true;\n    pack_data();\n}\n\n\n{-\n    SHOULD\n    [+] return prev bid \n    [+] return nft to owner\n    [+] reserve 0,001 ton \n-}\n() handle::try_cancel(slice in_msg_body) impure inline_ref {\n    throw_if(;; throw if msg not \"cancel\"\n            exit::not_cancel(),\n            ~(equal_slices?(in_msg_body, msg::cancel_msg()))\n    );\n\n    if (last_bid > 0) {\n        builder bid_return = begin_cell()\n                .store_uint(0x18, 6)\n                .store_slice(last_member)\n                .store_coins(last_bid)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_uint(0, 32)\n                .store_slice(msg::bid_return());\n\n        send_raw_message(bid_return.end_cell(), 2); ;; ignore errors\n    }\n\n    builder nft_return_body = begin_cell()\n            .store_uint(op::transfer(), 32)\n            .store_uint(cur_lt(), 64) ;; query id\n            .store_slice(nft_owner) ;; new owner\n            .store_slice(nft_owner) ;; response_destination\n            .store_uint(0, 1) ;; custom payload\n            .store_coins(0) ;; forward amount\n            .store_uint(0, 1); ;; forward payload\n\n    builder nft_return_msg = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(nft_addr)\n            .store_coins(0)\n            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_ref(nft_return_body.end_cell());\n\n    raw_reserve(1000000, 0); ;; reserve some bebras  üêà\n\n    send_raw_message(nft_return_msg.end_cell(), 128);\n    end? = true;\n    is_canceled? = true;\n    pack_data();\n}\n\n{-\n    SHOULD\n    [+] transfer nft\n    [+] send marketplace fee\n    [+] send royalty fee\n    [+] reserve 0,001 ton \n    [+] send profit to previous nft owner\n    [+] change auction status\n-}\n() handle::end_auction() impure inline_ref {\n    if (last_bid == 0) {\n        builder nft_return_body = begin_cell()\n                .store_uint(op::transfer(), 32)\n                .store_uint(cur_lt(), 64) ;; query id\n                .store_slice(nft_owner) ;; new owner\n                .store_slice(nft_owner) ;; response_destination\n                .store_uint(0, 1) ;; custom payload\n                .store_coins(0) ;; forward amount\n                .store_uint(0, 1); ;; forward payload\n\n        builder nft_return_msg = begin_cell()\n                .store_uint(0x18, 6)\n                .store_slice(nft_addr)\n                .store_coins(0)\n                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_ref(nft_return_body.end_cell());\n\n        raw_reserve(1000000, 0); ;; reserve some bebras  üêà\n\n        send_raw_message(nft_return_msg.end_cell(), 128);\n    } else {\n        builder nft_transfer_body = begin_cell()\n                .store_uint(op::transfer(), 32)\n                .store_uint(cur_lt(), 64) ;; query id\n                .store_slice(last_member) ;; new owner\n                .store_slice(nft_owner) ;; response_destination\n                .store_uint(0, 1) ;; custom payload\n                .store_coins(30000000) ;; forward amount  0,03 ton\n                .store_uint(0, 1); ;; forward payload\n        builder nft_transfer = begin_cell()\n                .store_uint(0x18, 6)\n                .store_slice(nft_addr)\n                .store_coins(1000000000) ;; 1 ton\n                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_ref(nft_transfer_body.end_cell());\n        send_raw_message(nft_transfer.end_cell(), 2);\n\n\n        int mp_fee = math::get_percent(last_bid, mp_fee_factor, mp_fee_base);\n\n        if (mp_fee > 0) {\n            builder mp_transfer = begin_cell()\n                    .store_uint(0x18, 6)\n                    .store_slice(mp_fee_addr)\n                    .store_coins(mp_fee)\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .store_uint(0, 32)\n                    .store_slice(msg::mp_msg());\n\n            send_raw_message(mp_transfer.end_cell(), 3);\n        }\n\n        int royalty_fee = math::get_percent(last_bid, royalty_fee_factor, royalty_fee_base);\n\n        if (royalty_fee > 0) {\n            builder royalty_transfer = begin_cell()\n                    .store_uint(0x18, 6)\n                    .store_slice(royalty_fee_addr)\n                    .store_coins(royalty_fee)\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .store_uint(0, 32)\n                    .store_slice(msg::royalty_msg());\n\n            send_raw_message(royalty_transfer.end_cell(), 3);\n        }\n\n        raw_reserve(1000000, 0); ;; reserve some bebras  üêà\n\n        builder prev_owner_msg = begin_cell()\n                .store_uint(0x18, 6)\n                .store_slice(nft_owner)\n                .store_coins(0)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                .store_uint(0, 32)\n                .store_slice(msg::profit_msg());\n\n        send_raw_message(prev_owner_msg.end_cell(), 128);\n    }\n    end? = true;\n    pack_data();\n}\n\n\n{-\n    SHOULD \n    [+] check if first bid\n    [+] check time  \n    [+] check bid step amount\n    [+] check init auction or not \n    [+] return prev bid\n    [+] change bid info\n    [+] check max bid\n-}\n() handle::new_bid(slice sender_addr, int msg_value) impure inline_ref {\n    throw_if(exit::auction_end(), end? == true);\n\n    if (end_time < now()) {\n        handle::return_transaction(sender_addr);\n        handle::end_auction();\n        return ();\n    }\n\n    if ((max_bid > 0) & (msg_value >= max_bid)) {\n        if (last_bid) {\n            builder return_prev_bid = begin_cell()\n                    .store_uint(0x18, 6)\n                    .store_slice(last_member)\n                    .store_coins(last_bid)\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n                    .store_uint(0, 32)\n                    .store_slice(msg::bid_return());\n            send_raw_message(return_prev_bid.end_cell(), 2);\n        }\n        last_member = sender_addr;\n        last_bid = msg_value;\n        last_bid_at = now();\n        handle::end_auction();\n        return ();\n    }\n\n    ;; 990(now) 1000(end time) 100(try step time)\n    if ((end_time - try_step_time) < now()) {\n        end_time += step_time;\n    }\n\n    ifnot(last_bid) {\n        throw_if(exit::low_bid(), msg_value < min_bid);\n        last_bid = msg_value;\n        last_member = sender_addr;\n        last_bid_at = now();\n        pack_data();\n        return ();\n    }\n\n    if (msg_value < (last_bid + min_step)) {\n        handle::return_transaction(sender_addr);\n        return ();\n    }\n\n    builder return_prev_bid = begin_cell()\n            .store_uint(0x18, 6)\n            .store_slice(last_member)\n            .store_coins(last_bid)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(0, 32)\n            .store_slice(msg::bid_return());\n\n    send_raw_message(return_prev_bid.end_cell(), 2);\n\n    last_member = sender_addr;\n    last_bid = msg_value;\n    last_bid_at = now();\n\n    pack_data();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "struct/op-codes.func",
        "content": ";;\n;;  op codes\n;;\n\nint op::transfer()              asm \"0x5fcc3d14 PUSHINT\";\nint op::ownership_assigned()    asm \"0x05138d91 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}