{
  "code": "b5ee9c720102e301001c4f000114ff00f4a413f4bcf2c80b0102016202030202701e1f02012004050201200607020120181902012008090201200e0f0201580a0b02016a0c0d001baff3f8190823af8380f84aaf81c00007ae22bfc00026a801c85005fa025003cf1601cf16f400ca3fc90016a8fbf03210475f0701f08c020148101102012014150097af46f8190823af83907847b6c880c71c00f84729a178132f83ac10617fcd9880c10c746a52880054c24e360900c10c746a52880054c37164652064e829114183fa0b291178482a81743620c002012012130018a994f03210475f0701f099300014aafcf03210475f07f09802037ba016170009b00abc0ca00017bacf03210475f0701f096308000bbbef0325f0780201201a1b0201201c1d0011b769de064204ebe0f00019b60e5e064208ebe0e03e1266100027b6121e064208ebe0ea609e118206a8861e1346100011b75e5e064208ebe0f0020148202102039d5c5152020120222302039f74363702012024250203a136343502012026270201482a2b0201202829020162b7b802012058590201207b7c0202762c2d02027230310201202e2f0039f3618f6a2687d007d207d207a02691fe3804b36b6b6f88099c92f82f1400334c85008fa025006cf165004cf1612f400ca3ff400f400f400c9800375c85008fa025006cf165004cf1612f400ca3ff400f400f400c9ed54801c3f2f8236e42802e78b41780a41e29fb1df27397da3fe928d6fae8c5d0a6e75ad9da68fcdf9efd3416ad2652c02c183fa21e42801e78b41784315ebc72170a1dda8b306290ba921bb2477b3cb3ea82a849e88df088be3ba582c01c183fa2180e47a0043201d5f1818e410c1780a41e29fb1df27397da3fe928d6fae8c5d0a6e75ad9da68fcdf9efd3416ad26500c183fa0737d0c100627800f97a678b10c1784315ebc72170a1dda8b306290ba921bb2477b3cb3ea82a849e88df088be3ba5800c183fa0737d0c100627800f97a678b10c3300a482f0f2db50ca82af28655e6055eb11cd12a3836462898e75d4f779fb336d201942ac588307f44301c8ca3f82f04ba69735ca53765ed6a709edb56c6ea236b7193a3b29a6b390c346f0f4340e4e588307f44300da82f0f2db50ca82af28655e6055eb11cd12a3836462898e75d4f779fb336d201942ac018307f40e6fa18200c4f001f2f4f4043001f4000182f04ba69735ca53765ed6a709edb56c6ea236b7193a3b29a6b390c346f0f4340e4e018307f40e6fa18200c4f001f2f4d23f3001ca3f001116be8084bd0032806000053c0a60004fd38642c678b64c10802faf07fe4400780e58fe59fa801e78b096664c020783b7c07c100627a7978404f7f781904698f8080e99f916008c7702a3843a9aa76a276a2f6a3c70b0811af8181f81cb641032a984105312d0003f81e783cf6b3f6b2f6b23abff688c7552555189d1d1d1d1d02781cab0a6180470ba87f2f851b9b9b9ba20aa819c105312d0003781e09783cf18776a0f6f880f97ff0116010f1811140908d5d7181438393a3b02fe53fbf08c547a9020c2ff9b31018218e8d4a51000a9849c6c12018218e8d4a51000a986e22ca04ba020c2ff8e133121c2009a8218e8d4a5100058a984925b70e28e146c1221c2009a8218e8d4a5100058a986925b70e2e25208b927c200b0927037de5376f06a5166a05151a15157bc07c30017b025c200b004c10014b1e3023c3d015e547721ed44ed45ed478e1210235f03820a625a008121ec58f04a12f07aed67ed65ed64737fed118aed41edf101f2ff3e018054798754798729561153a9ed44ed45ed478e1b10235f0334820a625a0081211a5005f04c542460f07a7003f10133ed67ed65ed647a7fed118aed41edf101f2ff4304fe2281211fba8e324aaa3134393939393903f0495391f08c01a01029f08d820a625a008208211fe85008f04a542730f07a060550437003f10133e022c031e3022281311abae3022281311fba8e294aaa5b393939393903f06053b1f08c01a0102bf08d5301f08c500aa01029f08d06a517456314f10133e022810d21bae3022244454647003010265f063636373737375e3113820a625a0006f03c12f07900a232543c84f08d561029018307f40e6fa1705202985bd33f0101d70b3f9132e24e43541076f09b102f275901c8cb3fcb3f028307f44326106b05104b50e3820a625a000cf03a542520f07950765513f1013302f84aaa8f77eda2edfb313a3a3a3a3a09c3008ee603f0435349f021107f5f0f6c3129843fba56132cf08c018e273a535456145476dcf09ab321c101b18e145f0e6c42820a625a008121e85003f04af07adb31e00ade54798020c2ff9b31018218e8d4a51000a9849c6c12018218e8d4a51000a986e22ba1547a90e30dd83f4001b220c2ff8e133121c2009a8218e8d4a5100058a984925b70e28e146c1221c2009a8218e8d4a5100058a986925b70e2e211152d5616f08d48705207f09701e30257105f0d3333820a625a0034938121e7938121e8e258f04af07a410028355f036c2232820a625a008121e65003f04af07a018230561226f06a21c20098104a103950675f05e30d537ff08d107b820a625a002b08107d06051111051034021111021df044542440f0794516504385325520f101334200d83057131112a354688020c2ff9b31018218e8d4a51000a9849c6c12018218e8d4a51000a986e2a301111282103b9aca00a98413a1465020c2ff8e133121c2009a8218e8d4a5100058a984925b70e28e146c1221c2009a8218e8d4a5100058a986925b70e2e25202f06a401f0400b04aaa3134393939393903f0475393018307f40e6fa1705202985bd33f0101d70b3f9132e253d5f08c5206a045044313f09b103801c8cb3fcb3f028307f443820a625a0081211a5008f04c542730f07a065043157003f1013301fc5470875354ed44ed45ed478e2110235f0303f04f373737820a625a00f053109b108b103746b015144330f059f079ed67ed65ed64757fed118ebd4aaa8eb8eda2edfb313a3a3a3a3a04f04f5612c1008e2337373739393a3a3a3a820a625a00f0511079103810671056102510244ba0f05912f079e30ed8ed41edf101f2ff48018854798754798729561153a9ed44ed45ed478e1a10235f03820a625a00820311d158f0635270f07a03a503f10133ed67ed65ed647a7fed118e844aaadb3ced41edf101f2ff4f002a4aaa5b34383838383802f404304674505213f10133005a810081ba8e134aaa3b5f096c42f036317002f037128042f076e010265f066c628200d001ba925f03e001f1077001fe54798d2af095038e2630313838383a3a3b3b3b3b0a92f05292f058e210681027102610390a820a625a000bf059f079e13153a5f0265f07561128f08c54721020c2ff9b31018218e8d4a51000a9849c6c12018218e8d4a51000a986e2a353fcf021103d5f0d6c4281271001a152a0812710a98422b6085611547c1f5613f06b4903f0531fb98e2c571157115f08393b3b3c3c3c3c92f0549330f058e21068102710251024103a4999820a625a000af05912f079e03011112ff0265f0756175611f08c54721020c2ff9b31018218e8d4a51000a9849c6c12018218e8d4a51000a986e2205612b9e30211145614b6082bc30096353a38102770e30d4a4b4c003e57135f0b38383a3a3b3b3b820a625a003cf055107910381037104af059f07900180a812710a8500ba9045004b901fe94571057118e735611ab0011135610f02311115610018307f40e6fa130fa00d120c3008e158218174876e8001112f00401111201a8011111a904953057105611e2205613bc9257129130e256112eb98e225f0837373a3a3b3b3b3b820a625a0002f056107910381037104a41b0f059f079db31e0111116b60805e251f5a1014d01fe5610a1a3443020c2ff8e133121c2009a8218e8d4a5100058a984925b70e28e146c1221c2009a8218e8d4a5100058a986925b70e2e24cdd20c2ff8e133121c2009a8218e8d4a5100058a984925b70e28e146c1221c2009a8218e8d4a5100058a986925b70e2e251aba1512aa1515ca108111108820a625a002e0951800810574e0050106f2e1046515d4435021116022f021112f05b542960f0794670f08d4045f08d07a4175523f1013301f6313a3a3a3a3a04f05e53b3f08c5204a0561025018307f40e6fa1705202985bd33f0101d70b3f9132e2553005f09b103e01c8cb3fcb3f028307f4435373f08c5204a05314018307f40e6fa1705202985bd33f0101d70b3f9132e204034eee05f09b103a01c8cb3fcb3f028307f443820a625a00820311d15006f06350001e542580f07a07a51716445302f1013301c1a0b6e42804678b41780a41e29fb1df27397da3fe928d6fae8c5d0a6e75ad9da68fcdf9efd3416ad2652c044183fa21e42803678b41784315ebc72170a1dda8b306290ba921bb2477b3cb3ea82a849e88df088be3ba582c034183fa2181e47a00405301d7a09818e410c1780a41e29fb1df27397da3fe928d6fae8c5d0a6e75ad9da68fcdf9efd3416ad26500c183fa0737d0c100627800f97a678b10c1784315ebc72170a1dda8b306290ba921bb2477b3cb3ea82a849e88df088be3ba5800c183fa0737d0c100627800f97a678b10c05501fe82f0f2db50ca82af28655e6055eb11cd12a3836462898e75d4f779fb336d201942ac58048307f44301c8ca3f82f04ba69735ca53765ed6a709edb56c6ea236b7193a3b29a6b390c346f0f4340e4e588307f44301c8f40082f0a6cf09112e1b746540b2310263d97cf9e5ff39a8e9dc37f3ee863e913d736b42588307f443015400aac8f40082f0b1d9a56a685ac1700f038f1eb82c4eee8cf2d7e83c8c459b7bbb1490b1ba09c9588307f44301c8f40082f0eb81cb47eeae848dbe60a667e92d224966bb0e6d0f29f8d06df32469355122b3588307f44301dc82f0f2db50ca82af28655e6055eb11cd12a3836462898e75d4f779fb336d201942ac018307f40e6fa18200c4f001f2f4f4043001f4002182f04ba69735ca53765ed6a709edb56c6ea236b7193a3b29a6b390c346f0f4340e4e018307f40e6fa18200c4f001f2f4d23f3001ca3f215601dc82f02132af8346ebcf20b705e359e167f843a4f981f818b9cf006e3f3e9401f05961018307f40e6fa18200c4f001f2f4d33f3001cb3f2182f0cbc8e634a9700f7eeb3f5580d7c590b4e96370f5c2b604061301bbb1f7267278018307f40e6fa18200c4f001f2f4d33f3001cb3f215700d682f0d5387610eab4cdf828ae08fe6f50e716b90b6105f69bcfee3e05436102818b9b018307f40e6fa18200c4f001f2f4d31f3001cb1f0182f084e334e9d6776072a83214644483439f17fd87ed24cdac5eb3c83e2869fa4f8c018307f40e6fa18200c4f001f2f4d43001cc0201205a5b02012061620201485c5d0055f34fff4c1f50c3434c3f4c3f4c3f4cff4cff4cff4cff4cff4cff4cff4cff4cff4c3f4c3f4cff4cff4cfcc201f7d76d176fd90e8698180b8d8492f82f07d2018107d227c147d22180140aaff81dd09797a417867b9b3702092f82efc6b723f6cb2846e10bec57d6cef8495a6475f81e2d365eb5d471990e98f90c1008214dd4db630e98fea1800fd806d98f010c10082155d4a2f83ed98f000c1008215dd4c3628ea1876aa6d98f01845e0201485f6000aade21fa000182009998ba996c42d33fd4d158f09de030ed44d0fa00fa405331c705f2e1fb24f02a5326bc8e1d27fa44312c518c518c518b0710461035401454133df09c945f06db31e09410365f06e25e3113f10777007b1c5ea0192040fa2049c4208061a8208203d09020822625a02084017d784020840ee6b28020849502f900208605d21dba0020863a352944001bc3405be060000b3e0a3e910c200201206364020120717202012065660201486f700201206768020120696a00155018307f40e6fa130f01f8001f5018307f40e6fa130d3ff0130d70b0780201206b6c0201206d6e006909b0403c914970403c917214024072cfd401c072cfd40140728fd400c0728fc04072c7c04072cfc04072cfc04072cfc04072cff260004934cfc04074cfc040748fc040748fc04074c7c04074cfc04074cfc04074cfc04074cfc04c6000150060c1fd039be84c3c096000113c093400a0c1fd05a000075f1029a800134fa00f404d20101433080201207374020120777800296bb51343e803e903e903d01348ffd013d013d010c20201587576000b3d013e900c200015322042078072c7f2cff260020120797a0039d6440808f80e58f8b659fa802678b2c00e5ff8080e59f8080e59fe664c00555d3ff0101d33f0101d33f0101d33f0101d33fd33fd23f0101d23f0101d33f0101d33f0101d33f0101d4308004b4c881011a01cb1f18cb3f5006cf16500401cbff5801cb3f0101ca3f0101ca3f0101ca3fccc980201207d7e0201209d9e0201207f800201208b8c02012081820201208586005bf106ba66800e9ff8080e99f8080e99f8080e99f8080fd201802fa027a027a02699f8080ea180844883c0833882b4020120838400614c85003cf160101cb3fccc9c881021101cb1f18cb3f5006cf16500401cbff5801cb3f0101ca3f0101ca3f0101ca3fccc9800215d3ff0101d23f0101d33f0101d33f013180201208788020120898a00115d3ff0101d23f0131800114c85801cb1fcb3fc98003345bc87001cb1f8be455641412077697468647261772e8cf16c9800415f404f404d74cd0d4d3ff0101d33f0101fa40d3ff0101d33f0101d33f0101d43080201208d8e02012097980201208f900201209394000f5c88131f001cb1f80201209192000f32204c7c8072c7e0000f32204c7f8072c7e0020120959600174c88131f501cb1f0101cb3f80025083040248c1c37b2204c7cc072c7c04072cfe0001732204c7d0072c7c04072cfe0020120999a00416b4ffc040748fc04074cfc04074cfc04074ffc040748fc04074cfc04074cfc04c60201209b9c008f5c8500b01ca3f500901cb3f500701cb3f500501ca3f500301cbff0101ca3f0101cb3f0101cb3f0101ca3f0101cb3fccc9c881031101cb1f15cb3f5003cf1601cf160101cbffccc98000f32204c7dc072c7e0005d3214018072cfd4010072ffd60072cfc04072cff333c4f2722040c7c072c7c572cfd400f3c58073c5804072fff332600201209fa0020120a7a8020148a1a2020120a3a400214d3ff0101d23f0101d3ff0101d23f01318003b55bc87001cb1f8d0451559050481b1a5c5d5a59185d1a5bdb8ba0cf16c98020158a5a60021f780280fc803a646581096503e5ffe4e8400451c082080203c54d0ef3cbc88f040270c4870406480a864cc0068f8a50c00a84078806000c714c04060c1fd039be864fe8034648c1ff888303fe517c19fdc381494fc08443bd7c3cc4c94494060c1fd039be864fe8034648c1ff888303fe517c1dfdc3814197c08c8b0002517c19fdff81410ea00fc0104ea1400e049c42a61006a41007c012a411fe0020120a9aa020120afb0002df7c14368938642802fd012801e78b00e78b7a00651fe4c020120abac003f4f82801706dc85004cf1658cf16cb07f400c97020c8cb0113f400f400cb00c98020120adae00311c20043232c1540173c59400fe8084f2da44bd0032407ec020004f1c32208403e29fa94072c7c5b2cfd4013e808973c5940173c594903d00007e8084fd0032563c1da0020120b1b2008164920bc0690867f9798358ebca8f31f739bfb1a6d171ad5c6125e985239f08cab21ef62aea58d0d28167c1da384813c015d3232c0b281f2fff2740181413c1df8a020120b3b4020120b5b6000b0060103c1de00015009c3ec09c1620c1bc1da00017009cbec09c16204020bc1da000651c20043232c1540133c59401be8084b2da095ba58d5c540172c0659dc072c0857338b2169ffc40a684f3c4f2563332407ec020020120b9ba020120c6c7020120bbbc020158c0c1020158bdbe0035f2d00c10c746a52880054c22c80c10c746a52880054c32cd080d0401f319bc0997c154153c084411d7c1cdcdd6cd4d4d541a0060863a352944002a6114118060863a352944002a6189700024cc0d1c2720863a352944002a14016a413894c0eee79b089448a0863a352944002a612823865450e0863a352944002a6128148ce860863a352944002a6128389480a0863a352944002a6120bf006314c87c0997c1c8b0802388d548bc2094452a148c20863a352944002a6104e81408ea148420863a352944002a6128381b10a0001a8127105003a112812710a98401020120c2c3020120c4c5001d0060c1fd039be864f5c28ff80c1c200015320040728fc0a0c1fd10e0000735c28fe0000f20c1fd219be944a0020120c8c9020120d6d7020120cacb020120cdce00114018307f47c6fa5128013b5eda2edfb705302f08f908ae85b6c428218e8d4a5100066a858a904a17f8cc00e8f08e208e685341018307f40e6fa193fa00d192307fe220c0ff965f097070db31e05372f0265f0753a4f0215f0f313225c1008e1731325aa802f00412a904a3018218e8d4a51000a98613a08e1e325043a858a802f00412a904812710a904018218e8d4a51000a98412a058e2029130e25240f090020120cfd0020120d3d400373b68bb7ec83c23e427bc23b0402516dc36cc7814843c243a17c0dfe001453b68bb7edc151c00bc23e423a2fc2388244c38c354943c243a16db0cccc86e409fc0a0d101fe5351018307f40e6fa193fa00d192307fe220c0ff985f0a70707020db31e05382f0265f0753b4f0215f0f313225c1008e1731325aa802f00412a904a3018218e8d4a51000a98614a08e34325343a801a821f004a904812710a9045220018218e8d4a51000a98417a05aa805f00415a904018218e8d4a51000a98412a05003e2d200020301233b68bb7edc14c0bc23e422ba16db10a85fe0d5001f087c252517c11fdff83c258070bfc06000e2f08e208e655341018307f40e6fa193fa00d192307fe220c0ff965f097f70db31e05372f0265f0753a4f0215f0f303225c1008e16313203a313018218e8d4a51000a98602f004a98412a08e1c325024018218e8d4a51000a98401f00412a98401812710a98413a059e2019130e25240f090020120d8d9020148e0e1020120dadb020120ddde00451400fc23048830bfe6cc4060863a352944002a61271b048060863a352944002a61b8a001f73b68bb7edc14c0bc23e4239bfc23882398d4d04060c1fd039be864fe8034648c1ff888303fe5d7c25c081c36cc7814dcbc0997c1d4e93c0857c3c408d7c0c930402385cc80e8c4c060863a352944002a61806a007c012a4104a823858c40c060863a352944002a61006a007c012a4104e8167880644c3894903c2420dc000ae85b6c427f01e93b68bb7ed4d47c08441bd7c3ccd76f23ab94dd3c0997c1d510458830bfe6cc4060863a352944002a61271b048060863a352944002a61b889fc25249b2478c3a38c44d7c0d4888060c1fd039be864fe8034648c1ff888303fe597c19c1c36cc78154c7c25a597c0dc1c36cc7840bc01006a61389fe0df005f0870bfe7948da860863a352944002a6104e823845489a84068c060863a352944002a6104e83880f0bfe44c644c38806000ce5266018307f40e6fa193fa00d192307fe220c0ff965f0a7070db31e07022c00095106a5f0a208e3b21c2008e303010394876f096965f077070db31e1708127105006a98405f0044503a98404018218e8d4a51000a984ab0013a112b60994106a6c91e2e201b608019323b1bb68bb7ecc8d0d0d3c0c840d97c18830000c63aac9918cc13b513b517b51e756c07e900c007c41dc1ff6cc4c3b59fb597b591d1ffb4462bb507b7c407cbfdc25441a57c25ff8b620e200313b511c32208026664072c7c572cfc4f304b33244a0103c1da000f68200c4f2236ef2f2ed44d0fa003120f90104d08200c4f221d74ac002f2f4d43020fb04d0ed1eed537002c000927f32dec823fa0201cf16c9ed545466605266f1013770c8236d7ff1029a8200d00101cb1fcb3fc9d010374650f000926c218e1aed44d0fa00f901018200c4f104ba13f2f4028200c4f102baf2f4e2",
  "code_hash": "b1ed3af875b6a8878a0c914c03be387c297f79b38ad03c7eb78239313e57e70b",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "storage/user-upgrade.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/universal-dict.fc\";\n\nconst int user::code::version = 1;\n\n(cell) user::upgrade::pack_universal_storage(\n    slice master_address, slice owner_address, cell user_principals, int state,\n    int tracking_supply_index, int tracking_borrow_index, int dutch_auction_start_timestamp, cell backup_cell\n) method_id(0x153) {\n    cell storage = new_dict();\n    storage~udict_set_builder(\n        256, \"master_address\"H,\n        begin_cell().store_slice(master_address)\n    );\n    storage~udict_set_builder(\n        256, \"owner_address\"H,\n        begin_cell().store_slice(owner_address)\n    );\n    storage~udict_set_builder(\n        256, \"user_principals\"H,\n        begin_cell().store_dict(user_principals)\n    );\n    storage~udict_set_builder(\n        256, \"state\"H,\n        begin_cell().store_int(state, 64)\n    );\n    return storage;\n}\n\n(cell) user::upgrade::pack_universal_storage_after_v6(\n    slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2\n) method_id(0x1561) {\n    cell storage = new_dict();\n    storage~udict_set_builder(\n        256, \"master_address\"H,\n        begin_cell().store_slice(master_address)\n    );\n    storage~udict_set_builder(\n        256, \"owner_address\"H,\n        begin_cell().store_slice(owner_address)\n    );\n    storage~udict_set_builder(\n        256, \"user_principals\"H,\n        begin_cell().store_dict(user_principals)\n    );\n    storage~udict_set_builder(\n        256, \"state\"H,\n        begin_cell().store_int(state, 64)\n    );\n    storage~udict_set_builder(\n        256, \"user_rewards\"H,\n        begin_cell().store_dict(user_rewards)\n    );\n    storage~udict_set_builder(\n        256, \"backup_cell_1\"H,\n        begin_cell().store_maybe_ref(backup_cell_1)\n    );\n    storage~udict_set_builder(\n        256, \"backup_cell_2\"H,\n        begin_cell().store_maybe_ref(backup_cell_2)\n    );\n    return storage;\n}\n\n\n;; storage - universal storage packed by the previous version of code\n;; old_code_version - the previuos version of code, we might theoretically need it in some tricky cases. Hopefully, we won't\n;; new_data - data arriving from Master, packed exactly for empty/Blank contracts. We might need to parse it in case we expect new info from Master to incorporate into existing User contracts\nbuilder user::upgrade::unpack_universal_storage(\n    int old_code_version, cell storage,\n    cell new_data\n) method_id(0x157) {\n    builder new_storage = begin_cell();\n    \n    slice value = storage.upgrade_storage:get!(\"master_address\"H);\n    new_storage = new_storage.store_slice(value);\n\n    slice value = storage.upgrade_storage:get!(\"owner_address\"H);\n    new_storage = new_storage.store_slice(value);\n\n    slice value = storage.upgrade_storage:get!(\"user_principals\"H);\n    new_storage = new_storage.store_dict(value~load_dict());\n\n    slice value = storage.upgrade_storage:get!(\"state\"H);\n    new_storage = new_storage.store_int(value~load_int(64), 64);\n\n    return new_storage;\n}\n\nbuilder user::upgrade::unpack_universal_storage_version_after_update(\n    int old_code_version, cell storage,\n    cell new_data\n) method_id(0x1571) {\n    builder new_storage = begin_cell();\n    \n    slice value = storage.upgrade_storage:get!(\"master_address\"H);\n    new_storage = new_storage.store_slice(value);\n\n    slice value = storage.upgrade_storage:get!(\"owner_address\"H);\n    new_storage = new_storage.store_slice(value);\n\n    slice value = storage.upgrade_storage:get!(\"user_principals\"H);\n    new_storage = new_storage.store_dict(value~load_dict());\n\n    slice value = storage.upgrade_storage:get!(\"state\"H);\n    new_storage = new_storage.store_int(value~load_int(64), 64);\n    \n    slice value = storage.upgrade_storage:get!(\"tracking_supply_index\"H);\n    new_storage = new_storage.store_uint(value~load_uint(64), 64);\n\n    slice value = storage.upgrade_storage:get!(\"tracking_borrow_index\"H);\n    new_storage = new_storage.store_uint(value~load_uint(64), 64);\n \n    slice value = storage.upgrade_storage:get!(\"dutch_auction_start_timestamp\"H);\n    new_storage = new_storage.store_uint(value~load_uint(32), 32);\n    \n    slice value = storage.upgrade_storage:get!(\"backup_cell\"H);\n    new_storage = new_storage.store_ref(value~load_ref());\n    \n    return new_storage;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "storage/user-storage.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n\n{-\n  user_principals = Dict\n    slice(256) jetton_address -> int(64) value\n\n  user_rewards = Dict\n    slice(256) jetton_address -> int(64) tracking_index, int(64) tracking_accrued\n-}\n\n;; note move all global constants to one file\n;; Added to ^: nns2009: I'd say it makes sense to keep constants at their logical destination\n;; in this case here\nconst user_state::free = 0; ;; Fully unlocked state\nconst user_state::withdrawing = - (2 << 50); ;; \"Big\" negative number - big enough such that in case of some theoretical weird subtraction-by-one errors, this number can't be reached regardless\n\ncell user::storage::pack_init(\n  int user_version,\n  slice master_address, slice owner_address,\n  cell user_principals, int state\n) inline method_id(0x13001) {\n  return begin_cell()\n    .store_coins(user_version)\n    .store_slice(master_address)\n    .store_slice(owner_address)\n    ;; The part above ^ MUST stay fixed,\n    ;; because User's \"entry\" (=upgrade handling) code expects these fields\n    .store_dict(user_principals)\n    .store_int(state, 64)\n  .end_cell();\n}\n\ncell user::storage::pack(\n  int user_version,\n  slice master_address, slice owner_address,\n  cell user_principals, int state,\n  cell user_rewards, cell backup_cell_1, cell backup_cell_2\n) inline method_id(0x130) {\n  return begin_cell()\n    .store_coins(user_version)\n    .store_slice(master_address)\n    .store_slice(owner_address)\n    ;; The part above ^ MUST stay fixed,\n    ;; because User's \"entry\" (=upgrade handling) code expects these fields\n    .store_dict(user_principals)\n    .store_int(state, 64)\n    .store_dict(user_rewards)\n    .store_maybe_ref(backup_cell_1)\n    .store_maybe_ref(backup_cell_2)\n  .end_cell();\n}\n\n() user::storage::save (\n  int user_version,\n  slice master_address, slice owner_address,\n  cell user_principals, int state,\n  cell user_rewards, cell backup_cell_1, cell backup_cell_2\n) impure method_id(0x133) {\n  set_data(user::storage::pack(\n    user_version, master_address, owner_address,\n    user_principals, state,\n    user_rewards, backup_cell_1, backup_cell_2\n  ));\n}\n\n(int, slice, slice, cell, int, cell, cell, cell) user::storage::load () {\n  slice ds = get_data().begin_parse();\n  int code_version = ds~load_coins();\n  slice master_address = ds~load_msg_addr();\n  slice owner_address = ds~load_msg_addr();\n  cell user_principals = ds~load_dict();\n  int state = ds~load_int(64);\n  cell user_rewards = ds~load_dict();\n  cell backup_cell_1 = ds~load_maybe_ref();\n  cell backup_cell_2 = ds~load_maybe_ref();\n  \n  ;; note\n  ;; we cant add ds.end_parse() here because there is some amount of 0000 left in the store data if we just upgraded code version from < v6\n\n  ;; 34/ all of our user sc-s have code version >= 2, so there is 64 + 64 + 32 zeros and one REF after state variable in the store of all of the user sc-s\n  ;; so, in new version (v6) we will have in user load function\n  ;; cell user_rewards = ds~load_dict();\n  ;; cell backup_cell_1 = ds~load_maybe_ref();\n  ;; cell backup_cell_2 = ds~load_maybe_ref();\n  ;; that will load 3 nulls (when you have …000000000… and etc in the store, load_ref() from …00000000… will return null)\n  ;; so, in upgrade logic we will not change the storage, but on the firs sc invocation after upgrade store will re-write itself with \n  ;; .store_dict(user_rewards)\n  ;; .store_maybe_ref(backup_cell_1)\n  ;; .store_maybe_ref(backup_cell_2)\n\n  return (code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2);\n}\n\ncell user::storage::load_principals () inline {\n    (_, _, _, cell user_principals, _, _, _, _) = user::storage::load();\n    return user_principals;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "storage/master-upgrade.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/universal-dict.fc\";\n\n;; --------------- upgrade_config ---------------\n\n(cell) pack_upgrade_config(\n    int master_code_version, int user_code_version,\n    int timeout, int update_time, int freeze_time,\n    cell user_code,\n    cell new_master_code, cell new_user_code\n) inline {\n    return (\n        begin_cell()\n            .store_coins(master_code_version)\n            .store_coins(user_code_version)\n            .store_uint(timeout, 32)\n            .store_uint(update_time, 64)\n            .store_uint(freeze_time, 64)\n            .store_ref(user_code)\n            .store_maybe_ref(new_master_code)\n            .store_maybe_ref(new_user_code)\n    ).end_cell();\n}\n\n(int, int, int, int, int, cell, cell, cell) unpack_upgrade_config(cell config) inline {\n    slice cs = config.begin_parse();\n    return (\n        cs~load_coins(), cs~load_coins(),\n        cs~load_uint(32), cs~load_uint(64), cs~load_uint(64),\n        cs~load_ref(), cs~load_maybe_ref(), cs~load_maybe_ref()\n    );\n}\n\nint upgrade_config:user_code_version(cell config) inline {\n    slice cs = config.begin_parse();\n    cs~load_coins(); ;; Skip master_code_version\n    return cs~load_coins(); ;; Return user_code_version\n}\n\n;; --------------- Master's universal_storage ---------------\n\n(cell) master::upgrade::pack_universal_storage(\n    cell meta, cell upgrade_config, cell asset_config_collection,\n    int if_active, slice oracles_info, slice admin, cell tokens_keys,\n     cell asset_dynamics_collection\n) method_id(0x153) {\n    cell storage = new_dict();\n    storage~udict_set_builder(\n        256, \"meta\"H,\n        begin_cell().store_ref(meta)\n    );\n    storage~udict_set_builder(\n        256, \"upgrade_config\"H,\n        begin_cell().store_ref(upgrade_config)\n    );\n    storage~udict_set_builder(\n        256, \"asset_config_collection\"H,\n        begin_cell().store_dict(asset_config_collection)\n    );\n    storage~udict_set_builder(\n        256, \"if_active\"H,\n        begin_cell().store_int(if_active, 8)\n    );\n     storage~udict_set_builder(\n        256, \"oracles_info\"H,\n        begin_cell().store_slice(oracles_info)\n    );\n    storage~udict_set_builder(\n        256, \"admin\"H,\n        begin_cell().store_slice(admin)\n    );\n    storage~udict_set_builder(\n        256, \"tokens_keys\"H,\n        begin_cell().store_dict(tokens_keys)\n    );\n    storage~udict_set_builder(\n        256, \"asset_dynamics_collection\"H,\n        begin_cell().store_dict(asset_dynamics_collection)\n    );\n    return storage;\n}\n\n(cell) master::upgrade::unpack_universal_storage(cell storage) method_id(0x157) {\n    builder new_storage = begin_cell();\n\n    slice value = storage.upgrade_storage:get!(\"meta\"H);\n    new_storage = new_storage.store_ref(value~load_ref());\n\n    slice value = storage.upgrade_storage:get!(\"upgrade_config\"H);\n    new_storage = new_storage.store_ref(value~load_ref());\n\n    builder new_storage_ref = begin_cell();\n    {\n        slice value = storage.upgrade_storage:get!(\"asset_config_collection\"H);\n        new_storage_ref = new_storage_ref.store_dict(value~load_dict());\n\n        slice value = storage.upgrade_storage:get!(\"if_active\"H);\n        new_storage_ref = new_storage_ref.store_int(value~load_int(8), 8);\n\n        slice value = storage.upgrade_storage:get!(\"admin\"H);\n        new_storage_ref = new_storage_ref.store_slice(value);\n\n        slice value = storage.upgrade_storage:get!(\"admin_pk\"H);\n        new_storage_ref = new_storage_ref.store_slice(value);\n        \n        slice value = storage.upgrade_storage:get!(\"tokens_keys\"H);\n        new_storage_ref = new_storage_ref.store_dict(value~load_dict());\n\n        slice value = storage.upgrade_storage:get!(\"wallet_to_master\"H);\n        new_storage_ref = new_storage_ref.store_dict(value~load_dict());\n    }\n    new_storage = new_storage.store_ref(new_storage_ref.end_cell());\n\n    slice value = storage.upgrade_storage:get!(\"asset_dynamics_collection\"H);\n    new_storage = new_storage.store_dict(value~load_dict());\n\n    return new_storage.end_cell();\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-supply.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/constants.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/logs.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../messages/supply-message.fc\";\n#include \"../logic/addr-calc.fc\";\n#include \"../logic/master-get-methods.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/utils.fc\";\n\ncell master_core_logic_supply_asset_unchecked(\n  int query_id, int user_version, cell user_code,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int asset_id, slice owner_address, int amount,\n  int message_send_mode, int forward_ton_amount, cell custom_response_payload,\n  int fwd_fee, int msg_value_for_fee_check\n) impure {\n  ;; Update tracking indexes\n  (_, _, _, _, _, _, _, _, _, _, _, _, int dust, int max_token_amount, _, _, _, _, _\n  ) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n  asset_dynamics_collection~update_old_rates_and_provided_asset_id(\n    asset_config_collection, asset_id, 0\n  );\n\n  (\n    int s_rate, int b_rate,\n    int total_supply_principal, int total_borrow_principal,\n    int last_accrual, int token_balance,\n    int tracking_supply_index, int tracking_borrow_index,\n    int awaited_supply\n  ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  int total_supply_principal_with_awaited_supply =\n    total_supply_principal + principal_value_supply_calc(s_rate, awaited_supply);\n\n  cell supply_user_message = pack_supply_user_message(\n      query_id,\n      asset_id, amount,\n      s_rate, b_rate,\n      dust, max_token_amount,\n      total_supply_principal_with_awaited_supply, total_borrow_principal,\n      tracking_supply_index, tracking_borrow_index,\n      forward_ton_amount, custom_response_payload\n    );\n\n  int awaited_supply_with_incoming_amount = awaited_supply + amount;\n\n  int enough_fee = supply_min_attachment(fwd_fee, supply_user_message) + forward_ton_amount;\n\n  throw_unless(\n    error::incoming_asset_transaction_fees,\n    msg_value_for_fee_check > enough_fee\n  );\n\n  asset_dynamics_collection~asset_dynamics_collection:set_packed(\n    asset_id,\n    s_rate, b_rate,\n    total_supply_principal, total_borrow_principal,\n    last_accrual, token_balance,\n    tracking_supply_index, tracking_borrow_index,\n    awaited_supply_with_incoming_amount\n  );\n\n  send_message_to_lending_wallet(\n    BLANK_CODE(), user_version, user_code, owner_address,\n    supply_user_message,\n    message_send_mode\n  );\n\n  return asset_dynamics_collection;\n}\n\ncell supply_jetton(\n  int query_id, int user_version, cell user_code,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int msg_value, int fwd_fee,\n  int asset_id, slice owner_address, int amount, int forward_ton_amount, cell custom_response_payload\n) impure inline {\n  return master_core_logic_supply_asset_unchecked(\n    query_id, user_version, user_code,\n    asset_config_collection, asset_dynamics_collection,\n    asset_id, owner_address, amount, 64, forward_ton_amount, custom_response_payload,\n    fwd_fee, msg_value + 1 ;; offset by 1 because inside comparison is strict\n  );\n}\n\n() supply_master_jetton_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int jetton_op_code, int query_id, int jetton_amount, slice from_address, int user_version, cell user_code ;; jetton tx body params\n) impure inline {\n  int include_user_code = in_msg_body~load_bool_ext();\n  (slice token_id, int found) = tokens_keys.udict_get?(256, addr_hash);\n  slice recipient_address = in_msg_body~load_msg_addr();\n\tint forward_ton_amount = in_msg_body~load_amount();\n  cell custom_response_payload = in_msg_body~load_ref();\n  in_msg_body.end_parse();\n\n  ifnot (is_valid_address?(recipient_address)) {\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(error::invalid_address_provided).end_cell(), 0\n    );\n    return ();\n  }\n\n  ifnot (is_valid_custom_response_payload?(custom_response_payload)) {\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(error::custom_response_payload_too_big).end_cell(), 0\n    );\n    return ();\n  }\n\n  asset_dynamics_collection = supply_jetton(\n    query_id, user_version, include_user_code ? user_code : null(),\n    asset_config_collection, asset_dynamics_collection,\n    msg_value, fwd_fee,\n    token_id~load_asset_id(), ;; jetton_master_address, <- I am not sure we want this transformation anymore\n    recipient_address, jetton_amount, forward_ton_amount, custom_response_payload\n  );\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection, \n    if_active, oracles_info, admin, tokens_keys,\n    asset_dynamics_collection\n  );\n  return ();\n}\n\ncell supply_ton(\n  int query_id, int user_version, cell user_code,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int msg_value, int supply_amount, int fwd_fee,\n  slice owner_address, int forward_ton_amount, cell custom_response_payload\n) impure inline {\n  ;; Withhold some amount of TONs for blockchain fees\n  raw_reserve(supply_amount, reserve::AT_MOST + 2);\n  return master_core_logic_supply_asset_unchecked(\n    query_id, user_version, user_code,\n    asset_config_collection, asset_dynamics_collection,\n    constants::ton_asset_id, owner_address, supply_amount,\n    sendmode::CARRY_ALL_BALANCE, ;; <- in combination with raw_reserve with mode=4\n    ;;^ should resend the whole value of the original message minus \"amount\" and fees\n    forward_ton_amount, custom_response_payload,\n    fwd_fee, msg_value - supply_amount\n  );\n}\n\n() supply_master_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  (\n    _, int user_version, _, _, _, cell user_code, _, _\n  ) = upgrade_config.unpack_upgrade_config();\n  int include_user_code = in_msg_body~load_bool_ext(); ;; bool\n\n  int supply_amount = in_msg_body~load_amount();\n  slice recipient_address = in_msg_body~load_msg_addr();\n\tint forward_ton_amount = in_msg_body~load_amount();\n  cell custom_response_payload = in_msg_body~load_ref();\n  in_msg_body.end_parse();\n\n  throw_unless(error::invalid_address_provided, is_valid_address?(recipient_address));\n  throw_unless(error::custom_response_payload_too_big, is_valid_custom_response_payload?(custom_response_payload));\n\n  asset_dynamics_collection = supply_ton(\n     query_id, user_version, include_user_code ? user_code : null(),\n    asset_config_collection, asset_dynamics_collection,\n    msg_value, supply_amount, fwd_fee,\n    recipient_address, forward_ton_amount, custom_response_payload\n  );\n\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection, \n    if_active, oracles_info, admin, tokens_keys,\n    asset_dynamics_collection\n  );\n  return ();\n}\n\n() supply_success_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  (slice owner_address, ;; add new user principal to log\n    int asset_id, int amount_supplied, int user_new_principal,\n    int repay_amount_principal, int supply_amount_principal, cell custom_response_payload) = parse_supply_success_message(in_msg_body);\n\n  ;; Verify this is a message from lending-user smart contract\n\n  throw_unless(\n    error::supply_success_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n\n  (int s_rate, int b_rate,\n   int total_supply_principal, int total_borrow_principal,\n   int last_accrual, int token_balance,\n   int tracking_supply_index, int tracking_borrow_index,\n   int awaited_supply\n  ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  int new_total_supply = total_supply_principal + supply_amount_principal;\n  int new_total_borrow = total_borrow_principal - repay_amount_principal;\n\n  int new_awaited_supply = awaited_supply - amount_supplied;\n\n  asset_dynamics_collection~asset_dynamics_collection:set_packed(\n    asset_id,\n    s_rate, b_rate,\n    new_total_supply,\n    new_total_borrow,\n    last_accrual,\n    token_balance + amount_supplied, ;; update asset balance\n    ;; ^ We couldn't update it when receiving Supply,\n    ;; because there is no guarantee it would succeed\n    tracking_supply_index, tracking_borrow_index,\n    new_awaited_supply\n  );\n  \n  cell log_data = begin_cell()\n    .store_uint(log::supply_success, 8) ;; supply code\n    .store_slice(owner_address) ;; user addr\n    .store_slice(sender_address) ;; user sc addr\n    .store_uint(now(), 32) ;; current time\n    .store_ref(begin_cell() ;; attached asset data\n      .store_uint(asset_id, 256) \n      .store_uint(amount_supplied, 64) \n      .store_int(user_new_principal, 64) \n      .store_int(new_total_supply, 64) \n      .store_int(new_total_borrow, 64) \n      .store_uint(s_rate, 64) \n      .store_uint(b_rate, 64) \n      .end_cell())\n    .store_ref(begin_cell().end_cell()) ;; redeemed asset data (nothic cause its supply)\n    .end_cell();\n\n    emit_log_simple(log_data);\n\n    ;; deducting fee::log_tx is NOT neccessary because raw_reserve mode 4 accounts for action phase\n    ;;   (including logs - external out messages) fees\n\n    raw_reserve(0, 4);\n\n  cell body = pack_supply_success_excess_message();\n  slice custom_response_payload_open = custom_response_payload.begin_parse();\n  ifnot (custom_response_payload_open.slice_empty?()) {\n    body = pack_supply_excess_message_with_data(query_id, custom_response_payload);\n  }\n\n  send_message(\n    owner_address,\n    0,\n    body,\n    sendmode::CARRY_ALL_BALANCE \n  );\n\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection, \n    if_active, oracles_info, admin, tokens_keys,\n    asset_dynamics_collection\n  );\n  return ();\n}\n\n() supply_fail_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  var (owner_address, transferred_asset_id, transferred_amount, forward_ton_amount, custom_response_payload) = parse_supply_fail_message(in_msg_body);\n\n  ;; Verify this is a message from lending-user smart contract\n  \n  throw_unless(\n    error::supply_fail_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n  \n  (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n\n  (int s_rate, int b_rate,\n    int total_supply_principal, int total_borrow_principal,\n    int last_accrual, int token_balance,\n    int tracking_supply_index, int tracking_borrow_index,\n    int awaited_supply\n  ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(transferred_asset_id);\n\n  int new_awaited_supply = awaited_supply - transferred_amount;\n\n  asset_dynamics_collection~asset_dynamics_collection:set_packed(\n    transferred_asset_id,\n    s_rate, b_rate,\n    total_supply_principal, total_borrow_principal,\n    last_accrual, token_balance,\n    tracking_supply_index, tracking_borrow_index,\n    new_awaited_supply\n  );\n\n  int supply_fail_fees = modest_fwd_fee_estimation(fwd_fee) + fee::supply_fail;\n\n  msg_value -= supply_fail_fees;\n\n  if (transferred_asset_id == constants::ton_asset_id) {\n    raw_reserve(my_balance - transferred_amount - msg_value, reserve::REGULAR);\n  } else {\n    raw_reserve(0, 4);\n  }\n  \n  send_asset_ext(\n    owner_address, query_id,\n    jw_address_hash, transferred_amount,\n    forward_ton_amount,\n    pack_supply_fail_message_with_data(query_id, custom_response_payload),\n    sendmode::CARRY_ALL_BALANCE \n  );\n\n  ;; ^ Note how we don't check if that asset is available for refund\n  ;; (same as with liquidation unsatisfied, more on this - there)\n\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection,\n    if_active, oracles_info, admin, tokens_keys,\n    asset_dynamics_collection\n  );\n\n  return ();\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-revert-call.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../messages/idle-message.fc\";\n#include \"../messages/liquidate-message.fc\";\n#include \"../messages/supply-message.fc\";\n#include \"../messages/upgrade-header.fc\";\n#include \"../logic/addr-calc.fc\";\n#include \"../logic/master-get-methods.fc\";\n#include \"../logic/tx-utils.fc\";\n\n() revert_call_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  slice owner_address = in_msg_body~load_msg_addr();\n\n  ;; Verify this is a message from lending-user smart contract\n  throw_unless(\n    error::revert_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n\n  slice revert_body = in_msg_body.preload_ref().begin_parse();\n\n  (int user_code_version, cell upgrade_info_cell,\n   int upgrade_exec\n  ) = revert_body~user::upgrade::load_header();\n\n  ;; upgrade_exec - why does it even exist?\n  ;; throw_if(error::cant_revert_upgrade_exec, upgrade_exec);\n  \n  ;; It should be possible to revert requests with upgrade_exec,\n  ;; but that would require master.fc to also have access to the specific on_upgrade function that was supposed to be executed on the User.\n  ;; This specific Master version doesn't have it yet.\n  ;; todo: !!!! whoever came up with the idea for upgrade_exec,\n  ;; take a look at this code\n\n  ;; Revert is possible in two cases: if upgrade fails or if opcode does not exist\n  ;; Process sends back the assets in case of these situations\n  ;; As of now it is not neccessary to check why this happened, always return\n\n  ;; Specific revert operations might depend on the specific user_code_version in the future\n\n  int revert_op = revert_body~load_op_code();\n  int revert_query_id = revert_body~load_query_id();\n\n  if (revert_op == op::supply_user) {\n    ;; As this has to do with supply refund,\n    ;; the code is very similar to op::supply_fail\n    ;; except that the authenticity check had already been made\n    (int asset_id, int supply_amount_current, int s_rate, int b_rate, _, _, _, _, _, _, _, _) = parse_supply_user_message(revert_body);\n\n    (int s_rate, int b_rate,\n      int total_supply_principal, int total_borrow_principal,\n      int last_accrual, int token_balance,\n      int tracking_supply_index, int tracking_borrow_index,\n      int awaited_supply\n    ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n    int new_awaited_supply = awaited_supply - supply_amount_current;\n\n    asset_dynamics_collection~asset_dynamics_collection:set_packed(\n      asset_id,\n      s_rate, b_rate,\n      total_supply_principal, total_borrow_principal,\n      last_accrual, token_balance,\n      tracking_supply_index, tracking_borrow_index,\n      new_awaited_supply\n    );\n\n    msg_value -= fee::revert_call;\n\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n    send_asset(\n      owner_address, revert_query_id,\n      jw_address_hash, supply_amount_current,\n      msg_value\n      ;; todo: !! Need to send some kind of info to the Owner?\n    );\n\n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection,\n      if_active, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n\n    return ();\n  }\n\n  if (revert_op == op::withdraw_user) {\n    ;; No assets are attached with request for Withdraw\n    ;; => It's enough to only refund attached (for network fees) TONs\n    ;; (no need to parse message)\n    send_message(\n      owner_address,\n      0,\n      null(), ;; todo: !! Need to send some kind of info to the Owner?\n      sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n\n    return ();\n  }\n\n  if (revert_op == op::liquidate_user) {\n    ;; As this has to do with liquidate refund,\n    ;; the code is very similar to op::liquidate_unsatisfied\n    ;; except that the authenticity check had already been made\n    (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed,\n     int collateral_asset_id, int min_collateral_amount,\n     slice liquidator_address,\n     int transferred_asset_id, int transferred_amount,\n     int forward_ton_amount, cell custom_response_payload\n     )\n      = parse_liquidate_user_message(revert_body);\n\n    msg_value -= fee::revert_call;\n\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n    send_asset(\n      liquidator_address, revert_query_id,\n      jw_address_hash, transferred_amount,\n      msg_value\n      ;; todo: !! Need to send some kind of info to the Owner?\n    );\n\n    return ();\n  }\n\n  if (revert_op == op::idle_user) {\n    ;; It's enough to only refund attached (for network fees) TONs\n    ;; It is very tempting to just reuse the code for the revert of op::withdraw_user,\n    ;; but in this case we need to refund to the Originator (who can be either Owner or Admin)\n    ;; It doesn't matter too much, because of the little amount in question,\n    ;; but let's do it properly\n    (cell tokens_keys, slice originator_address) = parse_idle_user_message(revert_body);\n\n    send_message(\n      originator_address,\n      0,\n      null(), ;; todo: !! Need to send some kind of info to the Originator?\n      sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n\n    return ();\n  }\n\n  throw(error::we_screwed_up_revert);\n  ;; Code really shouldn't reach here\n  ;; The only possible messages/requests to revert are the incoming requests\n  ;; (Supply, Withdraw, Liquidate)\n  ;; Intermediate requests (e.g. op::withdraw_success) are not possible to revert,\n  ;; because by that point the asset had already been sent\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "storage/master-storage.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n\n(cell) master::storage::pack(\n  cell meta, cell upgrade_config,\n  cell asset_config_collection,\n  int if_active, slice oracles_info, slice admin,\n  cell tokens_keys,  \n  cell asset_dynamics_collection\n) inline {\n  return (\n    begin_cell()\n      .store_ref(meta)\n      .store_ref(upgrade_config)\n      .store_ref(\n        begin_cell()\n          .store_dict(asset_config_collection)\n          .store_int(if_active, 8)\n          .store_slice(admin)\n          .store_slice(oracles_info) ;; uint8 num_oracles, uint8 threshold, ^cell oracles\n          .store_dict(tokens_keys)\n        .end_cell())\n      .store_dict(asset_dynamics_collection)\n      .end_cell()\n  );\n}\n\n() master::storage::save (\n  cell meta, cell upgrade_config,\n  cell asset_config_collection,\n  int if_active, slice oracles_info, slice admin,\n  cell tokens_keys,  \n  cell asset_dynamics_collection\n) impure {\n  set_data(\n    master::storage::pack(\n      meta, upgrade_config, asset_config_collection,\n      if_active, oracles_info, admin, tokens_keys, \n      asset_dynamics_collection\n    )\n  );\n}\n\n(cell, cell, cell, int, slice, slice, cell, cell) master::storage::load () inline {\n  slice ds = get_data().begin_parse();\n  cell meta = ds~load_ref();\n  cell upgrade_config = ds~load_ref();\n  cell marketConfig = ds~load_ref();\n  slice unpacked_marked_config = marketConfig.begin_parse();\n  cell asset_config_collection = unpacked_marked_config~load_dict();\n  int if_active = unpacked_marked_config~load_int(8);\n  slice admin = unpacked_marked_config~load_msg_addr();\n  slice oracles_info = unpacked_marked_config~load_bits_refs(33, 1);\n  cell tokens_keys = unpacked_marked_config~load_dict();\n  unpacked_marked_config.end_parse();\n  cell asset_dynamics_collection = ds~load_dict();\n  ds.end_parse();\n  return (meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection);\n}\n \n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/withdraw-message.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/ton.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../external/stdlib.fc\";\n\n;; --------------- op::withdraw_master ---------------\n\n(int, int, slice, int, cell, int, cell) parse_withdraw_master_message(slice cs) {\n\tint asset_id = cs~load_asset_id();\n\tint amount = cs~load_amount();\n\tslice recipient_addr = cs~load_msg_addr();\n\tint include_user_code = cs~load_bool_ext();\n\tint forward_ton_amount = cs~load_amount();\n\tcell custom_response_payload = cs~load_ref();\n\tcell prices_with_signature_packed = cs~load_ref();\n\tcs.end_parse();\n\n\tif (prices_with_signature_packed.begin_parse().slice_empty?()){\n\t\treturn (asset_id, amount, recipient_addr, include_user_code, null(), forward_ton_amount, custom_response_payload);\n\t}\n\n\treturn (asset_id, amount, recipient_addr, include_user_code, prices_with_signature_packed, forward_ton_amount, custom_response_payload);\n}\n\n;; --------------- op::withdraw_user ---------------\n\n;; ??? Should we send s/b-rate separately?, since it's obtainable from the asset_dynamics_collection\ncell pack_withdraw_user_message(\n\tint query_id,\n\tint asset_id, int withdraw_amount_current,\n\tint s_rate, int b_rate,\n\tcell asset_config_collection, cell asset_dynamics_collection,\n\tcell prices_packed, slice recipient_address,\n\tint forward_ton_amount, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::withdraw_user) ;; 32\n\t\t.store_query_id(query_id) ;; 64\n\t\t.store_asset_id(asset_id) ;; 256\n\t\t.store_amount(withdraw_amount_current) ;; 64\n\t\t.store_sb_rate(s_rate) ;; 64\n\t\t.store_sb_rate(b_rate) ;; 64\n\t\t.store_slice(recipient_address) ;; 267\n\t\t.store_ref(\n\t\t\tbegin_cell()\n\t\t\t\t.store_dict(asset_config_collection) ;; 1\n\t\t\t\t.store_dict(asset_dynamics_collection) ;; 1\n\t\t\t\t.store_dict(prices_packed) \n\t\t\t\t.store_amount(forward_ton_amount)\n\t\t\t\t.store_ref(custom_response_payload)\n\t\t\t\t.end_cell())\n\t\t.end_cell();\n}\n\n(int, int, int, int, slice, cell, cell, cell, int, cell) parse_withdraw_user_message(slice cs) {\n\tslice rest = cs.preload_ref().begin_parse();\n\treturn (\n\t\tcs~load_asset_id(),\n\t\tcs~load_amount(),\n\t\tcs~load_sb_rate(),\n\t\tcs~load_sb_rate(),\n\t\tcs~load_msg_addr(),\n\t\trest~load_dict(),\n\t\trest~load_dict(),\n\t\trest~load_dict(),\n\t\trest~load_amount(),\n\t\trest~load_ref()\n\t);\n}\n\n;; --------------- op::withdraw_collateralized ---------------\n\ncell pack_withdraw_collateralized_message(\n\tint query_id,\n\tslice owner_address, int asset_id,\n\tint withdraw_amount_current, int user_new_principal,\n\tint borrow_amount_principal, int reclaim_amount_principal, slice recipient_address,\n\tint forward_ton_amount, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::withdraw_collateralized)\n\t\t.store_query_id(query_id)\n\t\t.store_slice(owner_address)\n\t\t.store_asset_id(asset_id)\n\t\t.store_amount(withdraw_amount_current)\n\t\t.store_principal(user_new_principal)\n\t\t.store_principal(borrow_amount_principal)\n\t\t.store_principal(reclaim_amount_principal)\n\t\t.store_ref(\n\t\t\tbegin_cell()\n\t\t\t\t.store_slice(recipient_address)\n\t\t\t\t.store_amount(forward_ton_amount)\n\t\t\t\t.store_ref(custom_response_payload)\n\t\t\t\t.end_cell())\n\t\t.end_cell();\n}\n\n(slice, int, int, int, int, int, slice, int, cell) parse_withdraw_collateralized_message(slice cs) {\n\tslice rest = cs.preload_ref().begin_parse();\n\treturn (\n\t\tcs~load_msg_addr(), ;; owner_address\n\t\tcs~load_asset_id(),\n\t\tcs~load_amount(),\n\t\tcs~load_principal(),\n\t\tcs~load_principal(),\n\t\tcs~load_principal(),\n\t\trest~load_msg_addr(), ;; recipient_address\n\t\trest~load_amount(),\n\t\trest~load_ref() ;; custom_response_payload\n\t);\n}\n\n;; --------------- op::withdraw_success ---------------\n\nbuilder pack_withdraw_success_message(\n\tint query_id, int asset_id, int principal_amount,\n    int tracking_supply_index, int tracking_borrow_index\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::withdraw_success)\n\t\t.store_query_id(query_id)\n\t\t.store_asset_id(asset_id)\n\t\t.store_principal(principal_amount)\n\t\t.store_tracking_index(tracking_supply_index)\n\t\t.store_tracking_index(tracking_borrow_index);\n}\n\n(int, int, int, int) parse_withdraw_success_message(slice cs) {\n\treturn (\n\t\tcs~load_asset_id(),\n\t\tcs~load_principal(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_tracking_index()\n\t);\n}\n\n;; --------------- op::withdraw_fail ---------------\n\nbuilder pack_withdraw_fail_message(\n\tint query_id, int asset_id, int principal_amount\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::withdraw_fail)\n\t\t.store_query_id(query_id)\n\t\t.store_asset_id(asset_id)\n\t\t.store_principal(principal_amount);\n}\n\n(int, int) parse_withdraw_fail_message(slice cs) {\n\tint asset_id = cs~load_asset_id();\n\tint principal_amount = cs~load_principal();\n\treturn (asset_id, principal_amount);\n}\n\n;; --------------- op::withdraw_***_excess ---------------\n;; Withdraw excess message - refund extra TON attachment back to owner\ncell pack_withdraw_excess_message(int op, int query_id) {\n\treturn begin_cell()\n\t\t.store_op_code(op)\n\t\t.store_query_id(query_id)\n\t\t.end_cell();\n}\n\ncell pack_withdraw_excess_message_with_data(int op, int query_id, cell custom_response_payload) {\n\treturn begin_cell()\n\t\t.store_op_code(op)\n\t\t.store_query_id(query_id)\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\ncell pack_withdraw_success_excess_message(int op, int query_id) {\n\treturn begin_cell()\n\t\t.store_op_code(0)\n\t\t.store_slice(\"EVAA withdraw.\")\n\t\t.end_cell();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/upgrade-header.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/basic-types.fc\";\n\n(builder) user::upgrade::store_header(\n\tbuilder source, int user_version, cell upgrade_info,\n\tint upgrade_exec\n) method_id(666) {\n\tsource = (\n\t\tsource\n\t\t\t.store_coins(user_version)\n\t\t\t.store_maybe_ref(upgrade_info)\n\t\t\t.store_int(upgrade_exec, 2)\n\t);\n\treturn source;\n}\n\n;; Required for compability of upgrades from v4 and v5 version.\n;; This method must have ID 41 for user contract (user.fc)\n(builder) user::upgrade::store_header_compat(\n\tbuilder source, int user_version, cell upgrade_info,\n\tint upgrade_exec\n) {\n\treturn user::upgrade::store_header(source, user_version, upgrade_info, upgrade_exec);\n}\n\n(slice, (int, cell, int)) user::upgrade::load_header(slice cs) {\n\tint user_version = cs~load_coins();\n\tcell upgrade_info = cs~load_maybe_ref();\n\tint upgrade_exec = cs~load_bool_ext();\n\n\treturn (cs,\n\t\t(user_version, upgrade_info,\n\t\tupgrade_exec)\n\t);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/supply-message.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/ton.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../constants/op-codes.fc\";\n\n;; --------------- op::supply_user ---------------\n;; Supply request message\ncell pack_supply_user_message(\n\tint query_id,\n\tint asset_id, int supply_amount_current,\n\tint s_rate, int b_rate,\n\tint dust, int max_token_amount,\n\tint total_supply, int total_borrow,\n\tint tracking_supply_index, int tracking_borrow_index,\n\tint forward_ton_amount, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::supply_user) ;; 32\n\t\t.store_query_id(query_id) ;; 64\n\t\t.store_asset_id(asset_id) ;; 256\n\t\t.store_amount(supply_amount_current) ;; 64\n\t\t.store_sb_rate(s_rate) ;; 64\n\t\t.store_sb_rate(b_rate) ;; 64\n\t\t.store_uint(dust, 64)\n\t\t.store_uint(max_token_amount, 64)\n\t\t.store_principal(total_supply) ;; 64\n\t\t.store_principal(total_borrow) ;; 64\n\t\t.store_tracking_index(tracking_supply_index)\n\t\t.store_tracking_index(tracking_borrow_index)\n\t\t.store_amount(forward_ton_amount) ;; 64\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\n(int, int, int, int, int, int, int, int, int, int, int, cell) parse_supply_user_message(slice cs) {\n\treturn (\n\t\tcs~load_asset_id(),\n\t\tcs~load_amount(),\n\t\tcs~load_sb_rate(),\n\t\tcs~load_sb_rate(),\n\t\tcs~load_uint(64),\n\t\tcs~load_uint(64),\n\t\tcs~load_principal(),\n\t\tcs~load_principal(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_amount(),\n\t\tcs~load_ref()\n\t);\n}\n\n;; --------------- op::supply_success ---------------\n;; Supply success (response) message\ncell pack_supply_success_message(\n\tint query_id, slice owner_address,\n\tint asset_id, int amount_supplied, int user_new_principal,\n\tint repay_amount_principal, int supply_amount_principal, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::supply_success);; 32\n\t\t.store_query_id(query_id) ;; 64\n\t\t.store_slice(owner_address) ;; 256\n\t\t.store_asset_id(asset_id) ;; 256\n\t\t.store_amount(amount_supplied);; 64\n\t\t.store_principal(user_new_principal);; 64\n\t\t.store_principal(repay_amount_principal);; 64\n\t\t.store_principal(supply_amount_principal)\t;; 64\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\n(slice, int, int, int, int, int, cell) parse_supply_success_message(slice cs) {\n\treturn (\n\t\tcs~load_msg_addr(), ;; owner_address\n\t\tcs~load_asset_id(),\n\t\tcs~load_amount(),\n\t\tcs~load_principal(),\n\t\tcs~load_principal(),\n\t\tcs~load_principal(),\n\t\tcs~load_ref()\n\t);\n}\n\n;; --------------- op::supply_fail ---------------\ncell pack_supply_fail_message(\n\tint query_id, slice owner_address,\n\tint asset_id, int amount, int forward_ton_amount, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::supply_fail)\n\t\t.store_query_id(query_id)\n\t\t.store_slice(owner_address)\n\t\t.store_asset_id(asset_id)\n\t\t.store_amount(amount)\n\t\t.store_amount(forward_ton_amount)\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\n(slice, int, int, int, cell) parse_supply_fail_message(slice cs) {\n\treturn (\n\t\tcs~load_msg_addr(),\n\t\tcs~load_asset_id(),\n\t\tcs~load_amount(),\n\t\tcs~load_amount(),\n\t\tcs~load_ref()\n\t);\n}\n\n;; --------------- op::supply_excess ---------------\n;; Supply excess message - refund extra TON attachment back to owner\ncell pack_supply_excess_message_with_data(int query_id, cell custom_response_payload) {\n\treturn begin_cell()\n\t\t.store_op_code(op::supply_excess)\n\t\t.store_query_id(query_id)\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\ncell pack_supply_fail_message_with_data(int query_id, cell custom_response_payload) {\n\treturn begin_cell()\n\t\t.store_op_code(op::supply_fail_excess)\n\t\t.store_query_id(query_id)\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\ncell pack_supply_success_excess_message() {\n\treturn begin_cell()\n\t\t.store_op_code(0)\n\t\t.store_slice(\"EVAA supply.\")\n\t\t.end_cell();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/liquidate-message.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../external/ton.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../constants/errors.fc\";\n\n;; ---------- op::liquidate_master ----------\n\n(slice, slice, int, int, int, int, int, cell, cell) parse_liquidate_master_message(slice cs) {\n\tslice borrower_address = cs~load_msg_addr(); ;;256\n\tslice liquidator_address = cs~load_msg_addr(); ;;256\n\tint collateral_asset_id = cs~load_asset_id(); ;;256\n\tint min_collateral_amount = cs~load_amount(); ;;64\n\t;; WARNING\n\t;; It is important that min_collateral_amount ^ is stored as unsigned,\n\t;; so it is always guaranteed to be non-negative (or that the code checks for its non-negativity)\n\t;; Otherwise, it's possible to set min_collateral_amount to negative value\n\t;; and try to do some sketchy stuff like \"reverse-liquidation\":\n\t;; trying to liquidate positive (non-loan) position to increase both \"collateral\" and \"loan\" (which is, once again - non-loan)\n\t;; (and \"collateral\" increases more because of liquidation bonus, so hacker gets net-positive)\n\t;; The problem with this \"hack\" right now though, is that Master will be unable to send negative TONs or Jettons,\n\t;; thus failing compute-phase and as part of it: also failing to send liquidation-subtract/unblock message:\n\t;; in other words, the smart contract will be left forever in liquidation state.\n\t;; So it will be impossible to just withdraw money from it.\n\t;; \"Anti-liquidation\" can remove negative balances and turn them higher than zero,\n\t;; but it's unclear how to hack from there without using Supply/Withdraw, only liquidation (which is allowed to proceed in parallel).\n\t;; Regardless, anti-liquidation can permanently block/freeze any liquidatable User contract\n\t;; and it's best to keep min_collateral_amount non-negative regardless of potential (yet not fully clear) money-stealing hack.\n\tint include_user_code = cs~load_bool_ext(); ;; bool\n\tint liquidate_incoming_amount = cs~load_amount(); ;;64 \n\tcell response_payload_packed = cs~load_ref();\n\tslice response_payload_unpacked = response_payload_packed.begin_parse();\n\tint forward_ton_amount = response_payload_unpacked~load_amount(); ;;64 \n\tcell custom_response_payload = response_payload_unpacked~load_ref();\n\tcell prices_with_signature_packed = cs~load_ref();\n\tcs.end_parse();\n\treturn (\n\t\tborrower_address, liquidator_address,\n\t\tcollateral_asset_id, min_collateral_amount,\n\t\tliquidate_incoming_amount, include_user_code,\n\t\tforward_ton_amount, \n\t\tcustom_response_payload, prices_with_signature_packed\n\t);\n}\n\n;; ---------- op::liquidate_user ----------\n\ncell pack_liquidate_user_message(\n\tint query_id,\n\tcell asset_config_collection, cell asset_dynamics_collection,\n\tint collateral_asset_id, int min_collateral_amount,\n\tslice liquidator_address,\n\tint transferred_asset_id, int transfered_amount,\n\tint forward_ton_amount, cell custom_response_payload,\n\tcell prices_packed\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_user) ;; 32\n\t\t.store_query_id(query_id) ;; 64\n\t\t.store_dict(asset_config_collection) ;; 1 ^1\n\t\t.store_dict(asset_dynamics_collection) ;; 1 ^1\n\t\t.store_ref( ;; ^1\n\t\t\tbegin_cell()\n\t\t\t.store_ref(prices_packed) ;; ^1\n\t\t\t.store_asset_id(collateral_asset_id) ;; 256\n\t\t\t.store_amount(min_collateral_amount) ;; 64\n\t\t\t.store_slice(liquidator_address) ;; 256\n\t\t\t.store_asset_id(transferred_asset_id) ;; 256\n\t\t\t.store_amount(transfered_amount) ;; 64\n\t\t\t.store_amount(forward_ton_amount) ;; 64\n\t\t\t.store_ref(custom_response_payload) ;; ^1\n\t\t\t.end_cell()\n\t\t)\n\t\t.end_cell();\n}\n\n(cell, cell, cell, int, int, slice, int, int, int, cell) parse_liquidate_user_message(slice cs) {\n\tcell asset_config_collection = cs~load_dict();\n\tcell asset_dynamics_collection = cs~load_dict();\n\tcs = cs.preload_ref().begin_parse();\n\tcell prices_packed = cs~load_ref();\n\tint collateral_asset_id = cs~load_asset_id();\n\tint min_collateral_amount = cs~load_amount();\n\t;; cs = cs.preload_ref().begin_parse();\n\tslice liquidator_address = cs~load_msg_addr();\n\tint transferred_asset_id = cs~load_asset_id();\n\tint transfered_amount = cs~load_amount();\n\tint forward_ton_amount = cs~load_amount();\n\tcell custom_response_payload = cs~load_ref();\n\treturn (\n\t\tasset_config_collection, asset_dynamics_collection, prices_packed,\n\t\tcollateral_asset_id, min_collateral_amount,\n\t\tliquidator_address,\n\t\ttransferred_asset_id, transfered_amount,\n\t\tforward_ton_amount, custom_response_payload\n\t);\n}\n\n;; ---------- Liquidate unsatisfied errors ----------\n\nbuilder build_master_liquidating_too_much_error(int max_allowed_liquidation) {\n\treturn begin_cell()\n\t\t.store_op_code(error::master_liquidating_too_much)\n\t\t.store_amount(max_allowed_liquidation);\n}\nbuilder build_user_withdraw_in_progress_error() {\n\treturn begin_cell()\n\t\t.store_op_code(error::user_withdraw_in_progress);\n}\nbuilder build_not_liquidatable_error() {\n\treturn begin_cell()\n\t\t.store_op_code(error::not_liquidatable);\n}\nbuilder build_execution_crashed_error() {\n\treturn begin_cell()\n\t\t.store_op_code(error::liqudation_execution_crashed);\n}\nbuilder build_min_collateral_not_satisfied_error(int collateral_amount) {\n\tif (collateral_amount < 0) {\n\t\tcollateral_amount = 0;\n\t}\n\treturn begin_cell()\n\t\t.store_op_code(error::min_collateral_not_satisfied)\n\t\t.store_amount(collateral_amount);\n}\nbuilder build_user_not_enough_collateral_error(int collateral_present) {\n\treturn begin_cell()\n\t\t.store_op_code(error::user_not_enough_collateral)\n\t\t.store_amount(collateral_present);\n}\nbuilder build_user_liquidating_too_much_error(int max_not_too_much) {\n\treturn begin_cell()\n\t\t.store_op_code(error::user_liquidating_too_much)\n\t\t.store_amount(max_not_too_much);\n}\nbuilder build_master_not_enough_liquidity_error(int available_liquidity) {\n\treturn begin_cell()\n\t\t.store_op_code(error::master_not_enough_liquidity)\n\t\t.store_amount(available_liquidity);\n}\nbuilder build_liquidation_prices_missing() {\n\treturn begin_cell()\n\t\t.store_op_code(error::liquidation_prices_missing);\n}\n\n;; ---------- op::liquidate_unsatisfied ----------\n\ncell pack_liquidate_unsatisfied_message(\n\tint query_id, slice owner_address,\n\tslice liquidator_address,\n\tint transferred_asset_id, int transfered_amount,\n\tint collateral_asset_id, int min_collateral_amount,\n\tint forward_ton_amount, cell custom_response_payload,\n\tbuilder error\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_unsatisfied)\n\t\t.store_query_id(query_id)\n\t\t.store_slice(owner_address)\n\t\t.store_slice(liquidator_address)\n\t\t.store_asset_id(transferred_asset_id)\n\t\t;; Store some part in the reference, it wouldn't fit otherwise. The storage layout is quite arbitrary though\n\t\t.store_ref(\n\t\t\tbegin_cell()\n\t\t\t.store_amount(transfered_amount)\n\t\t\t.store_asset_id(collateral_asset_id)\n\t\t\t.store_amount(min_collateral_amount)\n\t\t\t.store_amount(forward_ton_amount)\n\t\t\t.store_ref(custom_response_payload)\n\t\t\t.store_builder(error)\n\t\t\t.end_cell()\n\t\t)\n\t\t.end_cell();\n}\n\n(slice, slice, int, int, int, int, int, cell, slice) parse_liquidate_unsatisfied_message(slice cs) {\n\tslice owner_address = cs~load_msg_addr();\n\tslice liquidator_address = cs~load_msg_addr();\n\tint transferred_asset_id = cs~load_asset_id();\n\tcs = cs.preload_ref().begin_parse();\n\tint transfered_amount = cs~load_amount();\n\tint collateral_asset_id = cs~load_asset_id();\n\tint min_collateral_amount = cs~load_amount();\n\tint forward_ton_amount = cs~load_amount();\n\tcell custom_response_payload = cs~load_ref();\n\tslice error = cs;\n\treturn (\n\t\towner_address,\n\t\tliquidator_address,\n\t\ttransferred_asset_id, transfered_amount,\n\t\tcollateral_asset_id, min_collateral_amount,\n\t\tforward_ton_amount, custom_response_payload,\n\t\terror\n\t);\n}\n\n;; ---------- op::liquidate_satisfied ----------\n\ncell pack_liquidate_satisfied_message(\n\tint query_id,\n\tslice owner_address, slice liquidator_address,\n\tint transferred_asset_id,\n\tint delta_loan_principal, int liquidatable_amount, int protocol_gift,\n\tint new_user_loan_principal,\n\tint collateral_asset_id,\n\tint delta_collateral_principal, int collateral_reward, int min_collateral_amount,\n\tint new_user_collateral_principal,\n\tint forward_ton_amount, cell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_satisfied)\n\t\t.store_query_id(query_id)\n\t\t.store_slice(owner_address)\n\t\t.store_slice(liquidator_address)\n\t\t.store_asset_id(transferred_asset_id)\n\t\t;; Store some part in the reference, it wouldn't fit otherwise. The storage layout is quite arbitrary though\n\t\t.store_ref(\n\t\t\tbegin_cell()\n\t\t\t.store_principal(delta_loan_principal) ;; 64\n\t\t\t.store_amount(liquidatable_amount) ;; 64\n\t\t\t.store_amount(protocol_gift) ;; 64\n\t\t\t.store_principal(new_user_loan_principal) ;; 64\n\t\t\t.store_asset_id(collateral_asset_id) ;; 256\n\t\t\t.store_principal(delta_collateral_principal) ;; 64\n\t\t\t.store_amount(collateral_reward) ;; 64\n\t\t\t.store_amount(min_collateral_amount) ;; 64\n\t\t\t.store_principal(new_user_collateral_principal) ;; 64\n\t\t\t.store_amount(forward_ton_amount) ;; 64\n\t\t\t.store_ref(custom_response_payload)\n\t\t\t.end_cell()\n\t\t)\n\t\t.end_cell();\n}\n\n(slice, slice, int, int, int, int, int, int, int, int, int, int, int, cell) parse_liquidate_satisfied_message(slice cs) {\n\tslice owner_address = cs~load_msg_addr();\n\tslice liquidator_address = cs~load_msg_addr();\n\tint transferred_asset_id = cs~load_asset_id();\n\tcs = cs.preload_ref().begin_parse();\n\tint delta_loan_principal = cs~load_principal();\n\tint liquidatable_amount = cs~load_amount();\n\tint protocol_gift = cs~load_amount();\n\tint new_user_loan_principal = cs~load_principal();\n\n\tint collateral_asset_id = cs~load_asset_id();\n\tint delta_collateral_principal = cs~load_principal();\n\tint collateral_reward = cs~load_amount();\n\tint min_collateral_amount = cs~load_amount();\n\tint new_user_collateral_principal = cs~load_principal();\n\tint forward_ton_amount = cs~load_amount();\n\tcell custom_response_payload = cs~load_ref();\n\t\n\treturn (\n\t\towner_address, liquidator_address,\n\t\ttransferred_asset_id,\n\t\tdelta_loan_principal, liquidatable_amount, protocol_gift,\n\t\tnew_user_loan_principal, \n\t\tcollateral_asset_id,\n\t\tdelta_collateral_principal, collateral_reward, min_collateral_amount,\n\t\tnew_user_collateral_principal, \n\t\tforward_ton_amount, custom_response_payload\n\t);\n}\n\n;; ---------- op::liquidate_success ----------\n\nbuilder pack_liquidate_success_message(\n\tint query_id,\n\tint transferred_asset_id,\n\tint delta_loan_principal,\n\tint loan_tracking_supply_index, int loan_tracking_borrow_index,\n\tint collateral_asset_id,\n\tint delta_collateral_principal,\n\tint collateral_tracking_supply_index, int collateral_tracking_borrow_index\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_success)\n\t\t.store_query_id(query_id)\n\t\t.store_asset_id(transferred_asset_id)\n\t\t.store_principal(delta_loan_principal)\n\t\t.store_tracking_index(loan_tracking_supply_index)\n\t\t.store_tracking_index(loan_tracking_borrow_index)\n\t\t.store_asset_id(collateral_asset_id)\n\t\t.store_principal(delta_collateral_principal)\n\t\t.store_tracking_index(collateral_tracking_supply_index)\n\t\t.store_tracking_index(collateral_tracking_borrow_index);\n}\n\n(int, int, int, int, int, int, int, int) parse_liquidate_success_message(slice cs) {\n\treturn (\n\t\tcs~load_asset_id(),\n\t\tcs~load_principal(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_asset_id(),\n\t\tcs~load_principal(),\n\t\tcs~load_tracking_index(),\n\t\tcs~load_tracking_index()\n\t);\n}\n\n;; ---------- op::liquidate_fail ----------\n\nbuilder pack_liquidate_fail_message(\n\tint query_id,\n\tint transferred_asset_id,\n\tint delta_loan_principal,\n\tint collateral_asset_id,\n\tint delta_collateral_principal\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_fail)\n\t\t.store_query_id(query_id)\n\t\t.store_asset_id(transferred_asset_id)\n\t\t.store_principal(delta_loan_principal)\n\t\t.store_asset_id(collateral_asset_id)\n\t\t.store_principal(delta_collateral_principal);\n}\n\n(int, int, int, int) parse_liquidate_fail_message(slice cs) {\n\treturn (\n\t\tcs~load_asset_id(),\n\t\tcs~load_principal(),\n\t\tcs~load_asset_id(),\n\t\tcs~load_principal()\n\t);\n}\n\n;; ---------- Liquidate fail report ----------\n\ncell pack_liquidation_fail_report_message(builder error, cell custom_response_payload) {\n\treturn error\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\n;; ---------- Liquidate success report ----------\n\ncell pack_liquidation_success_report_message(\n\tint query_id, \n\tint transferred_asset_id,\n\tint transferred_amount,\n\tint collateral_asset_id,\n\tint collateral_reward, \n\tcell custom_response_payload\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::liquidate_success_report)  ;; 32\n\t\t.store_query_id(query_id) ;; 64\n\t\t.store_asset_id(transferred_asset_id) ;; 256\n\t\t.store_amount(transferred_amount) ;; 64\n\t\t.store_asset_id(collateral_asset_id) ;; 256\n\t\t.store_amount(collateral_reward) ;; 64\n\t\t.store_ref(custom_response_payload)\n\t\t.end_cell();\n}\n\ncell pack_liquidate_excess_message(int op, int query_id) {\n\treturn begin_cell()\n\t\t.store_op_code(0)\n\t\t.store_slice(\"EVAA liquidation.\")\n\t\t.end_cell();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/idle-message.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../external/ton.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../data/basic-types.fc\";\n\n;; --------------- op::idle_master ---------------\n(slice) parse_idle_master_message(slice cs) {\n\tslice target_address = cs~load_msg_addr(); ;; target_address\n\tcs.end_parse();\n\t\n\treturn (\n\t\ttarget_address\n\t);\n}\n\n;; --------------- op::idle_user ---------------\ncell pack_idle_user_message(\n\tcell tokens_keys,\n  int query_id,\n\tslice originator_address\n) {\n\treturn begin_cell()\n\t\t.store_op_code(op::idle_user) ;; 32\n\t\t.store_query_id(query_id)\n    \t.store_dict(tokens_keys)\n\t\t.store_slice(originator_address)\n\t\t.end_cell();\n}\n\n(cell, slice) parse_idle_user_message(slice cs) {\n\treturn (\n\t\tcs~load_dict(),\n    \tcs~load_msg_addr()\n\t);\n}\n\n;; --------------- op::idle_excess ---------------\n;; Idle excess message - refund extra TON attachment back to originator\ncell pack_idle_excess_message(int query_id) {\n\treturn begin_cell()\n\t\t.store_op_code(op::idle_excess)\n\t\t.store_query_id(query_id)\n\t\t.end_cell();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "messages/admin-message.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/basic-types.fc\";\n\n(slice, int, int) parse_claim_asset_reserves_message(slice cs) {\n\tslice target_address = cs~load_msg_addr();\n\tint asset_id = cs~load_asset_id();\n\tint amount_to_claim = cs~load_amount();\n\tcs.end_parse();\n\treturn (\n\t\ttarget_address,\n\t\tasset_id, amount_to_claim\n\t);\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/utils.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/constants.fc\";\n#include \"../data/prices-packed.fc\";\n#include \"../data/asset-config-packer.fc\";\n#include \"../external/openlib.fc\";\n\n(int) present_value_supply_calc (int index, int principal_value) inline {\n  return muldiv(principal_value, index, constants::factor_scale);\n}\n\n(int) present_value_borrow_calc (int index, int principal_value) inline {\n  return muldivc(principal_value, index, constants::factor_scale);\n}\n\n(int) principal_value_supply_calc (int s_rate, int present_value) inline {\n  return s_rate > 0 ? muldiv(present_value, constants::factor_scale, s_rate) : 0;\n}\n\n(int) principal_value_borrow_calc (int b_rate, int present_value) inline {\n  ;; was: (present_value * constants::factor_scale + b_rate - 1) / b_rate\n  ;; adding (b_rate - 1) before dividing by b_rate is equivalent to rounding up (muldivc)\n  return b_rate > 0 ? muldivc(present_value, constants::factor_scale, b_rate) : 0;\n}\n\n(int) present_value(int s_rate, int b_rate, int principal_value) inline {\n  if (principal_value >= 0) {\n    return present_value_supply_calc(s_rate, principal_value);\n  } else {\n    return present_value_borrow_calc(b_rate, principal_value);\n  }\n}\n\n(int) principal_value(int s_rate, int b_rate, int present_value) inline {\n  if (present_value >= 0) {\n    return principal_value_supply_calc(s_rate, present_value);\n  } else {\n    return principal_value_borrow_calc(b_rate, present_value);\n  }\n}\n\n(int, int) around_zero_split(int lower, int upper) {\n  int below = 0;\n  int above = 0;\n  \n  throw_if(error::around_zero_split_messed_up, lower > upper); ;; we need to make sure that lower is always less than upper\n\n  if (lower < 0) {\n    if (upper <= 0) {\n      below = upper - lower;\n    } else {\n      below = - lower;\n      above = upper;\n    }\n  } else {\n    above = upper - lower;\n  }\n  return (below, above);\n}\n\n(int, int) get_collateral_quote (\n  cell asset_config_collection,\n  int borrow_asset_id, int borrow_liquidate_amount,\n  int collateral_asset_id, cell prices_packed\n) {\n  int collateral_price = prices_packed.prices_packed:get?(collateral_asset_id);\n  if (collateral_price == -1) { return (-1, false); }\n  (_, int collateral_decimals, _, _, int liquidation_bonus, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(collateral_asset_id);\n\n  int borrow_price = prices_packed.prices_packed:get?(borrow_asset_id);\n  if (borrow_price == -1) { return (-1, false); }\n  int borrow_decimals = asset_config_collection.asset_config_collection:decimals(borrow_asset_id);\n\n  if (collateral_price == 0) { return (-1, true); }\n\n  return (muldiv(\n    borrow_price * borrow_liquidate_amount * fast_dec_pow(collateral_decimals),\n    liquidation_bonus,\n    constants::asset_coefficient_scale ;; ??? This coefficient\n  ) / collateral_price ;; used to be asset_price_discounted\n    / fast_dec_pow(borrow_decimals), true);\n}\n\n(int) is_valid_address?(slice address) inline {\n  ifnot (ext::addr_std_any_wc?(address)) {\n    return false;\n  }\n  return ext::is_on_same_workchain?(address);\n}\n\n(int) is_valid_custom_response_payload?(cell custom_response_payload) inline {\n  (_, _, _, int f?) = compute_data_size?(custom_response_payload, constants::custom_response_payload_max_cells);\n  return f?;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/user-utils.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../data/prices-packed.fc\";\n#include \"../data/asset-config-packer.fc\";\n#include \"master-utils.fc\";\n#include \"utils.fc\";\n\n;; --------------- principals dictionary functions ---------------\n\nint get_principal(cell principals, int asset_id) {\n  (slice cs, int f) = principals.udict_get?(256, asset_id);\n  if (f) {\n    return cs.preload_principal();\n  } else {\n    return 0;\n    ;; Default to zero,\n    ;; so it doesn't have to store all possible assets from the start\n    ;; and the supported assets can be extended by changing master's config\n  }\n}\n\n(cell, ()) ~set_principal(cell principals, int asset_id, int amount) {\n  return (\n    principals.udict_set_builder(256, asset_id,\n      begin_cell().store_principal(amount)),\n    ()\n  );\n}\n\nint packed_principal:unpack(slice principal_packed) {\n  return principal_packed.preload_principal();\n}\n\n;; asset_id, principal_packed, found?\n(int, slice, int) principals:get_min?(cell principals) {\n  (int asset_id, slice principal_packed, int flag) = principals.udict_get_min?(256);\n  return (asset_id, principal_packed, flag);\n\n  ;; I wanted for enumeration to spit principal value directly (instead of principal_packed)\n  ;; this would require the code below:\n  ;; if (flag) {\n  ;;   return (asset_id, principal_packed.preload_principal(), flag);\n  ;; } else {\n  ;;   return (asset_id, null(), flag);\n  ;; }\n  ;; but each enumeration already contains \"while (flag)\" loop,\n  ;; which checks for \"flag\" after getting a new value/packed_value\n  ;; This means that the code above would perform reductant double checks for \"flag\"\n  ;; (both on the start and on every iteration)\n  ;; That is why I decided to sacrifice readability a little to save some gas and require\n  ;; each enumeration to also use packed_principal:unpack inside the \"while (flag)\" loop\n  ;; The purpose of principals:get_min? and principals:get_next? functions is to:\n  ;; 1) Encapsulate the dictionary specifics part (256-bit key)\n  ;; 2) Make the iteration code more readable\n}\n\n(int, slice, int) principals:get_next?(cell principals, int asset_id) {\n  return principals.udict_get_next?(256, asset_id);\n}\n\n(int, int) get_reward(cell rewards, int asset_id) inline {\n  (slice rewards_packed, int found) = rewards.udict_get?(256, asset_id);\n  int tracking_index = 0;\n  int tracking_accrued = 0;\n  if (found) {\n    tracking_index = rewards_packed~load_tracking_index();\n    tracking_accrued = rewards_packed.preload_tracking_index();\n  }\n  return (tracking_index, tracking_accrued);\n}\n\n(cell, ()) ~set_reward(cell rewards, int asset_id, int tracking_index, int tracking_accrued) inline {\n  return (\n    rewards.udict_set_builder(256, asset_id,\n      begin_cell().store_uint(tracking_index, 64).store_uint(tracking_accrued, 64)),\n    ()\n  );\n}\n\n\n(int, int) account_health_calc (\n  cell asset_config_collection,\n  cell asset_dynamics_collection,\n  cell user_principals,\n  cell prices_packed\n) {\n  int borrow_amount = 0;\n  int borrow_limit = 0;\n\n  (int asset_id, slice asset_value_principal_packed, int flag) = user_principals.principals:get_min?();\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n\n    if (asset_value_principal) { ;; != 0\n\n      int price = prices_packed.prices_packed:get?(asset_id);\n\n      if (price == -1) {\n        return (0, false);\n      }\n\n      var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, token_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n      (int jw_address_hash, int decimals, int collateral_factor, int liquidation_threshold, _, int base_borrow_rate, int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low, int supply_rate_slope_high, int target_utilization, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n      if (asset_value_principal < 0) {\n        borrow_amount += present_value_borrow_calc(asset_b_rate, - asset_value_principal * price / fast_dec_pow(decimals));\n      } else {\n        borrow_limit += present_value_supply_calc(asset_s_rate, asset_value_principal * price * liquidation_threshold / fast_dec_pow(decimals) / constants::asset_coefficient_scale);\n      }\n\n    }\n\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return (constants::factor_scale - (borrow_limit * constants::factor_scale / borrow_amount), true); ;; // it will be account_health (which is 1 - totalBorrowBalance / totalSupplyBalance) times constants::factor_scale\n}\n\n(int) check_not_in_debt_at_all (\n  cell user_principals\n) {\n  ;; this function checks if the user has any debt\n  (int asset_id, slice asset_value_principal_packed, int flag) = user_principals.principals:get_min?();\n\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n    if (asset_value_principal < 0) {\n      return false; ;; user has debt in at least one asset\n    }\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return true;\n}\n\n(int, int, int, int) is_liquidatable (\n  cell asset_config_collection,\n  cell asset_dynamics_collection,\n  cell user_principals,\n  cell prices_packed\n) {\n  int borrow_amount = 0;\n  int borrow_limit = 0;\n  int supply_amount = 0;\n\n  (int asset_id, slice asset_value_principal_packed, int flag) = user_principals.principals:get_min?();\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n\n    if (asset_value_principal) { ;; != 0\n\n      int price = prices_packed.prices_packed:get?(asset_id);\n\n      if (price == -1) {\n        return (false, false, 0, 0);\n      }\n\n      var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, token_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n      (int jw_address_hash, int decimals, int collateral_factor, int liquidation_threshold, _, int base_borrow_rate, int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low, int supply_rate_slope_high, int target_utilization, int origination_fee, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n      if (asset_value_principal < 0) {\n        borrow_amount += present_value_borrow_calc(asset_b_rate, - asset_value_principal * price / fast_dec_pow(decimals));\n      } else {\n        borrow_limit += present_value_supply_calc(asset_s_rate, asset_value_principal * price * liquidation_threshold / fast_dec_pow(decimals) / constants::asset_coefficient_scale);\n        supply_amount += present_value_supply_calc(asset_s_rate, asset_value_principal * price / fast_dec_pow(decimals));\n      }\n\n    }\n\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return (borrow_limit < borrow_amount, true, supply_amount, borrow_amount);\n}\n\n(int, int) get_available_to_borrow(\n  cell asset_config_collection, cell asset_dynamics_collection,\n  cell user_principals, cell prices_packed\n) {\n  int borrow_limit = 0;\n  int borrow_amount = 0;\n\n  (int asset_id, slice asset_value_principal_packed, int flag) =  user_principals.principals:get_min?();\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n\n    if (asset_value_principal) { ;; != 0\n\n      int price = prices_packed.prices_packed:get?(asset_id);\n\n      if (price == -1) {\n        ;; if prices are not ok, result shall be -1, and therefore is_borrow_collateralized will return false\n        return (-1, false);\n      }\n\n      var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, token_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n      (int jw_address_hash, int decimals, int collateral_factor, int liquidation_threshold, _, int base_borrow_rate, int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low, int supply_rate_slope_high, int target_utilization, int origination_fee, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n      if (asset_value_principal < 0) {\n        borrow_amount += muldiv(present_value_borrow_calc(asset_b_rate, - asset_value_principal), price, fast_dec_pow(decimals));\n        ;; todo: !!!!!\n        ;; \"/ binpow(10, decimals)\" MUST go ... it did go, now\n        ;; \"/ fast_dec_pow(decimals)\" MUST go as well\n        ;; Besides unnecessarily spending gas, it also introduces extra computation error:\n        ;; by default positive division rounds to smaller numbers,\n        ;; so both borrow_amount and borrow_limit might be less precise and less than expected\n        ;; With completely \"unscaled\" prices (e.g. USDC=1, TON=2),\n        ;; I found out it would be possible to cheat the protocol for 1 TON at a time\n        ;; (because 0.99 TON / fast_dec_pow(decimals) rounds down to 0 of borrow_amount)\n        ;; Which means, subtracting ~0.14 commision, ~0.85 TON profit for a hacker per transaction\n      } else {\n        ;; borrow_limit += present_value_supply_calc(asset_s_rate, asset_value_principal) * price * collateral_factor / fast_dec_pow(decimals) / constants::asset_coefficient_scale;\n        borrow_limit += muldiv(\n          muldiv(present_value_supply_calc(asset_s_rate, asset_value_principal), price, fast_dec_pow(decimals)),\n          collateral_factor, constants::asset_coefficient_scale\n        );\n      }\n\n    }\n\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return (borrow_limit - borrow_amount, true);\n}\n\n(int, int) is_borrow_collateralized (\n  cell asset_config_collection, cell asset_dynamics_collection,\n  cell user_principals, cell prices_packed\n) {\n  if(check_not_in_debt_at_all(user_principals)){\n    ;; user hasn't borrowed any asset so we can ignore the borrow check\n    return (true, true);\n  }\n\n  (int avail, int enough_price_data) = (get_available_to_borrow(\n      asset_config_collection, asset_dynamics_collection,\n      user_principals, prices_packed\n  ));\n\n  ;; if prices are not ok, avail shall be -1, and therefore this will return false\n  return (avail >= 0, enough_price_data);\n}\n\n(int) get_account_asset_balance (\n  int asset_id,\n  int s_rate, int b_rate,\n  cell user_principals\n) {\n  int asset_value_principal = user_principals.get_principal(asset_id);\n  return present_value(s_rate, b_rate, asset_value_principal);\n}\n\n(int, int, int) get_agregated_balances (\n  cell asset_config_collection,\n  cell asset_dynamics_collection,\n  cell user_principals,\n  cell prices_packed\n) {\n  int user_total_supply = 0;\n  int user_total_borrow = 0;\n\n  (int asset_id, slice asset_value_principal_packed, int flag) =  user_principals.principals:get_min?();\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n\n    if (asset_value_principal) {\n\n      int price = prices_packed.prices_packed:get?(asset_id);\n\n      if (price == -1) {\n        return (0, 0, false);\n      }\n\n      var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, token_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n      (int jw_address_hash, int decimals, int collateral_factor, int liquidation_threshold, _, int base_borrow_rate, int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low, int supply_rate_slope_high, int target_utilization, int origination_fee, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n      if (asset_value_principal < 0) {\n        user_total_borrow += present_value_borrow_calc(asset_b_rate, - asset_value_principal) * price / fast_dec_pow(decimals);\n      } else {\n        user_total_supply += present_value_supply_calc(asset_s_rate, asset_value_principal) * price / fast_dec_pow(decimals);\n      }\n\n    }\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return (user_total_supply, user_total_borrow, true);\n}\n\n(int, int) calculate_maximum_withdraw_amount(\n  cell asset_config_collection, cell asset_dynamics_collection,\n  cell user_principals, cell prices_packed, int asset_id, int old_principal\n) {\n  int withdraw_amount_max = 0;\n  (_, int decimals, int collateral_factor, _, _, _, _, _, _, _, _, _, int dust, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n  \n  if (old_principal > dust) { \n    \n    var (asset_s_rate, asset_b_rate, _, _, _, _, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n    int old_present_value = present_value(asset_s_rate, asset_b_rate, old_principal);\n\n    if(check_not_in_debt_at_all(user_principals)){\n      ;; user hasn't borrowed any asset so we can set withdraw max as balance of asset\n      withdraw_amount_max = old_present_value; ;; withdraw all positive principal without prices if user has no debt\n    } else {\n      int price = prices_packed.prices_packed:get?(asset_id);\n\n      if (price == -1) {\n        return (0, false);\n      }\n\n      int max_amount_to_reclaim = 0;\n      if (collateral_factor == 0) {\n        max_amount_to_reclaim = old_present_value;\n      }\n      ;; if price == 0 then max_amount_to_reclaim = 0, as defined above\n      elseif (price > 0) {\n        (int borrowable, int prices_ok) = get_available_to_borrow(asset_config_collection, asset_dynamics_collection, user_principals, prices_packed);\n        ifnot (prices_ok) {\n          return (0, false);\n        }\n\n        max_amount_to_reclaim =\n          max(0, muldiv(\n            muldiv(borrowable, constants::asset_coefficient_scale, collateral_factor), ;; * asset_parameter_scale / CF_i\n            fast_dec_pow(decimals), price ;; * asset_scale_i / price_i\n          ) - present_value_supply_calc(asset_s_rate, dust) / 2); \n        ;; <likely fixed with muldiv considering the muldivc in the get_available_to_borrow code> \n        ;; consider changing muldiv to smth like (x * y + z - 1) / z in future (?)\n      }\n\n      withdraw_amount_max = min( ;; we want to reclaim as much as possible (cause user have dept), but not more than old_principal\n        max_amount_to_reclaim,\n        old_present_value\n      );\n    }\n  } else {\n    int price = prices_packed.prices_packed:get?(asset_id);\n\n    if (price == -1) {\n      return (0, false);\n    }\n\n    (withdraw_amount_max, int enough_price_data) = get_available_to_borrow(\n      asset_config_collection, asset_dynamics_collection,\n      user_principals, prices_packed);\n\n    ifnot (enough_price_data) {\n      return (0, false);\n    }\n\n    withdraw_amount_max = withdraw_amount_max.muldiv(\n      fast_dec_pow(decimals),\n      price\n    );\n  }\n  return (withdraw_amount_max, true);\n}\n\n(int, int) accrue_user_indexes (int base_tracking_index, int base_tracking_accrued, int tracking_supply_index, int tracking_borrow_index, int old_principal, int new_principal) {\n  if (old_principal >= 0) {\n    int index_delta = tracking_supply_index - base_tracking_index;\n    base_tracking_accrued += muldiv(old_principal, index_delta, constants::tracking_index_scale);\n  } else {\n    int index_delta = tracking_borrow_index - base_tracking_index;\n    base_tracking_accrued += muldiv(- old_principal, index_delta, constants::tracking_index_scale);\n  }\n\n  if (new_principal >= 0) {\n    base_tracking_index = tracking_supply_index;\n  } else {\n    base_tracking_index = tracking_borrow_index;\n  }\n  return (base_tracking_index, base_tracking_accrued);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/user-revert-call.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../logic/tx-utils.fc\";\n\n() revert_call(\n    slice sender_address, slice owner_address,\n    slice in_msg_body\n) impure method_id(0x770) {\n    {-\n    ;; revert_call_process does not make difference about upgrade_exec\n    ;; this code may be useful in future if there actually will be difference\n    if (update_failed) {\n        ;; If update failed, need to change upgrade_exec to false\n        (int expected_code_version, cell upgrade_info_cell, int upgrade_exec) = in_msg_body~user::upgrade::load_header();\n        builder new_msg_body = begin_cell()\n            .user::upgrade::store_header(expected_code_version, upgrade_info_cell, false)\n            .store_slice(in_msg_body);\n        in_msg_body = new_msg_body.end_cell().begin_parse();\n    }\n    -}\n    \n    send_message(\n        sender_address, 0,\n        begin_cell()\n        .store_op_code(op::revert_call) ;; 32\n        .store_query_id(99999999) ;; 64\n        ;; todo: !! ^ Should maybe use original query_id\n        .store_slice(owner_address) ;; 3+8+256\n        ;; Part above is totalling: 32 + 64 + 3+8+256 = 363 bits,\n        ;; which is significant -> Let's keep in_msg_body in a separate cell\n        .store_ref(\n            begin_cell().store_slice(in_msg_body).end_cell()\n        )\n        .end_cell(),\n        sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n    commit(); \n    throw(error::user_code_version_mismatch);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/user-get-methods.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"user-utils.fc\";\n#include \"master-utils.fc\";\n\n(int) getAccountAssetBalance (int asset_id, int s_rate, int b_rate) method_id {\n  cell user_principals = user::storage::load_principals();\n  int res = get_account_asset_balance(asset_id, s_rate, b_rate, user_principals);\n  return res;\n}\n\n(cell) getAccountBalances (cell asset_dynamics_collection) method_id {\n  cell user_principals = user::storage::load_principals();\n  (int asset_id, slice asset_value_principal_packed, int flag) = user_principals.principals:get_min?();\n  cell account_balances = new_dict();\n  while (flag) {\n    int asset_value_principal = asset_value_principal_packed.packed_principal:unpack();\n\n    var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, token_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n    int balance = present_value(asset_s_rate, asset_b_rate, asset_value_principal);\n    ;; int balance = get_account_asset_balance(asset_id, asset_s_rate, asset_b_rate, user_principals);\n    ;; Function get_account_asset_balance first fetches the corresponding principal from the dictionary\n    ;; by asset_id, but it's not necessary because we already have it as part of enumeration\n    account_balances~udict_set(256, asset_id, begin_cell().store_int(balance, 65).end_cell().begin_parse()); ;; nns2009 -> todo@sepezho: !! I did a project-wide search for 65, but I didn't quite understand why this specific number was chosen\n    (asset_id, asset_value_principal_packed, flag) = user_principals.principals:get_next?(asset_id);\n  }\n  return (account_balances);\n}\n\n(int) getAccountHealth (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed) method_id {\n  cell user_principals = user::storage::load_principals();\n  (int result, _) = account_health_calc(asset_config_collection, asset_dynamics_collection, user_principals, prices_packed);\n  return result;\n}\n\n(int) getAvailableToBorrow (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed) method_id {\n  cell user_principals = user::storage::load_principals();\n  (int result, _) = get_available_to_borrow(\n    asset_config_collection, asset_dynamics_collection,\n    user_principals, prices_packed\n  );\n  return result;\n}\n\n;; ??? todo: this method is questionable to have on user, because it takes space on every user-instance\n;; It should probably be moved to the master\n(int) getIsLiquidable (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed) method_id {\n  cell user_principals = user::storage::load_principals();\n  (int result, _, _, _) = is_liquidatable(asset_config_collection, asset_dynamics_collection, user_principals, prices_packed);\n  return result;\n}\n\n(int, int) getAggregatedBalances (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed) method_id {\n  cell user_principals = user::storage::load_principals();\n  (int res1, int res2, _) = get_agregated_balances(asset_config_collection, asset_dynamics_collection, user_principals, prices_packed);\n  return (res1, res2);\n}\n\n(int) codeVersion() method_id {\n  (int code_version, _, _, _, _, _, _, _) = user::storage::load();\n  return code_version;\n}\n\n(int) isUserSc () method_id {\n  return (-1); ;;for liquidation bot\n}\n\n;; nns2009 added for Testing\nint get_asset_principal(int asset_id) method_id {\n  cell user_principals = user::storage::load_principals();\n  return user_principals.get_principal(asset_id);\n}\n\ncell getPrincipals () method_id {\n  cell user_principals = user::storage::load_principals();\n  return user_principals;\n}\n\ncell getRewards () method_id {\n  (_, _, _, _, _, cell user_rewards, _, _) = user::storage::load();\n  return user_rewards;\n}\n\n(int, slice, slice, cell, int, cell, cell, cell) getAllUserScData () method_id {\n  return user::storage::load();\n}\n\n(int) get_maximum_withdraw_amount(int asset_id, cell prices_packed, cell asset_config_collection, cell asset_dynamics_collection) method_id {\n  cell user_principals = user::storage::load_principals();\n  int old_principal = user_principals.get_principal(asset_id);\n  (int result, _) = calculate_maximum_withdraw_amount(\n    asset_config_collection, asset_dynamics_collection,\n    user_principals, prices_packed, asset_id, old_principal\n  );\n  return result;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/tx-utils.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/ton.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../constants/constants.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../messages/upgrade-header.fc\";\n#include \"addr-calc.fc\";\n#include \"../constants/logs.fc\";\n\nconst int jetton_op::transfer = 0x0f8a7ea5;\nconst int jetton_op::transfer_notification = 0x7362d09c;\nconst int jetton_op::excesses = 0xd53276db;\n\n;; https://docs.ton.org/develop/smart-contracts/messages\n() send_message(\n\tslice to_address, int nano_ton_amount,\n\tcell content, int mode\n) impure {\n\tvar msg = begin_cell()\n\t\t.store_uint(0x10, 6) ;; todo: !!!! Any way to reasonably process bounced messages\n\t\t;; ??? Sends non-bounceable. Does it need to be a parameter?\n\t\t.store_slice(to_address)\n\t\t.store_grams(nano_ton_amount)\n\t\t.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)\n\t\t.store_maybe_ref(content); ;; body:(Either X ^X)\n\n\tsend_raw_message(msg.end_cell(), mode);\n}\n\n() send_jetton(\n\tslice my_jetton_wallet_address,\n\tslice to_address,\n\tint query_id, int amount,\n\tint nano_ton_attachment, cell body, int mode\n) impure {\n\tsend_message(\n\t\tmy_jetton_wallet_address,\n\t\t0, ;; because we using mode 128 +raw_reserve everywhere we dont need ton amount here\n\t\tbegin_cell()\n\t\t.store_op_code(jetton_op::transfer)\n\t\t.store_query_id(query_id)\n\t\t.store_grams(amount) ;; jetton amount\n\t\t.store_slice(to_address) ;; new owner\n\t\t.store_slice(to_address) ;; response_destination -> refund excess fees to the owner\n\t\t.store_maybe_ref(body) ;; custom_response_payload\n\t\t.store_grams(nano_ton_attachment) ;; minimum nano-TON amount to send transfer_notification\n\t\t;;.store_bool(false) ;; forward_payload\n\t\t.store_maybe_ref(body) ;; custom_response_payload\n\t\t.end_cell(),\n\t\tmode ;; send mode\n\t);\n}\n\n;; Carries all the remaining TON balance\n() respond_send_jetton(\n\tslice my_jetton_wallet_address,\n\tslice to_address,\n\tint query_id, int amount,\n\tcell body, int forward_ton_amount\n) impure {\n\tsend_jetton(\n\t\tmy_jetton_wallet_address,\n\t\tto_address,\n\t\tquery_id, amount,\n\t\tforward_ton_amount, ;; nanotons\n\t\tbody,\n\t\tsendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE \n\t);\n}\n\n() reserve_and_send_rest(\n\tint nano_ton_amount_to_reserve,\n\tslice to_address, cell content\n) impure {\n\traw_reserve(nano_ton_amount_to_reserve, reserve::REGULAR);\n\tsend_message(to_address, 0, content, sendmode::CARRY_ALL_BALANCE);\n}\n\n() try_reserve_and_send_rest(\n\tint nano_ton_amount_to_reserve,\n\tslice to_address, cell content\n) impure {\n\traw_reserve(nano_ton_amount_to_reserve, reserve::AT_MOST);\n\tsend_message(to_address, 0, content, sendmode::CARRY_ALL_BALANCE + 2);\n}\n\n() send_message_to_lending_wallet_by_address(\n  cell state_init, int ton_amount, int user_version, cell upgrade_info,\n  slice lending_wallet_address, builder content,\n  int message_send_mode\n) impure {\n  builder msg = begin_cell()\n                .store_uint(0x10, 6) ;; Non-bounceable to be able to deploy\n                .store_slice(lending_wallet_address)\n                .store_grams(ton_amount)\n                .store_uint(0, 1 + 4 + 4 + 64 + 32);\n\n  if (state_init.null?()) {\n    msg = msg.store_uint(1, 2); ;; $ 01\n  } else {\n    msg = msg.store_uint(7, 3).store_ref(state_init); ;; $ 111\n  }\n\n  msg = msg.store_ref(\n    begin_cell()\n      .user::upgrade::store_header(user_version, upgrade_info, true)\n      .store_builder(content)\n      ;; ^ NOTE: !!! Consider changing upgrade format so that \"content\" is completely independent from the header. At the moment, upgrade header uses 1 reference out of available 4 to be stored in the cell. So whoever constructs \"content\" needs keep that in mind and use no more than 3 references. In the future, in case upgrade header starts using 2 references, some of the previous code for \"content\" (which thought 3 references are ok) would be broken\n      .end_cell()\n  );\n\n  send_raw_message(msg.end_cell(), message_send_mode);\n}\n\n;; ??? Do we need send-mode as a separate parameter?\n() send_message_to_lending_wallet( ;; note rename landing_wallet to user sc\n  cell blank_code, int user_version, cell user_code,\n  slice owner_address, cell content,\n  int message_send_mode\n) impure {\n  cell state_init = calculate_user_state_init(blank_code, owner_address);\n  slice lending_wallet_address = calculate_address(state_init);\n\n\tcell upgrade_info = null();\n\tifnot (user_code.null?()) {\n\t\t;; NOTE: !! Gas optimization\n\t\t;; Code rearranged to do not call the following line when not needed!\n\t\tcell user_data = calculate_user_init_data(user_version, owner_address);\n\t\tupgrade_info = begin_cell().store_ref(user_code).store_ref(user_data).end_cell();\n\t}\n\n  send_message_to_lending_wallet_by_address(\n    state_init, 0, user_version, upgrade_info,\n    lending_wallet_address, begin_cell().store_slice(content.begin_parse()),\n    message_send_mode\n  );\n}\n\n() send_asset_ext(\n\tslice to_address,\n\tint query_id, int addr_hash, int amount,\n\tint nano_ton_attachment, cell body, int mode\n) impure {\n\t;; todo: !! Consider sending asset with raw_reserve and mode=128\n\t;; such that the exact network fee remainders are refunded\n\t;; In this case also update the tests to require exact equality\n\tif (addr_hash == constants::ton_asset_id) {\n\t\tsend_message(\n\t\t\tto_address, amount + nano_ton_attachment,\n\t\t\tbody,\n\t\t\tmode ;; send mode\n\t\t);\n\t} else {\n\t\tsend_jetton(\n\t\t\tcalc_address_from_hash(addr_hash), \n\t\t\tto_address, ;; new owner, and also:\n\t\t\t;; response_destination -> refund excess fees to the owner\n\t\t\tquery_id, amount, ;; jetton amount\n\t\t\tnano_ton_attachment, \n\t\t\tbody, ;; custom_response_payload\n\t\t\tmode\n\t\t);\n\t}\n}\n\n() send_asset(\n\tslice to_address,\n\tint query_id, int addr_hash, int amount,\n\tint nano_ton_attachment\n) impure {\n\tsend_asset_ext(\n\t\tto_address,\n\t\tquery_id, addr_hash, amount,\n\t\tnano_ton_attachment,\n\t\tbegin_cell().end_cell(), ;; todo: send some proper comment, with query_id?\n\t\tsendmode::REGULAR\n\t);\n}\n\n;; Used to refund asset in THE SAME transaction as it arrived thus being able to use mode=64 and refund exact remains\n() immediate_asset_refund(\n\tslice to_address,\n\tint query_id, int asset_id, int amount,\n\tcell body, int forward_ton_amount\n) impure {\n\tif (asset_id == constants::ton_asset_id) {\n\t\tsend_message(\n\t\t\tto_address, 0,\n\t\t\tbody, \n\t\t\tsendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n\t\t);\n\t} else {\n\t\trespond_send_jetton(\n\t\t\tcalc_address_from_hash(asset_id), \n\t\t\tto_address,\n\t\t\tquery_id, amount, ;; jetton amount\n\t\t\tbody, forward_ton_amount\n\t\t);\n\t}\n}\n\n() emit_log_simple (cell data) impure inline {\n  var msg = begin_cell()\n     .store_uint(12, 4)         ;; ext_out_msg_info$11 src:MsgAddressInt ()\n     .store_uint(1, 2)          ;; addr_extern$01\n     .store_uint(256, 9)        ;; len:(## 9)\n     .store_uint(0, 256)       ;; external_address:(bits len)\n     .store_uint(1, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n     .store_ref(data)\n     .end_cell();\n  send_raw_message(msg, 0);\n}\n\n() emit_log_crash(int error_code, int op, int query_id) {\n  emit_log_simple(\n\t  begin_cell()\n\t  .store_uint(log::execution_crashed, 8)\n\t  .store_uint(error_code, 16)\n\t  .store_op_code(op)\n\t  .store_query_id(query_id)\n\t  .end_cell()\n  );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/master-utils.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/asset-dynamics-packer.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../external/ton.fc\";\n#include \"utils.fc\";\n#include \"../constants/constants.fc\";\n\n(int, int) get_asset_interests (\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int asset_id\n) {\n  var (asset_s_rate, asset_b_rate, total_supply_principal, total_borrow_principal, last_accrual, asset_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  (int jw_address_hash, int decimals, int collateral_factor, int liquidation_threshold, _, int base_borrow_rate, int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low, int supply_rate_slope_high, int target_utilization, int origination_fee, int dust, _, int reserve_factor, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n  int total_supply = present_value_supply_calc(asset_s_rate, total_supply_principal);\n  int total_borrow = present_value_borrow_calc(asset_b_rate, total_borrow_principal);\n  int utilization = 0;\n  int supply_interest = 0;\n  int borrow_interest = 0;\n\n  if (total_supply == 0) {\n    utilization = 0;\n  } else {\n    utilization = total_borrow * constants::factor_scale / total_supply;\n  }\n\n  if (utilization <= target_utilization) {\n    borrow_interest = base_borrow_rate\n      + muldiv(borrow_rate_slope_low, utilization, constants::factor_scale);\n  } else {\n    borrow_interest = base_borrow_rate\n      + muldiv(borrow_rate_slope_low, target_utilization, constants::factor_scale)\n      + muldiv(borrow_rate_slope_high, (utilization - target_utilization), constants::factor_scale);\n  }\n\n  supply_interest =\n    borrow_interest\n    .muldiv(utilization, constants::factor_scale)\n    .muldiv(constants::reserve_scale - reserve_factor, constants::reserve_scale);\n  return (supply_interest, borrow_interest);\n}\n\n(int, int) get_current_rates (\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int asset_id, int time_elapsed\n) {\n  var (s_rate, b_rate, total_supply_principal, total_borrow_principal, last_accrual, asset_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  if (time_elapsed > 0) {\n    (int supply_rate, int borrow_rate) = get_asset_interests(asset_config_collection, asset_dynamics_collection, asset_id);\n    int updated_s_rate = s_rate + muldiv(s_rate, supply_rate * time_elapsed, constants::factor_scale);\n    int updated_b_rate = b_rate + muldiv(b_rate, borrow_rate * time_elapsed, constants::factor_scale);\n\n    return (updated_s_rate, updated_b_rate);\n  }\n  return (s_rate, b_rate);\n}\n\n\n(int, int) accrue_tracking_indexes(int tracking_supply_index, int tracking_borrow_index, int last_accrual, int total_supply, int total_borrow, int decimals, int min_principal_for_rewards, int base_tracking_supply_speed, int base_tracking_borrow_speed) inline {\n    if ((now() - last_accrual > 0) & (min_principal_for_rewards > 0)) {\n        ;; we set min_principal_for_rewards to 0 to disable rewards\n        int timeElapsed = now() - last_accrual;\n        if (total_supply >= min_principal_for_rewards) {\n            tracking_supply_index += muldiv(base_tracking_supply_speed * timeElapsed, fast_dec_pow(decimals), total_supply);\n        }\n        if (total_borrow >= min_principal_for_rewards) {\n            tracking_borrow_index += muldiv(base_tracking_borrow_speed * timeElapsed, fast_dec_pow(decimals), total_borrow);\n        }\n    }\n    return (tracking_supply_index, tracking_borrow_index);\n}\n\n(cell) update_master_lm_indexes(cell assets_config_collection, cell dynamics_collection) {\n    cell new_assets_dynamics_collection = new_dict();\n\n    (int asset_id, slice asset_dynamics, int flag) = dynamics_collection.udict_get_min?(256);\n    while (flag) {\n        (\n            int asset_s_rate, int asset_b_rate,\n            int total_supply_principal, int total_borrow_principal,\n            int last_accrual,\n            int token_balance,\n            int old_tracking_supply_index, int old_tracking_borrow_index,\n            int awaited_supply\n        ) = asset_dynamics.unpack_asset_dynamics();\n\n        ;; should exist, `found` is not necessary\n        (slice asset_slice, _) = assets_config_collection.udict_get?(256, asset_id);\n\n        (_, int decimals, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\n            int min_principal_for_rewards, int base_tracking_supply_speed, int base_tracking_borrow_speed\n        ) = asset_slice.unpack_asset_config();\n\n        ;; Note Replace after upgrade with proper loads!\n        (int tracking_supply_index, int tracking_borrow_index) = accrue_tracking_indexes(\n            old_tracking_supply_index, old_tracking_borrow_index,\n            last_accrual,\n            total_supply_principal, total_borrow_principal,\n            decimals, min_principal_for_rewards,\n            base_tracking_supply_speed, base_tracking_borrow_speed\n        );\n\n        int time_elapsed = now() - last_accrual;\n        (asset_s_rate, asset_b_rate) = get_current_rates(\n            assets_config_collection, dynamics_collection,\n            asset_id, time_elapsed\n        );\n\n        cell asset_dynamics_new = pack_asset_dynamics(\n            asset_s_rate, asset_b_rate,\n            total_supply_principal, total_borrow_principal,\n            now(), token_balance,\n            tracking_supply_index, tracking_borrow_index,\n            awaited_supply\n        );\n\n        new_assets_dynamics_collection~udict_set(256, asset_id, asset_dynamics_new.begin_parse());\n\n        (asset_id, asset_dynamics, flag) = dynamics_collection.udict_get_next?(256, asset_id);\n    }\n    return new_assets_dynamics_collection;\n}\n\n(cell, ()) update_old_rates_and_provided_asset_id (\ncell asset_dynamics_collection, cell asset_config_collection,\n  int required_asset_id1, int required_asset_id2\n) {\n  (int asset_id, slice asset_dynamics, int flag) = asset_dynamics_collection.udict_get_min?(256);\n  while (flag) {\n    (\n      int asset_s_rate, int asset_b_rate,\n      int total_supply_principal, int total_borrow_principal,\n      int last_accrual, int token_balance,\n      int tracking_supply_index, int tracking_borrow_index,\n      int awaited_supply\n    ) = asset_dynamics.unpack_asset_dynamics();\n\n    int is_required_asset? = (asset_id == required_asset_id1) | (asset_id == required_asset_id2);\n    int time_elapsed = now() - last_accrual;\n    if ((time_elapsed > 0) & ((is_required_asset?) | (time_elapsed > constants::consider_rates_old_after))) {\n        (asset_s_rate, asset_b_rate) = get_current_rates(\n            asset_config_collection, asset_dynamics_collection,\n            asset_id,\n            time_elapsed\n        );\n        ;; Update tracking indexes\n        (_, int decimals, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\n            int min_principal_for_rewards, int base_tracking_supply_speed, int base_tracking_borrow_speed\n        ) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n        (tracking_supply_index, tracking_borrow_index) = accrue_tracking_indexes(\n            tracking_supply_index, tracking_borrow_index, last_accrual,\n            total_supply_principal, total_borrow_principal, decimals,\n            min_principal_for_rewards, ;; < note we need to accrue interests on OLD totals.\n            ;; ^ so, total_supply_principal and total_borrow_principal NOT new_total_supply and new_total_borrow.\n            ;; ^ because we need to calculate rewards for the period from last_accrual_timestamp to now\n            base_tracking_supply_speed, base_tracking_borrow_speed\n        );\n        \n        asset_dynamics_collection~asset_dynamics_collection:set_packed(\n            asset_id,\n            asset_s_rate, asset_b_rate, ;; These are NEW (not unpacked) computed values\n            total_supply_principal, total_borrow_principal,\n            now(), ;; last_accrual updated because s_rate and b_rate are new\n            token_balance, ;; this doesn't change, because withdraw is not yet confirmed\n            tracking_supply_index, tracking_borrow_index,\n            awaited_supply\n        );\n    }\n\n    (asset_id, asset_dynamics, flag) = asset_dynamics_collection.udict_get_next?(256, asset_id);\n  }\n\n  return (asset_dynamics_collection, ());\n}\n\n;; DAO's money\nint get_asset_reserves_direct(\n  int asset_balance,\n  int s_rate, int total_supply_principal,\n  int b_rate, int total_borrow_principal\n) {\n  int total_supply = present_value_supply_calc(s_rate, total_supply_principal);\n  int total_borrow = present_value_borrow_calc(b_rate, total_borrow_principal);\n  return (asset_balance - total_supply + total_borrow);\n}\n\n(int) get_asset_reserves (\n  cell asset_config_collection,\n  cell asset_dynamics_collection,\n  int asset_id\n) {\n  var (_, _, total_supply_principal, total_borrow_principal, last_accrual, asset_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  (int s_rate, int b_rate) = get_current_rates(\n    asset_config_collection, asset_dynamics_collection,\n    asset_id, now() - last_accrual\n  );\n  return get_asset_reserves_direct(\n    asset_balance,\n    s_rate, total_supply_principal,\n    b_rate, total_borrow_principal\n  );\n}\n\n;; Function to calculate how much of specific asset\n;; protocol has available for withdrawing or liquidation\n;;NOTE if we want to set liquidity as supply - borrow then use this function everywhere where i leftet NOTEs  \nint get_asset_liquidity(\n  int total_supply_principal,\n  int total_borrow_principal,\n  int s_rate, int b_rate\n) {\n  int total_supply = present_value_supply_calc(s_rate, total_supply_principal);\n  int total_borrow = present_value_borrow_calc(b_rate, total_borrow_principal);\n  return total_supply - total_borrow;\n}\n;; This ^ formula might look strange, but we get it by subtracting:\n;; asset_balance - developers_money\n;; (substituting developers_money)\n;; = asset_balance - (asset_balance - total_supply + total_borrow)\n;; = total_supply - total_borrow\n\nint get_asset_liquidity_minus_reserves(\n  int total_supply_principal,\n  int total_borrow_principal,\n  int s_rate, int b_rate, int token_balance\n) {\n  int total_supply = present_value_supply_calc(s_rate, total_supply_principal);\n  int total_borrow = present_value_borrow_calc(b_rate, total_borrow_principal);\n  return min(total_supply - total_borrow, token_balance);\n}\n\n(int, int) get_asset_totals (\n  cell asset_config_collection,\n  cell asset_dynamics_collection,\n  int asset_id\n) {\n  var (_, _, total_supply_principal, total_borrow_principal, last_accrual, _, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  (int s_rate, int b_rate) = get_current_rates(\n    asset_config_collection, asset_dynamics_collection,\n    asset_id, now() - last_accrual\n  );\n  int total_supply = present_value_supply_calc(s_rate, total_supply_principal);\n  int total_borrow = present_value_borrow_calc(b_rate, total_borrow_principal);\n  return (total_supply, total_borrow);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/master-if-active-check.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../data/prices-packed.fc\";\n#include \"tx-utils.fc\";\n\n(int) if_active_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body,\n  slice sender_address, int addr_hash, int fwd_fee,\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection\n) impure inline {\n  if (~ slice_data_equal?(sender_address, admin)) { ;; if not Admin\n    slice in_msg_body_copy = in_msg_body; \n    int op = in_msg_body_copy~load_op_code();\n    int query_id = in_msg_body_copy~load_query_id();\n\n    if ((op == op::supply_master)\n      | (op == op::withdraw_master)\n      | (op == op::liquidate_master)\n      | (op == op::idle_master))\n      ;; ^ one of the \"front-facing\" op-codes, which initiate new operations\n    {\n      ;; Stop processing and return TONs back to owner\n      throw(error::disabled);\n    } elseif (op == jetton_op::transfer_notification) {\n      ;; If it is jetton supply / jetton liquidate\n      (_, int f) = tokens_keys.udict_get?(256, addr_hash);\n      throw_unless(error::received_unsupported_jetton, f); ;; check jetton is supported\n      ;; NOTE: !! It might be possible to refund unsupported jettons / do we need to refund them?\n\n      int jetton_amount = in_msg_body_copy~load_coins(); \n      slice from_address = in_msg_body_copy~load_msg_addr();\n      if (~ slice_data_equal?(from_address, admin)) { ;; if not Admin\n        ;; return jettons back to Owner\n        ;; NOTE: !!! will be nice to check that sender has enough TON attachment for gas\n        ;; (here and in other such places)\n        respond_send_jetton(\n          sender_address, from_address,\n          query_id, jetton_amount,\n          begin_cell().store_op_code(error::disabled).store_ref(begin_cell().store_slice(in_msg_body).end_cell()).end_cell(), 0 ;; lets send entire body on disabled so third party can process it ;; todo would be nice to have not a 0 here but some amount setted by sender\n          ;; NOTE: !! Do we need to also store some other info?\n        ); \n        return ret::stop_execution;\n      }\n      ;; else: Jetton sender is Admin: allow operation\n      ;; although it's not exactly clear:\n      ;; why would Admin want to Supply/Liquidate something while the Protocol is stopped, but let's keep this option open.\n      ;; Maybe some intricate Liquidate cases might arrise that need this kind of fixing?\n    }\n    ;; else: it is one of the \"internal\" op codes (from User smart contracts to Master)\n    ;; We don't allow owners to initiate new operations,\n    ;; but we allow all ongoing operations to finish processing.\n    ;; The validity of such [internal] requests\n    ;; (that they had been sent by a real User smart contract)\n    ;; is going to be verified as usual in the corresponding op code handlers\n\n    ;; op-code is one of the \"internal\" ones as described ^\n  }\n  return ret::continue_execution;\n  ;; Sender is Admin (either \"directly\" or through Jetton transfer) or ^\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/master-get-methods.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../storage/master-storage.fc\";\n#include \"../storage/master-upgrade.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../external/ton.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../data/asset-dynamics-packer.fc\";\n#include \"../constants/constants.fc\";\n#include \"../constants/fees.fc\";\n#include \"../messages/supply-message.fc\";\n#include \"../messages/withdraw-message.fc\";\n#include \"../messages/liquidate-message.fc\";\n#include \"addr-calc.fc\";\n#include \"utils.fc\";\n#include \"master-utils.fc\";\n\n(int) getCollateralQuote (\n  int borrow_asset_id, int borrow_liquidate_amount,\n  int collateral_asset_id, cell prices_packed\n) method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (int result, _) = get_collateral_quote(asset_config_collection,\n    borrow_asset_id, borrow_liquidate_amount, collateral_asset_id, prices_packed);\n  return result;\n}\n\n(int, int) getUpdatedRates (\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int asset_id, int time_elapsed \n) method_id {\n  return get_current_rates(\n    asset_config_collection, asset_dynamics_collection,\n    asset_id, time_elapsed);\n}\n\n(cell) getUpdatedRatesForAllAssets (int time_elapsed) method_id {\n  (cell meta, cell update_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  (int asset_id, slice asset_dynamics, int flag) = asset_dynamics_collection.udict_get_min?(256);\n  cell rates = new_dict();\n  while (flag) {\n    var (cumulative_supply_rate, cumulative_borrow_rate) = get_current_rates(\n      asset_config_collection, asset_dynamics_collection,\n      asset_id, time_elapsed);\n    slice cumulative_asset_rates = begin_cell()\n      .store_sb_rate(cumulative_supply_rate)\n      .store_sb_rate(cumulative_borrow_rate)\n      .end_cell()\n      .begin_parse();\n    rates~udict_set(256, asset_id, cumulative_asset_rates);\n    (asset_id, asset_dynamics, flag) = asset_dynamics_collection.udict_get_next?(256, asset_id);\n  }\n  return (rates);\n}\n\n(int, int) getAssetRates (int asset_id) method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  var (supply_rate, borrow_rate) = get_asset_interests(asset_config_collection, asset_dynamics_collection, asset_id);\n  return (supply_rate, borrow_rate);\n}\n\n(cell) get_assets_rates () method_id {\n  (cell meta, cell update_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  (int asset_id, slice asset_dynamics, int flag) = asset_dynamics_collection.udict_get_min?(256);\n  cell rates = new_dict();\n  while (flag) {\n    var (supply_rate, borrow_rate) = get_asset_interests(asset_config_collection, asset_dynamics_collection, asset_id);\n    slice asset_rates = begin_cell()\n      .store_sb_rate(supply_rate)\n      .store_sb_rate(borrow_rate)\n      .end_cell()\n      .begin_parse();\n    rates~udict_set(256, asset_id, asset_rates);\n    (asset_id, asset_dynamics, flag) = asset_dynamics_collection.udict_get_next?(256, asset_id);\n  }\n  return (rates);\n}\n\n(int) getAssetReserves (int asset_id) method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  return get_asset_reserves(asset_config_collection, asset_dynamics_collection, asset_id);\n}\n\n(cell) get_assets_reserves () method_id {\n  (cell meta, cell update_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  (int asset_id, slice asset_dynamics, int flag) = asset_dynamics_collection.udict_get_min?(256);\n  cell reserves = new_dict();\n  while (flag) {\n    int reserve = get_asset_reserves(asset_config_collection, asset_dynamics_collection, asset_id);\n    slice asset_reserve = begin_cell().store_int(reserve, 65).end_cell().begin_parse();\n    reserves~udict_set(256, asset_id, asset_reserve);\n    (asset_id,  asset_dynamics, flag) = asset_dynamics_collection.udict_get_next?(256, asset_id);\n  }\n  return (reserves);\n}\n\n(int, int) getAssetTotals (int asset_id) method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  var (total_supply, total_borrow) = get_asset_totals(asset_config_collection, asset_dynamics_collection, asset_id);\n  return (total_supply, total_borrow); \n}\n\n(cell) getAssetsData () method_id {\n  (cell meta, cell update_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  return (asset_dynamics_collection);\n}\n\n(cell) getAssetsConfig () method_id {\n  (cell meta, cell update_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  return (asset_config_collection);\n}\n\n(cell) getConfig () method_id {\n  slice ds = get_data().begin_parse();\n  cell meta = ds~load_ref();\n  cell upgrade_config = ds~load_ref();\n  cell marketConfig = ds~load_ref();\n  return (begin_cell()\n  .store_ref(meta) ;; meta\n  .store_ref(upgrade_config) ;; upgrade_config\n  .store_ref(marketConfig) ;; config\n  .end_cell());\n}\n\n(cell) getStore () method_id {\n  ;; UPD changed to get entire store ; we can parse it offchain\n  ;; its like getConfig but with asset_dinamics\n  return (get_data());\n}\n\n(cell, cell, cell, cell) getUIVariables () method_id {\n  cell config = getConfig();\n  cell asset_dynamics_collection = getAssetsData();\n  cell assets_rates = get_assets_rates();\n  cell assets_reserves = get_assets_reserves();\n  return (asset_dynamics_collection, config, assets_rates, assets_reserves);\n}\n  \nslice get_user_address(slice owner_address) method_id {\n  return calculate_user_address(BLANK_CODE(), owner_address);\n}\n\nint claim_asset_reserves_min_attachment(int fwd_fee) method_id {\n  int fwd_fee_upper_bound = modest_fwd_fee_estimation(fwd_fee);\n  return\n    ;; 1 message: master -> user or jetton-wallet\n    fwd_fee_upper_bound + \n    fee::claim_asset_reserves +\n    constants::jetton_send_ton_attachment;\n    ;; ^ asset to claim might be jetton, or might be TON\n    ;; in case of TON, adding jetton-TON-attachment is actually not necessary,\n    ;; but let's not add extra branches to the code for little benefit\n}\n\ncell dummy_supply_user_message() method_id {\n  ;; Most values don't really matter:\n  ;; they just need to be there to occupy space,\n  ;; so we can use this message to call withdraw_min_attachment\n  ;; and estimate the corresponding TON attachment\n  return pack_supply_user_message(\n    1111, ;; query_id\n    22222, ;; asset_id,\n    333333, ;; amount,\n    4444444, ;; s_rate,\n    55555555, ;; b_rate,\n    666666666, ;;dust\n    7777777777, ;; max_token_amount\n    88888888888, ;; total_supply\n    88888888888, ;; total_borrow\n    999999999999, ;; tracking_supply_index\n    88888888888, ;; tracking_borrow_index\n    0,\n    begin_cell().end_cell()\n  );\n}\n\nint supply_min_attachment(int fwd_fee, cell supply_user_message) method_id {\n  int fwd_fee_upper_bound = modest_fwd_fee_estimation(fwd_fee);\n  return\n    ;; 3 messages: master -> user, user -> master\n    2 * fwd_fee_upper_bound +\n    cell_fwd_fee(\n      get_current_workchain(),\n      supply_user_message\n    ) +\n    ;; potential User upgarde\n    fee::user_upgrade +\n    ;; 2 transactions\n    fee::incoming_asset +\n    fee::supply_user +\n    fee::supply_success +\n    fee::log_tx +\n    ;; storage on user\n    fee::min_tons_for_storage;\n}\n\ncell dummy_withdraw_user_message() method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  ;; Most values don't really matter:\n  ;; they just need to be there to occupy space,\n  ;; so we can use this message to call withdraw_min_attachment\n  ;; and estimate the corresponding TON attachment\n  return pack_withdraw_user_message(\n    1111, ;; query_id\n    22222, ;; asset_id,\n    333333, ;; amount,\n    4444444, ;; s_rate,\n    55555555, ;; b_rate,\n    ;; asset_config_collection, asset_dynamics_collection\n    ;; ^ though need to be legit, because they can greatly vary in size\n    asset_config_collection,\n    asset_dynamics_collection,\n    begin_cell().end_cell(),\n     ;; recipient_address,\n    my_address(),\n    0,\n    begin_cell().end_cell()\n    ;; todo do we need to have actual price dict here?\n    ;;todo if we will need this function, then price dict should be here\n  );\n}\n\nint withdraw_min_attachment(int fwd_fee, cell withdraw_user_message) method_id {\n  int fwd_fee_upper_bound = modest_fwd_fee_estimation(fwd_fee);\n  return\n    ;; 4 messages: master -> user | user -> master | master -> user & master -> jetton-wallet\n    ;; The first one contains significantly more info, because it needs to include s/b-rates and prices for all assets,\n    ;; so I use cell_fwd_fee to calculate the forward fee for its content,\n    ;; but I also account for it in fwd_fee_upper_bound multiplier (4, instead of 3), because it also includes state init\n    4 * fwd_fee_upper_bound +\n    cell_fwd_fee(\n      get_current_workchain(),\n      withdraw_user_message\n    ) +\n    ;; potential User upgarde\n    fee::user_upgrade +\n    ;; 5 transactions in the success case\n    fee::withdraw_master +\n    fee::withdraw_user +\n    fee::withdraw_collateralized +\n    fee::log_tx +\n    fee::withdraw_success +\n    constants::jetton_send_ton_attachment +\n    ;; op::withdraw_fail would have a larger fee,\n    ;; but failing doesn't come with sending jettons.\n    ;; Thus, combined fees in the case of success (fee::withdraw_success + constants::jetton_send_ton_attachment)\n    ;; are larger than \"fee::withdraw_fail\" would have been.\n    ;; Storage on user\n    fee::min_tons_for_storage;\n}\n\ncell dummy_liquidate_user_message() method_id {\n  (_, _, cell asset_config_collection, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  ;; Most values don't really matter:\n  ;; they just need to be there to occupy space,\n  ;; so we can use this message to call withdraw_min_attachment\n  ;; and estimate the corresponding TON attachment\n  return pack_liquidate_user_message(\n    1111, ;; query_id\n    asset_config_collection, asset_dynamics_collection,\n    22222, ;; collateral_asset_id\n    333333, ;; min_collateral_amount\n    my_address(),\n    44444, ;; transferred_asset_id\n    555555, ;; transferred_amount\n    666666, \n    begin_cell().end_cell(),\n    begin_cell().end_cell()\n  );\n}\n\nint liquidate_min_attachment(int fwd_fee, cell liquidate_user_message) method_id {\n  int fwd_fee_upper_bound = modest_fwd_fee_estimation(fwd_fee);\n  return\n    ;; 4 messages: master -> user | user -> master | master -> user & master -> jetton-wallet\n    ;; The first one contains significantly more info, because it needs to include s/b-rates and prices for all assets,\n    ;; so I use cell_fwd_fee to calculate the forward fee for its content,\n    ;; but I also account for it in fwd_fee_upper_bound multiplier (4, instead of 3), because it also includes state init\n    4 * fwd_fee_upper_bound +\n    cell_fwd_fee(\n      get_current_workchain(),\n      liquidate_user_message\n    ) +\n    ;; potential User upgarde\n    fee::user_upgrade +\n    ;; 5 transactions in the liquidate_satisfied case\n    fee::liquidate_master +\n    fee::liquidate_user +\n    fee::liquidate_satisfied +\n    fee::log_tx +\n    fee::liquidate_fail + \n    constants::jetton_send_ton_attachment +\n    ;; With liquidation, in case it fails at the last step\n    ;; (on master, because there is not enough liquidity)\n    ;; User fail also consumes more than success (because it reverts)\n    ;; but (unlike withdraw) Master needs to send assets either way\n    ;; (either refund in case of fail, or reward in case of success)\n    ;; so failed branch would have larger total fee\n    ;; Storage on user\n    fee::min_tons_for_storage;\n}\n\n;; nns2009 added for testing/debugging/analysis\n(int, int) get_asset_total_principals(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (_, _, int total_supply_principal, int total_borrow_principal, _, _, _, _, _)\n    = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  return (total_supply_principal, total_borrow_principal);\n}\n\nint get_asset_balance(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (_, _, _, _, _, int balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  return balance;\n}\n\nint get_asset_liquidity_by_id(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (int s_rate, int b_rate,\n   int total_supply_principal, int total_borrow_principal,\n    _, int asset_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  ;;NOTE if we want to set liquidity as supply - borrow then uncomment here\n  ;;return get_asset_liquidity(total_supply_principal, total_borrow_principal, s_rate, b_rate);\n  return (asset_balance);\n}\n\nint get_asset_liquidity_minus_reserves_by_id(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (int s_rate, int b_rate,\n   int total_supply_principal, int total_borrow_principal,\n    _, int asset_balance, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  ;;NOTE if we want to set liquidity as supply - borrow then uncomment here\n  return get_asset_liquidity_minus_reserves(total_supply_principal, total_borrow_principal, s_rate, b_rate, asset_balance);\n}\n\n(int, int) get_asset_sb_rate(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (int s_rate, int b_rate, _, _, _, _, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  return (s_rate, b_rate);\n}\n\nint get_active() method_id {\n  (_, _, _, int if_active, _, _, _, _) = master::storage::load();\n  return if_active;\n}\n\n(cell) getTokensKeys () method_id {\n  (_, _, _, _, _, _, cell tokens_keys, _) = master::storage::load();\n  return (tokens_keys);\n}\n\n(int) getLastUserScVersion() method_id {\n  (_, cell upgrade_config, _, _, _, _, _, _) = master::storage::load();\n  (\n    int master_version, int user_version,\n    int timeout, int update_time, int freeze_time,\n    cell user_code,\n    cell new_master_code, cell new_user_code\n  ) = unpack_upgrade_config(upgrade_config);\n  return user_version;\n}\n\n(int, int, int, int, int, cell, cell, cell) getUpgradeConfig() method_id {\n  (_, cell upgrade_config, _, _, _, _, _, _) = master::storage::load();\n  return upgrade_config.unpack_upgrade_config();\n}\n\n(int, int, int) get_asset_tracking_info(int asset_id) method_id {\n  (_, _, _, _, _, _, _, cell asset_dynamics_collection) = master::storage::load();\n  (_, _, _, _, int last_accrual, _, int tracking_supply_index, int tracking_borrow_index, _\n  ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n  return (tracking_supply_index, tracking_borrow_index, last_accrual);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-other.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../constants/op-codes.fc\";\n\n() get_store_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    cell ds = get_data();\n    cell in_msg_body_data = in_msg_body~load_ref();\n    in_msg_body.end_parse();\n\n    send_message(\n        sender_address,\n        0,\n        begin_cell()\n            .store_op_code(op::get_store_response)\n            .store_query_id(query_id)\n            .store_ref(in_msg_body_data)\n            .store_ref(ds)\n            .end_cell(),\n        sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n    return ();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/addr-calc.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../external/ton.fc\";\n#include \"../storage/user-storage.fc\";\n\ncell pack_state_init(cell code, cell data) inline {\n\treturn begin_cell()\n\t\t.store_uint(0, 2)\n\t\t.store_dict(code)\n\t\t.store_dict(data)\n\t\t.store_uint(0, 1)\n\t\t.end_cell();\n}\n\n(slice) calculate_address (cell state_init) {\n\tint wc = get_current_workchain();\n\treturn begin_cell()\n\t\t.store_uint(4, 3)\n\t\t.store_int(wc, 8)\n\t\t.store_uint(cell_hash(state_init), 256)\n\t\t.end_cell()\n\t\t.begin_parse();\n}\n\nslice calc_address_from_hash (int addr_hash) inline {\n\tint wc = get_current_workchain();\n\treturn begin_cell().store_uint(4, 3)\n\t.store_int(wc, 8)\n\t.store_uint(addr_hash, 256)\n\t.end_cell()\n\t.begin_parse();\n}\n\nslice calc_master_wallet_address_from_asset_id(int asset_id, cell token_keys) inline {\n\t(int wallet_address_hash, slice data, int flag) = token_keys.udict_get_min?(256);\n\twhile (flag) {\n\t\tint ticker_hash = data~load_uint(256);\n\t\tif (ticker_hash == asset_id) {\n\t\t\treturn calc_address_from_hash(wallet_address_hash);\n\t\t}\n\n\t\t(wallet_address_hash, data, flag) = token_keys.udict_get_next?(256, wallet_address_hash);\n\t}\n\treturn null();\n}\n;; NOTE: !!! Why is it called platform_address instead of master_address?\n\n;; type_id is in case we need other upgradeable group of contracts\n;; (beyond Users)\n;; the Blank functionality is intended to be universal\n;; it should be possible to reuse it later for whatever comes up\n;; But different groups of contracts should have their own \"address space\",\n;; that is why we need something in the state_init, which discriminates addresses\n;; in some sense type_id here is somewhat similar to subwallet_id in the standard wallet v3R2,\n;; but also different, because these (Blank) contracts are only intended to share the same upgrade functionality/exterior, but diverge with their \"type\"/underlying-functionality\n\n;; params - whatever other params other (future) contracts might need\n;; I (nns2009) think it is not necessary to add them here,\n;; because we can always make a new function for a new group of contracts when we need it, but others wanted it to stay\ncell platform::calculate_blank_state_init(\n    cell blank_code,\n    slice platform_address, slice owner_address,\n    int type_id, cell params\n) inline {\n    return pack_state_init(\n        blank_code,\n        begin_cell()\n            .store_slice(platform_address)\n            .store_slice(owner_address)\n            .store_uint(type_id, 8)\n            .store_maybe_ref(params)\n            .end_cell()\n    );\n}\n\n;; Functions to calculate lending-user Smart Contract's state_init\n;; and, correspondingly, lending-user's address\n\ncell calculate_user_init_data(int code_version, slice owner_address) {\n  return user::storage::pack_init(\n    code_version,\n    my_address(),\n    owner_address,\n    new_dict(),\n    user_state::free\n  );\n}\n\ncell calculate_user_state_init(cell blank_code, slice owner_address) {\n  return platform::calculate_blank_state_init(\n    blank_code,\n    my_address(), owner_address,\n    0, null()\n  );\n}\n\nslice calculate_user_address(cell blank_code, slice owner_address) {\n  return calculate_address(calculate_user_state_init(blank_code, owner_address));\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "external/ton.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"stdlib.fc\";\n;; Functions, which are common for TON in general\n\nforall X -> int cast_to_int(X x) asm \"NOP\";\n\n(int) get_current_workchain () {\n\tvar (wc, _) = parse_std_addr(my_address());\n\treturn (wc);\n}\n\n;; Based on:\n;; https://github.com/ton-blockchain/token-contract/blob/main/misc/forward-fee-calc.fc#L6\nconst int cant_have_this_many_cells = 1 << 64;\nint cell_fwd_fee(int wc, cell content) impure inline {\n\tthrow_unless(107, (wc == -1) | (wc == 0) );\n\tint config_index = 25 + wc;\n\tslice cfg = config_param(config_index).begin_parse().skip_bits(8);\n\tint lump_price = cfg~load_uint(64);\n\tint bit_price = cfg~load_uint(64);\n\tint cell_price = cfg~load_uint(64);\n\n\t(int cells, int bits, _) = compute_data_size(content, cant_have_this_many_cells);\n\tcells -= 1;\n\tbits -= content.begin_parse().slice_bits();\n\n\treturn lump_price + ((bits * bit_price + cells * cell_price + 65535) >> 16 );\n}\n\nint modest_fwd_fee_estimation(int fwd_fee) {\n\treturn muldiv(fwd_fee, 3, 2);\n\t;; we use message fwd_fee for estimation of other similar-sized messages' costs\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "external/stdlib.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n;; Standard library for funC\n;;\n\n{-\n    This file is part of TON FunC Standard Library.\n\n    FunC Standard Library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    FunC Standard Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n-}\n\n{-\n  # Tuple manipulation primitives\n  The names and the types are mostly self-explaining.\n  See [polymorhism with forall](https://ton.org/docs/#/func/functions?id=polymorphism-with-forall)\n  for more info on the polymorphic functions.\n\n  Note that currently values of atomic type `tuple` can't be cast to composite tuple type (e.g. `[int, cell]`)\n  and vise versa.\n-}\n\n{-\n  # Lisp-style lists\n\n  Lists can be represented as nested 2-elements tuples.\n  Empty list is conventionally represented as TVM `null` value (it can be obtained by calling [null()]).\n  For example, tuple `(1, (2, (3, null)))` represents list `[1, 2, 3]`. Elements of a list can be of different types.\n-}\n\n;;; Adds an element to the beginning of lisp-style list.\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\n\n;;; Extracts the head and the tail of lisp-style list.\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\n\n;;; Extracts the tail and the head of lisp-style list.\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\n\n;;; Returns the head of lisp-style list.\nforall X -> X car(tuple list) asm \"CAR\";\n\n;;; Returns the tail of lisp-style list.\ntuple cdr(tuple list) asm \"CDR\";\n\n;;; Creates tuple with zero elements.\ntuple empty_tuple() asm \"NIL\";\n\n;;; Appends a value `x` to a `Tuple t = (x1, ..., xn)`, but only if the resulting `Tuple t' = (x1, ..., xn, x)`\n;;; is of length at most 255. Otherwise throws a type check exception.\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\n\n;;; Creates a tuple of length one with given argument as element.\nforall X -> [X] single(X x) asm \"SINGLE\";\n\n;;; Unpacks a tuple of length one\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\n\n;;; Creates a tuple of length two with given arguments as elements.\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\n\n;;; Unpacks a tuple of length two\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\n\n;;; Creates a tuple of length three with given arguments as elements.\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\n\n;;; Unpacks a tuple of length three\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\n\n;;; Creates a tuple of length four with given arguments as elements.\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\n\n;;; Unpacks a tuple of length four\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\n\n;;; Returns the first element of a tuple (with unknown element types).\nforall X -> X first(tuple t) asm \"FIRST\";\n\n;;; Returns the second element of a tuple (with unknown element types).\nforall X -> X second(tuple t) asm \"SECOND\";\n\n;;; Returns the third element of a tuple (with unknown element types).\nforall X -> X third(tuple t) asm \"THIRD\";\n\n;;; Returns the fourth element of a tuple (with unknown element types).\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\n\n;;; Returns the first element of a pair tuple.\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\n\n;;; Returns the second element of a pair tuple.\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\n\n;;; Returns the first element of a triple tuple.\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\n\n;;; Returns the second element of a triple tuple.\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\n\n;;; Returns the third element of a triple tuple.\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\n\n\n;;; Push null element (casted to given type)\n;;; By the TVM type `Null` FunC represents absence of a value of some atomic type.\n;;; So `null` can actually have any atomic type.\nforall X -> X null() asm \"PUSHNULL\";\n\n;;; Moves a variable [x] to the top of the stack\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\n\n\n;;; Returns the current Unix time as an Integer\nint now() asm \"NOW\";\n\n;;; Returns the internal address of the current smart contract as a Slice with a `MsgAddressInt`.\n;;; If necessary, it can be parsed further using primitives such as [parse_std_addr].\nslice my_address() asm \"MYADDR\";\n\n;;; Returns the balance of the smart contract as a tuple consisting of an int\n;;; (balance in nanotoncoins) and a `cell`\n;;; (a dictionary with 32-bit keys representing the balance of \"extra currencies\")\n;;; at the start of Computation Phase.\n;;; Note that RAW primitives such as [send_raw_message] do not update this field.\n[int, cell] get_balance() asm \"BALANCE\";\n\n;;; Returns the logical time of the current transaction.\nint cur_lt() asm \"LTIME\";\n\n;;; Returns the starting logical time of the current block.\nint block_lt() asm \"BLOCKLT\";\n\n;;; Computes the representation hash of a `cell` [c] and returns it as a 256-bit unsigned integer `x`.\n;;; Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.\nint cell_hash(cell c) asm \"HASHCU\";\n\n;;; Computes the hash of a `slice s` and returns it as a 256-bit unsigned integer `x`.\n;;; The result is the same as if an ordinary cell containing only data and references from `s` had been created\n;;; and its hash computed by [cell_hash].\nint slice_hash(slice s) asm \"HASHSU\";\n\n;;; Computes sha256 of the data bits of `slice` [s]. If the bit length of `s` is not divisible by eight,\n;;; throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer `x`.\nint string_hash(slice s) asm \"SHA256U\";\n\n{-\n  # Signature checks\n-}\n\n;;; Checks the Ed25519-`signature` of a `hash` (a 256-bit unsigned integer, usually computed as the hash of some data)\n;;; using [public_key] (also represented by a 256-bit unsigned integer).\n;;; The signature must contain at least 512 data bits; only the first 512 bits are used.\n;;; The result is `−1` if the signature is valid, `0` otherwise.\n;;; Note that `CHKSIGNU` creates a 256-bit slice with the hash and calls `CHKSIGNS`.\n;;; That is, if [hash] is computed as the hash of some data, these data are hashed twice,\n;;; the second hashing occurring inside `CHKSIGNS`.\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\n\n;;; Checks whether [signature] is a valid Ed25519-signature of the data portion of `slice data` using `public_key`,\n;;; similarly to [check_signature].\n;;; If the bit length of [data] is not divisible by eight, throws a cell underflow exception.\n;;; The verification of Ed25519 signatures is the standard one,\n;;; with sha256 used to reduce [data] to the 256-bit number that is actually signed.\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n{---\n  # Computation of boc size\n  The primitives below may be useful for computing storage fees of user-provided data.\n-}\n\n;;; Returns `(x, y, z, -1)` or `(null, null, null, 0)`.\n;;; Recursively computes the count of distinct cells `x`, data bits `y`, and cell references `z`\n;;; in the DAG rooted at `cell` [c], effectively returning the total storage used by this DAG taking into account\n;;; the identification of equal cells.\n;;; The values of `x`, `y`, and `z` are computed by a depth-first traversal of this DAG,\n;;; with a hash table of visited cell hashes used to prevent visits of already-visited cells.\n;;; The total count of visited cells `x` cannot exceed non-negative [max_cells];\n;;; otherwise the computation is aborted before visiting the `(max_cells + 1)`-st cell and\n;;; a zero flag is returned to indicate failure. If [c] is `null`, returns `x = y = z = 0`.\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; Similar to [compute_data_size?], but accepting a `slice` [s] instead of a `cell`.\n;;; The returned value of `x` does not take into account the cell that contains the `slice` [s] itself;\n;;; however, the data bits and the cell references of [s] are accounted for in `y` and `z`.\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; A non-quiet version of [compute_data_size?] that throws a cell overflow exception (`8`) on failure.\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n\n;;; A non-quiet version of [slice_compute_data_size?] that throws a cell overflow exception (8) on failure.\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n\n;;; Throws an exception with exit_code excno if cond is not 0 (commented since implemented in compilator)\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n{--\n  # Debug primitives\n  Only works for local TVM execution with debug level verbosity\n-}\n;;; Dumps the stack (at most the top 255 values) and shows the total stack depth.\n() dump_stack() impure asm \"DUMPSTK\";\n\n{-\n  # Persistent storage save and load\n-}\n\n;;; Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.\ncell get_data() asm \"c4 PUSH\";\n\n;;; Sets `cell` [c] as persistent contract data. You can update persistent contract storage with this primitive.\n() set_data(cell c) impure asm \"c4 POP\";\n\n{-\n  # Continuation primitives\n-}\n;;; Usually `c3` has a continuation initialized by the whole code of the contract. It is used for function calls.\n;;; The primitive returns the current value of `c3`.\ncont get_c3() impure asm \"c3 PUSH\";\n\n;;; Updates the current value of `c3`. Usually, it is used for updating smart contract code in run-time.\n;;; Note that after execution of this primitive the current code\n;;; (and the stack of recursive function calls) won't change,\n;;; but any other function call will use a function from the new code.\n() set_c3(cont c) impure asm \"c3 POP\";\n\n;;; Transforms a `slice` [s] into a simple ordinary continuation `c`, with `c.code = s` and an empty stack and savelist.\ncont bless(slice s) impure asm \"BLESS\";\n\n{---\n  # Gas related primitives\n-}\n\n;;; Sets current gas limit `gl` to its maximal allowed value `gm`, and resets the gas credit `gc` to zero,\n;;; decreasing the value of `gr` by `gc` in the process.\n;;; In other words, the current smart contract agrees to buy some gas to finish the current transaction.\n;;; This action is required to process external messages, which bring no value (hence no gas) with themselves.\n;;;\n;;; For more details check [accept_message effects](https://ton.org/docs/#/smart-contracts/accept).\n() accept_message() impure asm \"ACCEPT\";\n\n;;; Sets current gas limit `gl` to the minimum of limit and `gm`, and resets the gas credit `gc` to zero.\n;;; If the gas consumed so far (including the present instruction) exceeds the resulting value of `gl`,\n;;; an (unhandled) out of gas exception is thrown before setting new gas limits.\n;;; Notice that [set_gas_limit] with an argument `limit ≥ 2^63 − 1` is equivalent to [accept_message].\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n\n;;; Commits the current state of registers `c4` (“persistent data”) and `c5` (“actions”)\n;;; so that the current execution is considered “successful” with the saved values even if an exception\n;;; in Computation Phase is thrown later.\n() commit() impure asm \"COMMIT\";\n\n;;; Not implemented\n;;() buy_gas(int gram) impure asm \"BUYGAS\";\n\n;;; Computes the amount of gas that can be bought for `amount` nanoTONs,\n;;; and sets `gl` accordingly in the same way as [set_gas_limit].\n() buy_gas(int amount) impure asm \"BUYGAS\";\n\n;;; Computes the minimum of two integers [x] and [y].\nint min(int x, int y) asm \"MIN\";\n\n;;; Computes the maximum of two integers [x] and [y].\nint max(int x, int y) asm \"MAX\";\n\n;;; Sorts two integers.\n(int, int) minmax(int x, int y) asm \"MINMAX\";\n\n;;; Computes the absolute value of an integer [x].\nint abs(int x) asm \"ABS\";\n\n{-\n  # Slice primitives\n\n  It is said that a primitive _loads_ some data,\n  if it returns the data and the remainder of the slice\n  (so it can also be used as [modifying method](https://ton.org/docs/#/func/statements?id=modifying-methods)).\n\n  It is said that a primitive _preloads_ some data, if it returns only the data\n  (it can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods)).\n\n  Unless otherwise stated, loading and preloading primitives read the data from a prefix of the slice.\n-}\n\n\n;;; Converts a `cell` [c] into a `slice`. Notice that [c] must be either an ordinary cell,\n;;; or an exotic cell (see [TVM.pdf](https://ton-blockchain.github.io/docs/tvm.pdf), 3.1.2)\n;;; which is automatically loaded to yield an ordinary cell `c'`, converted into a `slice` afterwards.\nslice begin_parse(cell c) asm \"CTOS\";\n\n;;; Checks if [s] is empty. If not, throws an exception.\n() end_parse(slice s) impure asm \"ENDS\";\n\n;;; Loads the first reference from the slice.\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\n\n;;; Preloads the first reference from the slice.\ncell preload_ref(slice s) asm \"PLDREF\";\n\n  {- Functions below are commented because are implemented on compilator level for optimisation -}\n\n;;; Loads a signed [len]-bit integer from a slice [s].\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n\n;;; Loads an unsigned [len]-bit integer from a slice [s].\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n\n;;; Preloads a signed [len]-bit integer from a slice [s].\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n\n;;; Preloads an unsigned [len]-bit integer from a slice [s].\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n\n;;; Loads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n\n;;; Preloads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n\n;;; Loads serialized amount of TonCoins (any unsigned integer up to `2^120 - 1`).\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDGRAMS\";\n\n;;; Returns all but the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n\n;;; Returns the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\n\n;;; Returns all but the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n\n;;; Returns the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n\n;;; Loads a dictionary `D` (HashMapE) from `slice` [s].\n;;; (returns `null` if `nothing` constructor is used).\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\n\n;;; Preloads a dictionary `D` from `slice` [s].\ncell preload_dict(slice s) asm \"PLDDICT\";\n\n;;; Loads a dictionary as [load_dict], but returns only the remainder of the slice.\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n;;; Loads (Maybe ^Cell) from `slice` [s].\n;;; In other words loads 1 bit and if it is true\n;;; loads first ref and return it with slice remainder\n;;; otherwise returns `null` and slice remainder\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\n\n;;; Preloads (Maybe ^Cell) from `slice` [s].\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\n\n\n;;; Returns the depth of `cell` [c].\n;;; If [c] has no references, then return `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [c].\n;;; If [c] is a `null` instead of a cell, returns zero.\nint cell_depth(cell c) asm \"CDEPTH\";\n\n\n{-\n  # Slice size primitives\n-}\n\n;;; Returns the number of references in `slice` [s].\nint slice_refs(slice s) asm \"SREFS\";\n\n;;; Returns the number of data bits in `slice` [s].\nint slice_bits(slice s) asm \"SBITS\";\n\n;;; Returns both the number of data bits and the number of references in `slice` [s].\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\n\n;;; Checks whether a `slice` [s] is empty (i.e., contains no bits of data and no cell references).\nint slice_empty?(slice s) asm \"SEMPTY\";\n\n;;; Checks whether `slice` [s] has no bits of data.\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\n\n;;; Checks whether `slice` [s] has no references.\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\n\n;;; Returns the depth of `slice` [s].\n;;; If [s] has no references, then returns `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [s].\nint slice_depth(slice s) asm \"SDEPTH\";\n\n{-\n  # Builder size primitives\n-}\n\n;;; Returns the number of cell references already stored in `builder` [b]\nint builder_refs(builder b) asm \"BREFS\";\n\n;;; Returns the number of data bits already stored in `builder` [b].\nint builder_bits(builder b) asm \"BBITS\";\n\n;;; Returns the depth of `builder` [b].\n;;; If no cell references are stored in [b], then returns 0;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [b].\nint builder_depth(builder b) asm \"BDEPTH\";\n\n{-\n  # Builder primitives\n  It is said that a primitive _stores_ a value `x` into a builder `b`\n  if it returns a modified version of the builder `b'` with the value `x` stored at the end of it.\n  It can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods).\n\n  All the primitives below first check whether there is enough space in the `builder`,\n  and only then check the range of the value being serialized.\n-}\n\n;;; Creates a new empty `builder`.\nbuilder begin_cell() asm \"NEWC\";\n\n;;; Converts a `builder` into an ordinary `cell`.\ncell end_cell(builder b) asm \"ENDC\";\n\n;;; Stores a reference to `cell` [c] into `builder` [b].\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n\n;;; Stores an unsigned [len]-bit integer `x` into `b` for `0 ≤ len ≤ 256`.\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n\n;;; Stores a signed [len]-bit integer `x` into `b` for` 0 ≤ len ≤ 257`.\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\n\n\n;;; Stores `slice` [s] into `builder` [b]\n builder store_slice(builder b, slice s) asm \"STSLICER\";\n\n;;; Stores (serializes) an integer [x] in the range `0..2^120 − 1` into `builder` [b].\n;;; The serialization of [x] consists of a 4-bit unsigned big-endian integer `l`,\n;;; which is the smallest integer `l ≥ 0`, such that `x < 2^8l`,\n;;; followed by an `8l`-bit unsigned big-endian representation of [x].\n;;; If [x] does not belong to the supported range, a range check exception is thrown.\n;;;\n;;; Store amounts of TonCoins to the builder as VarUInteger 16\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_coins(builder b, int x) asm \"STGRAMS\";\n\n;;; Stores dictionary `D` represented by `cell` [c] or `null` into `builder` [b].\n;;; In other words, stores a `1`-bit and a reference to [c] if [c] is not `null` and `0`-bit otherwise.\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n;;; Stores (Maybe ^Cell) to builder:\n;;; if cell is null store 1 zero bit\n;;; otherwise store 1 true bit and ref to cell\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\n\n{-\n  # Address manipulation primitives\n  The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme:\n  ```TL-B\n  addr_none$00 = MsgAddressExt;\n  addr_extern$01 len:(## 8) external_address:(bits len)\n               = MsgAddressExt;\n  anycast_info$_ depth:(#<= 30) { depth >= 1 }\n    rewrite_pfx:(bits depth) = Anycast;\n  addr_std$10 anycast:(Maybe Anycast)\n    workchain_id:int8 address:bits256 = MsgAddressInt;\n  addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)\n    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;\n  _ _:MsgAddressInt = MsgAddress;\n  _ _:MsgAddressExt = MsgAddress;\n\n  int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n    src:MsgAddress dest:MsgAddressInt\n    value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ```\n  A deserialized `MsgAddress` is represented by a tuple `t` as follows:\n\n  - `addr_none` is represented by `t = (0)`,\n    i.e., a tuple containing exactly one integer equal to zero.\n  - `addr_extern` is represented by `t = (1, s)`,\n    where slice `s` contains the field `external_address`. In other words, `\n    t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`.\n  - `addr_std` is represented by `t = (2, u, x, s)`,\n    where `u` is either a `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if anycast is present).\n    Next, integer `x` is the `workchain_id`, and slice `s` contains the address.\n  - `addr_var` is represented by `t = (3, u, x, s)`,\n    where `u`, `x`, and `s` have the same meaning as for `addr_std`.\n-}\n\n;;; Loads from slice [s] the only prefix that is a valid `MsgAddress`,\n;;; and returns both this prefix `s'` and the remainder `s''` of [s] as slices.\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\n\n;;; Decomposes slice [s] containing a valid `MsgAddress` into a `tuple t` with separate fields of this `MsgAddress`.\n;;; If [s] is not a valid `MsgAddress`, a cell deserialization exception is thrown.\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n\n;;; Parses slice [s] containing a valid `MsgAddressInt` (usually a `msg_addr_std`),\n;;; applies rewriting from the anycast (if present) to the same-length prefix of the address,\n;;; and returns both the workchain and the 256-bit address as integers.\n;;; If the address is not 256-bit, or if [s] is not a valid serialization of `MsgAddressInt`,\n;;; throws a cell deserialization exception.\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n\n;;; A variant of [parse_std_addr] that returns the (rewritten) address as a slice [s],\n;;; even if it is not exactly 256 bit long (represented by a `msg_addr_var`).\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\n{-\n  # Dictionary primitives\n-}\n\n\n;;; Sets the value associated with [key_len]-bit key signed index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n\n;;; Sets the value associated with [key_len]-bit key unsigned index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\n\n;;; Creates an empty dictionary, which is actually a null value. Equivalent to PUSHNULL\ncell new_dict() asm \"NEWDICT\";\n;;; Checks whether a dictionary is empty. Equivalent to cell_null?.\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n\n{- Prefix dictionary primitives -}\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\n;;; Returns the value of the global configuration parameter with integer index `i` as a `cell` or `null` value.\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\n;;; Checks whether c is a null. Note, that FunC also has polymorphic null? built-in.\nint cell_null?(cell c) asm \"ISNULL\";\n\n;;; Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if mode = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b − amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means `amount <- -amount` before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently, amount must be a non-negative integer, and mode must be in the range 0..15.\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n;;; Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n;;; Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smart contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n;;; Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract\n() set_code(cell new_code) impure asm \"SETCODE\";\n\n;;; Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.\nint random() impure asm \"RANDU256\";\n;;; Generates a new pseudo-random integer z in the range 0..range−1 (or range..−1, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.\nint rand(int range) impure asm \"RAND\";\n;;; Returns the current random seed as an unsigned 256-bit Integer.\nint get_seed() impure asm \"RANDSEED\";\n;;; Sets the random seed to unsigned 256-bit seed.\n() set_seed(int) impure asm \"SETRAND\";\n;;; Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.\n() randomize(int x) impure asm \"ADDRAND\";\n;;; Equivalent to randomize(cur_lt());.\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n;;; Checks whether the data parts of two slices coinside\nint equal_slice_bits (slice a, slice b) asm \"SDEQ\";\n\n;;; Concatenates two builders\nbuilder store_builder(builder to, builder from) asm(from to) \"STB\";\n\n;; NEW FUNCS\n\n;; ===== TVM UPGRADE =====\n\n;;; Retrieves code of smart-contract from c7\ncell my_code() asm \"MYCODE\";\n\n;;; Creates an output action and returns a fee for creating a message. Mode has the same effect as in the case of SENDRAWMSG\n;;int send_message(cell msg, int mode) impure asm \"SENDMSG\";\n\n;;; Retrieves value of storage phase fees from c7\nint storage_fees() asm \"STORAGEFEES\";\n\n;;; Retrieves global_id from 19 network config\nint global_id() asm \"GLOBALID\";\n\n;;; Returns gas consumed by VM so far (including this instruction).\nint gas_consumed() asm \"GASCONSUMED\";\n\nint cell_level(cell c) asm \"CLEVEL\";\nint cell_level_mask(cell c) asm \"CLEVELMASK\";\n\n;; TVM V6 https://github.com/ton-blockchain/ton/blob/testnet/doc/GlobalVersions.md#version-6\n\nint get_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEE\";\nint get_storage_fee(int workchain, int seconds, int bits, int cells) asm(cells bits seconds workchain) \"GETSTORAGEFEE\";\nint get_forward_fee(int workchain, int bits, int cells) asm(cells bits workchain) \"GETFORWARDFEE\";\nint get_precompiled_gas_consumption() asm \"GETPRECOMPILEDGAS\";\n\nint get_simple_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEESIMPLE\";\nint get_simple_forward_fee(int workchain, int bits, int cells) asm(cells bits workchain) \"GETFORWARDFEESIMPLE\";\nint get_original_fwd_fee(int workchain, int fwd_fee) asm(fwd_fee workchain) \"GETORIGINALFWDFEE\";\nint my_storage_due() asm \"DUEPAYMENT\";\n\ntuple get_fee_cofigs() asm \"UNPACKEDCONFIGTUPLE\";\n\n;; ===== ADDRESS =====\n\nconst int BASECHAIN = 0;\nconst int MASTERCHAIN = -1;\n\nconst slice addr_none = \"2_\"s; ;; addr_none$00 = MsgAddressExt;\n\n;;; Store addr_none constuction (b{00}) to `builder` [b]\nbuilder store_addr_none(builder b) asm \"b{00} STSLICECONST\";\n\n;;; Checking that `slice` [s] is a addr_none constuction;\nint addr_none?(slice s) asm \"b{00} PUSHSLICE SDEQ\";\n\n;;; Checking that the address is a standard basechain address and does not have anycast (should be used after load_msg_addr)\nint validate_addr_bc(slice addr) asm \"b{10000000000} PUSHSLICE SDPPFXREV\";\n;;; Checking that the address is a standard masterchain address and does not have anycast (should be used after load_msg_addr)\nint validate_addr_mc(slice addr) asm \"b{10011111111} PUSHSLICE SDPPFXREV\";\n\nbuilder store_bc_address(builder b, cell state_init) asm \"HASHCU SWAP b{10000000000} STSLICECONST 256 STU\";\nbuilder store_mc_address(builder b, cell state_init) asm \"HASHCU SWAP b{10011111111} STSLICECONST 256 STU\";\n\n;;; Checking that the `slice` [addr] is a standard basechain address and does not have anycast (can be used with any `slice`)\nint ext_validate_addr_bc(slice addr) asm \"\"\"\n  DUP\n  b{10000000000} PUSHSLICE SDPPFXREV SWAP\n  267 INT 0 INT SCHKBITREFSQ\n  AND\n\"\"\";\n;;; Checking that the `slice` [addr] is a standard masterchain address and does not have anycast (can be used with any `slice`)\nint ext_validate_addr_mc(slice addr) asm \"\"\"\n  DUP\n  b{10011111111} PUSHSLICE SDPPFXREV SWAP\n  267 INT 0 INT SCHKBITREFSQ\n  AND\n\"\"\";\n\n;;; Checking that [addr1] and [addr2] have the same workchain\nint workchains_equal?(slice addr1, slice addr2) asm \"REWRITESTDADDR DROP SWAP REWRITESTDADDR DROP EQUAL\";\n;;; Checking that [addr] have the workchain [wc]\nint workchain_match?(slice addr, int wc) asm(wc addr) \"REWRITESTDADDR DROP EQUAL\";\n;;; Checking that [addr] have the workchain 0\nint basechain_addr?(slice addr) asm \"REWRITESTDADDR DROP 0 EQINT\";\n;;; Checking that [addr] have the workchain -1\nint masterchain_addr?(slice addr) asm \"REWRITESTDADDR DROP -1 EQINT\";\n\n;;; Basic store StateInit construction in `builder` [b].\nbuilder store_state_init(builder b, cell data, cell code) asm(data code b) \"b{00110} STSLICECONST STREF STREF\";\n\n;;; Calculate standard basechain address from `state_init`\n;;slice calc_bc_address(cell state_init) inline {\n;;  return pack_address(BASECHAIN, cell_hash(state_init));\n;;}\n;;\n;;;;; Calculate standard masterchain address from `state_init`\n;;slice calc_mc_address(cell state_init) inline {\n;;  return pack_address(MASTERCHAIN, cell_hash(state_init));\n;;}\n\n;; ===== BOOL =====\n\nconst int TRUE = -1;\nconst int FALSE = 0;\n\n;;; Store binary true b{1} to `builder` [b]\nbuilder store_true(builder b) asm \"STONE\";\n;;; Store binary false b{0} to `builder` [b]\nbuilder store_false(builder b) asm \"STZERO\";\n;;; Store `int` [x] as bool to `builder` [b]\nbuilder store_bool(builder b, int x) asm(x b) \"1 STI\";\n\n;;; Loads bool from `slice` [s]\n(slice, int) load_bool(slice s) asm(-> 1 0) \"1 LDI\";\n\n;;; Checks whether `int` [x] is a “boolean value\" (i.e., either 0 or -1).\nint bool?(int x) asm \"CHKBOOL\";\n\n;;; Skip (Maybe ^Cell) from `slice` [s].\n(slice, ()) ~skip_maybe_ref(slice s) asm \"SKIPOPTREF\";\n(slice, ()) ~skip_dict(slice s) asm \"SKIPOPTREF\";\n\n;; ===== MSG FLAGS =====\n\nconst slice BOUNCEABLE = \"62_\"s; ;; 0b011000 tag - 0, ihr_disabled - 1, bounce - 1, bounced - 0, src = adr_none$00\nconst slice NON_BOUNCEABLE = \"42_\"s; ;; 0b010000 tag - 0, ihr_disabled - 1, bounce - 0, bounced - 0, src = adr_none$00\n\nbuilder store_msg_flags(builder b, int flag) asm(flag b) \"6 STU\";\n\nbuilder store_msg_flags_bounceable(builder b) asm \"b{011000} STSLICECONST\";\nbuilder store_msg_flags_non_bounceable(builder b) asm \"b{010000} STSLICECONST\";\n\n;; load msg_flags only\n(slice, int) ~load_msg_flags(slice s) asm(-> 1 0) \"4 LDU\";\n\n;;; Basic parse MessageX (full_message), returns: flags, sender, forward fee\n(int, slice, int) parse_message(cell full_message) asm \"CTOS 4 LDU LDMSGADDR LDMSGADDR LDGRAMS SKIPDICT LDGRAMS LDGRAMS DROP 3 1 BLKDROP2\";\n\n;;; Checking that the \"bounce\" bit in the flags is set to \"true\"\nint bounceable?(int flags) asm \"2 INT AND\";\n;;; Checking that the \"bounced\" bit in the flags is set to \"true\"\nint bounced?(int flags) asm \"ONE AND\";\n\n(slice, ()) ~skip_bounced_prefix(slice s) asm \"x{FFFFFFFF} SDBEGINS\";\n\n;; ===== MSG BODY =====\n\n;;; Store standard uint32 operation code into `builder` [b]\nbuilder store_op(builder b, int op) asm(op b) \"32 STU\";\n;;; Store standard uint64 query id into `builder` [b]\nbuilder store_query_id(builder b, int query_id) asm(query_id b) \"64 STU\";\n;;; Load standard uint32 operation code from `slice` [s]\n(slice, int) load_op(slice s) asm(-> 1 0) \"32 LDU\";\n;;; Load standard uint64 query id from `slice` [s]\n(slice, int) load_query_id(slice s) asm(-> 1 0) \"64 LDU\";\n\n(slice, (int, int)) ~load_op_and_query_id(slice s) asm(-> 2 0 1) \"32 LDU 64 LDU\";\n\n(slice, ()) ~skip_op(slice s) asm \"32 LDU NIP\";\n(slice, ()) ~skip_query_id(slice s) asm \"32 LDU NIP\";\n\n;; ===== SEND =====\n\nconst int MSG_INFO_REST_BITS = 105; ;;1 + 4 + 4 + 64 + 32\n\n;; https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L155\n;; message$_ {X:Type} info:CommonMsgInfo\n;;  Maybe (Either StateInit ^StateInit)\n;;  body:(Either X ^X) = Message X;\n;;\n;;message$_ {X:Type} info:CommonMsgInfoRelaxed\n;;  init:(Maybe (Either StateInit ^StateInit))\n;;  body:(Either X ^X) = MessageRelaxed X;\n;;\n;;_ (Message Any) = MessageAny;\n\n;; if have StateInit (always place StateInit in ref):\n;; 0b11 for `Maybe (Either StateInit ^StateInit)` and 0b1 or 0b0 for `body:(Either X ^X)`\n\nconst int MSG_WITH_STATE_INIT_AND_BODY_SIZE = 108; ;; MSG_INFO_REST_BITS + 1 + 1 + 1\nconst int MSG_HAVE_STATE_INIT = 4;\nconst int MSG_STATE_INIT_IN_REF = 2;\nconst int MSG_BODY_IN_REF = 1;\n\n;; if no StateInit:\n;; 0b0 for `Maybe (Either StateInit ^StateInit)` and 0b1 or 0b0 for `body:(Either X ^X)`\n\nconst int MSG_ONLY_BODY_SIZE = 107; ;; MSG_INFO_REST_BITS + 1 + 1;\n\n;; ===== SEND MODES =====\n\n;; For `send_raw_message` and `send_message`:\n\n;;; x = 0 is used for ordinary messages; the gas fees are deducted from the senging amount; action phaes should NOT be ignored.\nconst int sendmode::REGULAR = 0;\n;;; +1 means that the sender wants to pay transfer fees separately.\nconst int sendmode::PAY_FEES_SEPARATELY = 1;\n;;; + 2 means that any errors arising while processing this message during the action phase should be ignored.\nconst int sendmode::IGNORE_ERRORS = 2;\n;;; + 32 means that the current account must be destroyed if its resulting balance is zero.\nconst int sendmode::DESTROY = 32;\n;;; x = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.\nconst int sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;\n;;; x = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message).\nconst int sendmode::CARRY_ALL_BALANCE = 128;\n;;; in the case of action fail - bounce transaction. No effect if sendmode::IGNORE_ERRORS (+2) is used. TVM UPGRADE 2023-07.\nconst int sendmode::BOUNCE_ON_ACTION_FAIL = 16;\n\n;; Only for `send_message`:\n\n;;; do not create an action, only estimate fee\nconst int sendmode::ESTIMATE_FEE_ONLY = 1024;\n\n;; Other modes affect the fee calculation as follows:\n;; +64 substitutes the entire balance of the incoming message as an outcoming value (slightly inaccurate, gas expenses that cannot be estimated before the computation is completed are not taken into account).\n;; +128 substitutes the value of the entire balance of the contract before the start of the computation phase (slightly inaccurate, since gas expenses that cannot be estimated before the completion of the computation phase are not taken into account).\n\n;; ===== RESERVE MODES =====\n\n;;; Creates an output action which would reserve exactly x nanograms (if y = 0).\nconst int reserve::REGULAR = 0;\n;;; Creates an output action which would reserve at most x nanograms (if y = 2).\n;;; Bit +2 in y means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved.\nconst int reserve::AT_MOST = 2;\n;;; in the case of action fail - bounce transaction. No effect if RESERVE_AT_MOST (+2) is used. TVM UPGRADE 2023-07.\nconst int reserve::BOUNCE_ON_ACTION_FAIL = 16;\n\n;; ===== TOKEN METADATA =====\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md\n\nconst slice ONCHAIN_CONTENT = \"00\"s;\nconst slice OFFCHAIN_CONTENT = \"01\"s;\nconst slice SNAKE_FORMAT = \"00\"s;\nconst slice CHUNKS_FORMAT = \"01\"s;\n\n;; Key is sha256 hash of string. Value is data encoded as described in \"Data serialization\" paragraph.\n;; Snake format - must be prefixed with 0x00 byte\n(cell, ()) ~set_token_snake_metadata_entry(cell content_dict, int key, slice value) impure {\n  content_dict~udict_set_ref(256, key, begin_cell().store_slice(SNAKE_FORMAT).store_slice(value).end_cell());\n  return (content_dict, ());\n}\n\n;; On-chain content layout The first byte is 0x00 and the rest is key/value dictionary.\ncell create_token_onchain_metadata(cell content_dict) inline {\n  return begin_cell().store_slice(ONCHAIN_CONTENT).store_dict(content_dict).end_cell();\n}\n\n;; ===== BASIC =====\n\n;;; Returns the current length of the `tuple` [t]\nint tuple_length(tuple t) asm \"TLEN\";\n\nbuilder store_zeroes(builder b, int x) asm \"STZEROES\";\nbuilder store_ones(builder b, int x) asm \"STONES\";\n\nbuilder store_varuint16(builder b, int x) asm \"STVARUINT16\";\nbuilder store_varint16(builder b, int x) asm \"STVARINT16\";\nbuilder store_varuint32(builder b, int x) asm \"STVARUINT32\";\nbuilder store_varint32(builder b, int x) asm \"STVARINT32\";\n\n(slice, int) load_varuint16(slice s) asm(-> 1 0) \"LDVARUINT16\";\n(slice, int) load_varint16(slice s) asm(-> 1 0) \"LDVARINT16\";\n(slice, int) load_varuint32(slice s) asm(-> 1 0) \"LDVARUINT32\";\n(slice, int) load_varint32(slice s) asm(-> 1 0) \"LDVARINT32\";\n\n;;; Creates an output action that would modify the collection of this smart contract\n;;; libraries by adding or removing library with code given in `Cell` [code].\n;;; Modes: 0 - remove library, 1 - add private library, 2 - add public library\n() set_library(cell code, int mode) impure asm \"SETLIBCODE\";\n\n(slice, ()) ~skip_ref(slice s) asm \"LDREF NIP\";\n(slice, ()) ~skip_coins(slice s) asm \"LDGRAMS NIP\";\n(slice, ()) ~skip_msg_addr(slice s) asm \"LDMSGADDR NIP\";\n\ncell preload_first_ref(slice s) asm \"0 PLDREFIDX\";\ncell preload_second_ref(slice s) asm \"1 PLDREFIDX\";\ncell preload_third_ref(slice s) asm \"2 PLDREFIDX\";\ncell preload_fourth_ref(slice s) asm \"3 PLDREFIDX\";\n\n;;; Concatenates two builders, but second builder stores as the reference (end_cell -> store_ref)\nbuilder store_builder_as_ref(builder to, builder from) asm(from to) \"STBREF\";\n\n;;; Loads the reference from the slice and parse (load_ref -> begin_parse)\n(slice, slice) load_ref_as_slice(slice s) asm \"LDREFRTOS\";\n\n;;; Returns the TON balance of the smart contract\nint get_ton_balance() asm \"BALANCE FIRST\";\n\n;;; Returns the number of data bits and cell references already stored in `builder` [b].\n(int, int) builder_bits_refs(builder b) asm \"BBITREFS\";\n\n;;; Returns the number of data bits and cell references that can be stored in `builder` [b].\n(int, int) builder_rem_bits_refs(builder b) asm \"BREMBITREFS\";\n\n;;; Checks whether `slice` [pfx] is a prefix of `slice` [s]\nint slice_check_prefix(slice s, slice pfx) asm \"SDPFXREV\";\n;;; Checks whether `slice` [sfx] is a suffix of `slice` [s]\nint slice_check_suffix(slice s, slice sfx) asm \"SDSFXREV\";\n;;; Checks whether there are at least [l] data bits in `slice` [s].\nint slice_check_bits(slice s, int l) asm \"SCHKBITSQ\";\n;;; Checks whether there are at least [r] references in `slice` [s].\nint slice_check_refs(slice s, int r) asm \"SCHKREFSQ\";\n;;; Checks whether there are at least [l] data bits and [r] references in `slice` [s].\nint slice_check_bits_refs(slice s, int l, int r) asm \"SCHKBITREFSQ\";\n\n;;; Checks whether `slice` [s] begins with (the data bits of) [pfx], and removes [pfx] from [s] on success.\n;;(slice, int) slice_begins_with(slice s, slice pfx) asm \"SDBEGINSXQ\";\n\n;;; Store `integer` [x] number as string (UTF-8) in decimal form in `builder` [b].\nbuilder store_number_dec(builder b, int x) asm \"\"\"\n  ZERO                                                        // b x i=0\n  SWAP                                                        // b i=0 x\n  UNTIL:<{                                                    // b i x\n    10 PUSHINT DIVMOD                                         // b i x r\n    48 ADDCONST                                               // b i x r\n    s3 s1 s3 XCHG3                                            // r b x i\n    INC                                                       // r b x i\n    s1 s0 XCPU                                                // r b i x x\n    ISZERO\n  }>\n  DROP\n  REPEAT:<{ 8 STU }>                                          // ..rrr.. b i\n\"\"\";\n\n;;; Store `int` [x] number as string (UTF-8) in hexadecimal form in `builder` [b].\nbuilder store_number_hex(builder b, int x) asm \"\"\"\n  ZERO                                                        // b x i=0\n  SWAP                                                        // b i=0 x\n  UNTIL:<{                                                    // b i x\n    16 PUSHINT DIVMOD                                         // b i x r\n    48 ADDCONST DUP 57 GTINT IF:<{ 7 ADDCONST }>              // b i x r\n    s3 s1 s3 XCHG3                                            // r b x i\n    INC                                                       // r b x i\n    s1 s0 XCPU                                                // r b i x x\n    ISZERO\n  }>\n  DROP\n  REPEAT:<{ 8 STU }>                                          // ..rrr.. b i\n\"\"\";\n\n;;; Returns the continuation located in register c2\ncont get_c2() asm \"c2 PUSH\";\n;;; Store `continuation` [c] to register c2\n() set_c2(cont c) impure asm \"c2 POP\";\n\n;;; DRAFT, not for use in prod\n() send(slice address, int value, builder state_init, builder body, int mode) impure inline {\n  builder message = begin_cell().store_slice(BOUNCEABLE).store_slice(address).store_coins(value).store_zeroes(105);\n\n  ifnot (state_init.null?()) {\n    message = message.store_slice(\"A_\"s).store_builder(state_init); ;; x{A_} == b{10}\n  } else {\n    message = message.store_false();\n  }\n\n  ifnot (body.null?()) {\n    (int b1, int r1) = message.builder_rem_bits_refs();\n    (int b2, int r2) = body.builder_bits_refs();\n    if ((b1 >= b2) & (r1 >= r2)) {\n      message = message.store_false().store_builder(body);\n    } else {\n      message = message.store_true().store_builder_as_ref(body);\n    }\n  } else {\n    message = message.store_false();\n  }\n  send_raw_message(message.end_cell(), mode);\n}\n\n;; ===== STANDARD OP's =====\n\n;; Common (used in TEP-62,74,85)\nconst slice op::excesses               = \"d53276db\"s;\n\n;; TEP-62 - NFT\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md\nconst slice op::transfer_nft           = \"5fcc3d14\"s;\nconst slice op::ownership_assigned     = \"05138d91\"s;\nconst slice op::get_static_data        = \"2fcb26a2\"s;\nconst slice op::report_static_data     = \"8b771735\"s;\n\n;; TEP-66 - NFT Royalty\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0066-nft-royalty-standard.md\nconst slice op::get_royalty_params     = \"693d3950\"s;\nconst slice op::report_royalty_params  = \"a8cb00ad\"s;\n\n;; TEP-74 - Jettons\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md\nconst slice op::transfer_jetton        = \"0f8a7ea5\"s;\nconst slice op::internal_transfer      = \"178d4519\"s;\nconst slice op::transfer_notification  = \"7362d09c\"s;\nconst slice op::burn_notification      = \"7bdd97de\"s;\n\n;; TEP-85 - SBT\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0085-sbt-standard.md\nconst slice op::prove_ownership        = \"04ded148\"s;\nconst slice op::ownership_proof        = \"0524c7ae\"s;\nconst slice op::request_owner          = \"d0c3bfea\"s;\nconst slice op::owner_info             = \"0dd607e3\"s;\nconst slice op::destroy_sbt            = \"1f04537a\"s;\nconst slice op::revoke_sbt             = \"6f89f5e3\"s;\n\n;; TEP-89 - Discoverable Jettons Wallets\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md\nconst slice op::provide_wallet_address = \"2c76b973\"s;\nconst slice op::take_wallet_address    = \"d1735400\"s;\n\n;; ===== DICTS (missing funcs) =====\n\ncell dict_get_ref(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTGETOPTREF\";\ncell udict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETOPTREF\";\n\n(cell, cell) dict_set_get_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTSETGETOPTREF\";\n\ncell dict_set_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTSETREF\";\n(cell, ()) ~dict_set_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTSETREF\";\n\n(cell, int) dict_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) dict_delete?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDEL\";\n(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTGET\" \"NULLSWAPIFNOT\";\n\n(cell, slice, int) dict_delete_get?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~dict_delete_get?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDELGET\" \"NULLSWAPIFNOT\";\n\n(cell, int) dict_replace?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTREPLACE\";\n(cell, int) dict_add?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTADD\";\n\n(cell, int) dict_replace_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTREPLACEB\";\n(cell, int) dict_add_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTADDB\";\n\n(slice, slice, int) dict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTMIN\" \"NULLSWAPIFNOT2\";\n(slice, slice, int) dict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTMAX\" \"NULLSWAPIFNOT2\";\n(slice, cell, int) dict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTMINREF\" \"NULLSWAPIFNOT2\";\n(slice, cell, int) dict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTMAXREF\" \"NULLSWAPIFNOT2\";\n(slice, slice, int) dict_get_next?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) \"DICTGETNEXT\" \"NULLSWAPIFNOT2\";\n(slice, slice, int) dict_get_nexteq?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) \"DICTGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(slice, slice, int) dict_get_prev?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) \"DICTGETPREV\" \"NULLSWAPIFNOT2\";\n(slice, slice, int) dict_get_preveq?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) \"DICTGETPREVEQ\" \"NULLSWAPIFNOT2\";\n\n;; ===== DICTS (new funcs) =====\n\n(slice, cell, int) load_dict?(slice s) asm(-> 1 0 2) \"LDDICTQ\" \"NULLROTRIFNOT\";\n(slice, (cell, int)) ~load_dict?(slice s) asm(-> 1 0 2) \"LDDICTQ\" \"NULLROTRIFNOT\";\n(cell, int) preload_dict?(slice s) asm \"PLDDICTQ\" \"NULLSWAPIFNOT\";\n\n(cell, slice, int) dict_set_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSETGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSETGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISETGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~dict_set_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSETGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSETGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISETGET\" \"NULLSWAPIFNOT\";\n\n(cell, cell, int) dict_set_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTSETGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) udict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) idict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~dict_set_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTSETGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~udict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~idict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETREF\" \"NULLSWAPIFNOT\";\n\n(cell, slice, int) dict_set_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETGETB\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETGETB\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~dict_set_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETGETB\" \"NULLSWAPIFNOT\";\n\n(cell, int) dict_replace_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTREPLACEREF\";\n(cell, int) udict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUREPLACEREF\";\n(cell, int) idict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIREPLACEREF\";\n\n(cell, slice, int) dict_replace_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTREPLACEGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACEGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACEGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~dict_replace_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTREPLACEGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACEGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACEGET\" \"NULLSWAPIFNOT\";\n\n(cell, cell, int) dict_replace_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTREPLACEGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) udict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUREPLACEGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) idict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIREPLACEGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~dict_replace_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTREPLACEGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~udict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUREPLACEGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~idict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIREPLACEGETREF\" \"NULLSWAPIFNOT\";\n\n(cell, slice, int) dict_replace_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTREPLACEGETB\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEGETB\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~dict_replace_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTREPLACEGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEGETB\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEGETB\" \"NULLSWAPIFNOT\";\n\n(cell, int) dict_add_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTADDREF\";\n(cell, int) udict_add_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUADDREF\";\n(cell, int) idict_add_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIADDREF\";\n\n(cell, slice, int) dict_add_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTADDGET\" \"NULLSWAPIF\";\n(cell, slice, int) udict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADDGET\" \"NULLSWAPIF\";\n(cell, slice, int) idict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADDGET\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~dict_add_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTADDGET\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~udict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADDGET\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~idict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADDGET\" \"NULLSWAPIF\";\n\n(cell, cell, int) dict_add_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTADDGETREF\" \"NULLSWAPIF\";\n(cell, cell, int) udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUADDGETREF\" \"NULLSWAPIF\";\n(cell, cell, int) idict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIADDGETREF\" \"NULLSWAPIF\";\n(cell, (cell, int)) ~dict_add_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) \"DICTADDGETREF\" \"NULLSWAPIF\";\n(cell, (cell, int)) ~udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUADDGETREF\" \"NULLSWAPIF\";\n(cell, (cell, int)) ~idict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTIADDGETREF\" \"NULLSWAPIF\";\n\n(cell, slice, int) dict_add_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTADDGETB\" \"NULLSWAPIF\";\n(cell, slice, int) udict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDGETB\" \"NULLSWAPIF\";\n(cell, slice, int) idict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDGETB\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~dict_add_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTADDGETB\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~udict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDGETB\" \"NULLSWAPIF\";\n(cell, (slice, int)) ~idict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDGETB\" \"NULLSWAPIF\";\n\n(cell, cell, int) dict_delete_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDELGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell, int) idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~dict_delete_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) \"DICTDELGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGETREF\" \"NULLSWAPIFNOT\";\n(cell, (cell, int)) ~idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGETREF\" \"NULLSWAPIFNOT\";\n\n(cell, slice, cell, int) dict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMINREF\" \"NULLSWAPIFNOT2\";\n(cell, int, cell, int) udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMINREF\" \"NULLSWAPIFNOT2\";\n(cell, int, cell, int) idict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMINREF\" \"NULLSWAPIFNOT2\";\n(cell, (slice, cell, int)) ~dict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMINREF\" \"NULLSWAPIFNOT2\";\n(cell, (int, cell, int)) ~udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMINREF\" \"NULLSWAPIFNOT2\";\n(cell, (int, cell, int)) ~idict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMINREF\" \"NULLSWAPIFNOT2\";\n\n(cell, slice, cell, int) dict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAXREF\" \"NULLSWAPIFNOT2\";\n(cell, int, cell, int) udict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAXREF\" \"NULLSWAPIFNOT2\";\n(cell, int, cell, int) idict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAXREF\" \"NULLSWAPIFNOT2\";\n(cell, (slice, cell, int)) ~dict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAXREF\" \"NULLSWAPIFNOT2\";\n(cell, (int, cell, int)) ~udict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAXREF\" \"NULLSWAPIFNOT2\";\n(cell, (int, cell, int)) ~idict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAXREF\" \"NULLSWAPIFNOT2\";\n\n;; ===== HASHES =====\n\nint        sha256_from_snake(slice snake)    asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH HASHEXT_SHA256 }> 1 1 CALLXARGS\";\n[int, int] sha512_from_snake(slice snake)    asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH HASHEXT_SHA512 }> 1 1 CALLXARGS\";\n[int, int] blake2b_from_snake(slice snake)   asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH HASHEXT_BLAKE2B }> 1 1 CALLXARGS\";\nint        keccak256_from_snake(slice snake) asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH HASHEXT_KECCAK256 }> 1 1 CALLXARGS\";\n[int, int] keccak512_from_snake(slice snake) asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH HASHEXT_KECCAK512 }> 1 1 CALLXARGS\";\n\nbuilder store_sha256_from_snake(builder b, slice snake)    asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH DEC HASHEXTA_SHA256 }> 2 1 CALLXARGS\";\nbuilder store_sha512_from_snake(builder b, slice snake)    asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH DEC HASHEXTA_SHA512 }> 2 1 CALLXARGS\";\nbuilder store_blake2b_from_snake(builder b, slice snake)   asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH DEC HASHEXTA_BLAKE2B }> 2 1 CALLXARGS\";\nbuilder store_keccak256_from_snake(builder b, slice snake) asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH DEC HASHEXTA_KECCAK256 }> 2 1 CALLXARGS\";\nbuilder store_keccak512_from_snake(builder b, slice snake) asm \"CONT:<{ WHILE:<{ DUP SREFS }>DO<{ LDREFRTOS }> DEPTH DEC HASHEXTA_KECCAK512 }> 2 1 CALLXARGS\";\n\n;; ===== SIGNATURES =====\n\nint check_secp256r1_signature(int hash, slice signature, int public_key) asm \"P256_CHKSIGNU\";\nint check_secp256r1_data_signature(slice data, slice signature, int public_key) asm \"P256_CHKSIGNS\";\nint check_bls_signature(slice data, slice signature, int public_key) asm(public_key data signature) \"BLS_VERIFY\";\n\nint slice_data_equal? (slice a, slice b) asm \"SDEQ\";\n\ntuple god_forgive_me_for_this_type([int, int, int, int, int, int, int, int, int, int, int, int, int] specific_tuple) asm \"NOP\";\n\nint fast_dec_pow(int e) {\n  var t = god_forgive_me_for_this_type([\n    1, ;; 0\n    10,\n    100,\n    1000,\n    10000,\n    100000, ;; 5\n    1000000,\n    10000000,\n    100000000,\n    1000000000,\n    10000000000, ;; 10\n    100000000000,\n    1000000000000 ;; 12\n  ]);\n  return t.at(e);\n}\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\n\n(slice, slice) load_bits_refs(slice s, int bits, int refs) asm \"SPLIT\" \"SWAP\";\n(slice, (slice)) ~load_bits_refs(slice s, int bits, int refs) asm \"SPLIT\" \"SWAP\";\ncell get_code() asm \"MYCODE\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": false
      },
      {
        "name": "external/openlib.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\r\n;; See the LICENSE.md file in the project root for more information.\r\n\r\n;; cherry-picked from https://github.com/continuation-team/openlib.func/blob/main/openlib.func\r\n\r\nint     ext::addr_std?(slice addr) asm \"b{10000000000} PUSHSLICE SDPPFXREV\";\r\n\r\nint     ext::workchains_equal?(slice addr1, slice addr2) asm \"REWRITESTDADDR DROP SWAP REWRITESTDADDR DROP EQUAL\";\r\nint     ext::workchain_match?(slice addr, int wc) asm(wc addr) \"REWRITESTDADDR DROP EQUAL\";\r\n\r\n;; added by hand\r\n\r\nint ext::addr_std_any_wc?(slice addr) asm \"b{100} PUSHSLICE SDPPFXREV\";\r\n;; <<< addr_std$10 anycast:(Maybe Anycast) >>> workchain_id:int8 address:bits256 = MsgAddressInt;\r\n\r\nint ext::is_on_same_workchain?(slice addr) asm \"REWRITESTDADDR DROP MYADDR REWRITESTDADDR DROP EQUAL\";\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "data/universal-dict.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n\nslice upgrade_storage:get!(cell storage, int field_name_hash) impure inline {\n\t(slice value, int found) = storage.udict_get?(256, field_name_hash);\n\tthrow_unless(error::unexpected_empty_value, found);\n\treturn value;\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "data/prices-packed.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n\nconst int max_timestamp_delta = 180;\n\nconst int exotic_cell_type::merkle_proof = 3;\n\nconst int int::max = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\nint prices_packed:get(cell prices_packed, int asset_id) inline {\n    (slice price_packed, _) = prices_packed.udict_get?(256, asset_id);\n    int result = price_packed~load_coins();\n    price_packed.end_parse();\n    return result;\n}\n\nint prices_packed:get?(cell prices_packed, int asset_id) inline {\n\t(slice price_packed, int found) = prices_packed.udict_get?(256, asset_id);\n    ifnot (found) {\n        return -1;\n    }\n    int result = price_packed~load_coins();\n    price_packed.end_parse();\n    return result;\n}\n\n(slice, int) begin_parse_exotic?(cell c) asm \"XCTOS\";\n\n(tuple, int) parse_check_oracles_data(cell oracles_data, cell oracles) impure inline_ref {\n    tuple res = null();\n\n    int cnt = 0;\n    int last_oracle_id = -1;\n    do {\n        slice cs = oracles_data.begin_parse();\n        int oracle_id = cs~load_uint(32);\n        cell proof = cs~load_ref();\n        slice signature = cs~load_bits(512);\n        oracles_data = cs~load_maybe_ref();\n        cs.end_parse();\n\n        (slice ps, int exotic?) = proof.begin_parse_exotic?();\n        throw_unless(error::prices_incorrect_proof, exotic?);\n        throw_unless(error::prices_incorrect_proof, ps~load_uint(8) == exotic_cell_type::merkle_proof);\n        int original_hash = ps~load_uint(256); ;; TON automatically checks that the hash is indeed proven\n\n        (slice vs, int found?) = oracles.udict_get?(32, oracle_id);\n        throw_unless(error::prices_no_such_oracle, found?);\n        int pubkey = vs~load_uint(256);\n        throw_unless(error::prices_incorrect_signature, check_signature(original_hash, signature, pubkey));\n\n        throw_unless(error::prices_incorrect_sequence, oracle_id > last_oracle_id); ;; no data is duplicated\n        last_oracle_id = oracle_id;\n        cnt += 1;\n\n        slice ds = ps~load_ref().begin_parse();\n        ps~skip_bits(16); ;; depth of the deleted subtree, which was replaced by the reference\n        ps.end_parse();\n        int timestamp = ds~load_uint(32);\n        cell prices = ds~load_dict();\n        ds.end_parse();\n\n        int delta = now() - timestamp;\n        throw_unless(error::prices_incorrect_timestamp, (delta >= 0) & (delta < max_timestamp_delta));\n\n        res = cons(prices, res); ;; might add [oracle_id, timestamp, prices] instead\n    } until oracles_data.cell_null?();\n\n    return (res, cnt);\n}\n\nslice udict_get(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"10 THROWIFNOT\";\n\nint check_suggested_price(int asset_id, int price, tuple oracles_prices, int cnt) impure inline_ref {\n    if (cnt % 2) {\n        ;; median is unique, just check that the price is a median\n        int leq_cnt = 0;\n        int geq_cnt = 0;\n        repeat (cnt) {\n            cell prices_dict = oracles_prices~list_next();\n            slice cs = prices_dict.udict_get(256, asset_id);\n            int oracle_price = cs~load_coins();\n            leq_cnt -= (oracle_price <= price);\n            geq_cnt -= (oracle_price >= price);\n        }\n        return (leq_cnt * 2 >= cnt) & (geq_cnt * 2 >= cnt);\n    } else {\n        ;; median is not unique\n        ;; price should be equal to average of two nearest neighbors\n\n        int le_cnt = 0;\n        int gt_cnt = 0;\n        int le_max = -1;\n        int gt_min = int::max;\n        repeat(cnt) {\n            cell prices_dict = oracles_prices~list_next();\n            slice cs = prices_dict.udict_get(256, asset_id);\n            int oracle_price = cs~load_coins();\n            if (oracle_price < price) {\n                le_cnt += 1;\n                le_max = max(le_max, oracle_price);\n            }\n            if (oracle_price > price) {\n                gt_cnt += 1;\n                gt_min = min(gt_min, oracle_price);\n            }\n        }\n\n        int cnt/2 = cnt / 2;\n        if (le_cnt == cnt/2) & (gt_cnt == cnt/2) { ;; most common case\n            return price == (le_max + gt_min) / 2;\n        }\n\n        int leq_cnt = cnt - gt_cnt;\n        int geq_cnt = cnt - le_cnt;\n        ifnot (leq_cnt >= cnt/2) & (geq_cnt >= cnt/2) { ;; it's not a median\n            return false;\n        }\n\n        ;; it's median, but it is equal to some element\n        ;; Possible cases:\n        ;; (1) price is equal to both neighbors\n        ;; (2) price is equal to left neighbor and 1 unit less than right neigbor\n        ;; (3) price is incorrect (not average of two neighbors)\n\n        if (gt_cnt == cnt/2) {\n            ;; price is less than the rigth neighbor, but equal to the left one\n            ;; check that the difference is indeed 1\n            return price == gt_min - 1;\n        }\n\n        return (le_cnt < cnt/2); ;; check that both neigbors are equal\n    }\n}\n\ncell retrieve_median_prices(slice oracles_info, cell assets, cell oracles_data) impure inline {\n    int total_oracles = oracles_info~load_uint(16);\n    int threshold = oracles_info~load_uint(16);\n    cell oracles = oracles_info.preload_ref();\n\n    (tuple oracles_prices, int cnt) = parse_check_oracles_data(oracles_data, oracles);\n\n    throw_unless(error::prices_not_enough_data, cnt >= threshold);\n    throw_if(error::prices_too_much_data, cnt > total_oracles);\n\n    cell res = new_dict();\n    do {\n        slice cs = assets.begin_parse();\n        int id = cs~load_uint(256);\n        int price = cs~load_coins();\n        assets = cs~load_maybe_ref();\n        cs.end_parse();\n\n        throw_unless(error::prices_not_positive, price > 0);\n        throw_unless(error::prices_incorrect_suggested_price, check_suggested_price(id, price, oracles_prices, cnt));\n        res~udict_set_builder(256, id, begin_cell().store_coins(price));\n    } until assets.null?();\n\n    return res;\n}\n\n;; Calling code MUST process prices_packed:error's result and check it for error\n;; the reason prices_packed:error doesn't throw exceptions itself is because:\n;; refunding Jettons requires manually sending a message\n;; (just throwing an exception can only refund TONs, but not Jettons)\n(cell, int) prices_packed:error (cell prices_packed, slice oracles_info) impure {\n    slice prices_unpacked = prices_packed.begin_parse();\n    cell assets = prices_unpacked~load_ref();\n    cell oracles_data = prices_unpacked~load_ref();\n    prices_unpacked.end_parse();\n    try {\n        cell res = retrieve_median_prices(oracles_info, assets, oracles_data);\n        return (res, 0);\n    }\n    catch(_, int n) {\n        return (null(), n);\n    }\n    {-\n    cell prices_dict = prices_unpacked~load_ref();\n    slice signature = prices_unpacked~load_bits(512);\n    int packed_dict_hash = cell_hash(prices_dict);\n    ;; int result = check_signature(packed_dict_hash, signature, oracles_info); ;; admin PK / not address!\n    if (~ result) { return (null(), error::prices_prices_signature_invalid); }\n    int time_key = \"time\"H;\n    (slice time_packed, int found?) = prices_dict~udict_delete_get?(256, time_key);\n    int timeout = 180;\n    int time = time_packed~load_uint(64);\n    if (now() > time + timeout) { return (null(), error::prices_prices_expired); }\n    return (prices_dict, 0);\n    -}\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "data/basic-types.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n\n(slice, int) load_op_code(slice cs) inline {\n\treturn cs.load_uint(32);\n}\n\nbuilder store_op_code(builder b, int op_code) inline {\n\treturn b.store_uint(op_code, 32);\n}\n\n;; ??? How to store prices?\nbuilder store_price(builder b, int price) inline {\n\treturn b.store_uint(price, 64);\n}\n\n(slice, int) load_price(slice cs) inline {\n\treturn cs.load_uint(64);\n}\n\nbuilder store_address_hash(builder b, int address_hash) inline {\n\treturn b.store_uint(address_hash, 256);\n}\n\n(slice, int) load_address_hash(slice cs) inline {\n\treturn cs.load_uint(256);\n}\n\nbuilder store_asset_id(builder b, int asset_id) inline {\n\treturn b.store_uint(asset_id, 256);\n}\n\n(slice, int) load_asset_id(slice cs) inline {\n\treturn cs.load_uint(256);\n}\n\nbuilder store_amount(builder b, int amount) inline {\n\t;; I recommend to ensure that amount is non-negative here\n\treturn b.store_uint(amount, 64);\n\t;; .load_amount is used in parse_liquidate_master_message\n\t;; to store min_collateral_amount, which MUST be non-negative\n\t;; (read the comment in parse_liquidate_master_message)\n\t;; don't change to signed int\n\t;; (or in case you need to - introduce necessary checks in the code)\n}\n\n(slice, int) load_amount(slice cs) inline {\n\treturn cs.load_uint(64);\n}\n\nbuilder store_balance(builder b, int balance) inline {\n\treturn b.store_uint(balance, 64);\n}\n\n(slice, int) load_balance(slice cs) inline {\n\treturn cs.load_uint(64);\n}\n\n;; ??? How to store s_rate and b_rate?\nbuilder store_sb_rate(builder b, int sb_rate) inline {\n\treturn b.store_uint(sb_rate, 64);\n}\n\n(slice, int) load_sb_rate(slice cs) inline {\n\treturn cs.load_uint(64);\n}\n\n;; ??? How to store principal amounts?\n;; (Note it at least can be negative)\nbuilder store_principal(builder b, int principal) inline {\n\treturn b.store_int(principal, 64);\n}\n\n(slice, int) load_principal(slice cs) inline {\n\treturn cs.load_int(64);\n}\n\nint preload_principal(slice cs) inline {\n\treturn cs.preload_int(64);\n}\n\n;; ??? Is timestamp always positive?\nbuilder store_timestamp(builder b, int timestamp) inline {\n\treturn b.store_uint(timestamp, 32);\n}\n\n(slice, int) load_timestamp(slice cs) inline {\n\treturn cs.load_uint(32);\n}\n\n(slice, int) load_bool_ext(slice cs) inline {\n\treturn cs.load_int(2);\n}\n\nbuilder store_tracking_index(builder b, int tracking_index) inline {\n\treturn b.store_uint(tracking_index, 64);\n}\n\n(slice, int) load_tracking_index(slice cs) inline {\n\treturn cs.load_uint(64);\n}\n\n(int) preload_tracking_index(slice cs) inline {\n\treturn cs.preload_uint(64);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-liquidate.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/constants.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/logs.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../messages/liquidate-message.fc\";\n#include \"../logic/addr-calc.fc\";\n#include \"../logic/master-get-methods.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/utils.fc\";\n\ncell master_core_logic_liquidate_asset_unchecked(\n  int user_version, cell user_code, int query_id,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  slice borrower_address,\n  int collateral_asset_id, int min_collateral_amount,\n  slice liquidator_address,\n  int transferred_asset_id, int transferred_amount,\n  int TON_reserve_amount, \n  int forward_ton_amount, cell custom_response_payload,\n  cell prices_packed,\n  int fwd_fee, int msg_value\n) impure {\n  (_, _, _, _, _, int token_balance, _, _, _) =\n    asset_dynamics_collection.asset_dynamics_collection:get_unpacked(collateral_asset_id);\n\n  asset_dynamics_collection~update_old_rates_and_provided_asset_id(\n    asset_config_collection, collateral_asset_id, transferred_asset_id\n  );\n\n  ;; ----- Check: don't liquidate too much -----\n  ;; I was thinking if we can calculate collateral_amount here on master, but looks like \"no\" because we don't know user's loan_present (of the transferred_asset_id).\n  ;; Or we'd have to either:\n  ;; a) strict-reject liquidation (on User) if user doesn't have enough loan_present (instead of soft-accepting it with lower liquidatable_amount)\n  ;; b) use the value calculated on master for checking that the liquidation doesn't liquidate too much of master's assets and (in case loan_present is < transferred_amount) recalculate get_collateral_quote\n  ;;NOTE if we want to set liquidity as supply - borrow then uncomment here\n  ;;int collateral_liquidity = get_asset_liquidity(\n  ;;  total_supply_principal, total_borrow_principal,\n  ;;  s_rate, b_rate\n  ;;);\n  int collateral_liquidity = token_balance;\n\n  int max_allowed_liquidation = muldiv(collateral_liquidity, 3, 4);\n  ;; Specific comparison below with 3/4th is a bit arbitrary\n  if (min_collateral_amount > max_allowed_liquidation) {\n    ;; Liquidating too much of our liquidity at once\n    ;; This is not allowed, because there is a higher chance that after getting a liquidation-approval from the User smart contract (and corresponding locking of funds there), the 3rd and the final phase of checks (on the Master: is there enough liquidity) will fail causing the liquidation failure and \"revert\".\n    ;; The bad part is that after 2nd phase of checks (on the User) funds there get temporarily locked and become unavailable for further liquidation -> thus making it (theoretically?) possible to prevent liquidation of the specific Owner by spamming large liquidation requests.\n    ;; Check with min_collateral_amount (instead of final collateral_amount) is not \"directly\" bulletproof: hacker may set low min_collateral_amount, but that would risk a lot of his funds because of all soft-checks that allow liquidation to proceed as long as min_collateral_amount is satisfied.\n\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _\n    ) = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n\n    ;; Refund asset\n    immediate_asset_refund(\n      liquidator_address,\n      query_id,\n      jw_address_hash, transferred_amount, \n      pack_liquidation_fail_report_message(\n        build_master_liquidating_too_much_error(max_allowed_liquidation),\n        custom_response_payload\n      ), forward_ton_amount\n    );\n\n    ;; Note that we don't break execution:\n    ;; We update asset_dynamics_collection with new s/b-rates regardless\n  } else {\n    raw_reserve(TON_reserve_amount, reserve::AT_MOST + 2);\n\n    cell liquidate_user_message = pack_liquidate_user_message(\n      query_id,\n      asset_config_collection, asset_dynamics_collection,\n      collateral_asset_id, min_collateral_amount,\n      liquidator_address,\n      transferred_asset_id, transferred_amount, \n      forward_ton_amount, custom_response_payload,\n      prices_packed\n    );\n\n    int enough_fee = liquidate_min_attachment(fwd_fee, liquidate_user_message) + forward_ton_amount;\n\n    throw_unless(\n      error::liquidate_asset_transaction_fees,\n      msg_value >= enough_fee\n    );\n\n    send_message_to_lending_wallet(\n      BLANK_CODE(), user_version, user_code, borrower_address, ;; <- the meaning is of owner_address\n      liquidate_user_message,\n      sendmode::CARRY_ALL_BALANCE ;; <- in combination with raw_reserve with mode=4\n      ;; should resend the whole value of the original message minus \"amount\" and fees\n    );\n  }\n\n  return asset_dynamics_collection;\n}\n\ncell liquidate_jetton(\n  int user_version, cell user_code, int query_id,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int msg_value, int fwd_fee,\n  slice borrower_address,\n  int collateral_asset_id, int min_collateral_amount,\n  slice liquidator_address,\n  int transferred_asset_id, int transferred_amount,\n  int forward_ton_amount, cell custom_response_payload,\n  cell prices_packed\n) impure inline {\n  return master_core_logic_liquidate_asset_unchecked(\n    user_version, user_code, query_id,\n    asset_config_collection, asset_dynamics_collection,\n    borrower_address,\n    collateral_asset_id, min_collateral_amount,\n    liquidator_address,\n    transferred_asset_id, transferred_amount,\n    0, ;; TON_reserve_amount\n    forward_ton_amount, custom_response_payload,\n    prices_packed,\n    fwd_fee, msg_value\n  );\n}\n\ncell liquidate_ton(\n  int user_version, cell user_code, int query_id,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int msg_value, int liquidate_incoming_amount, int fwd_fee,\n  slice borrower_address,\n  int collateral_asset_id, int min_collateral_amount,\n  slice liquidator_address, \n  int forward_ton_amount, cell custom_response_payload,\n  cell prices_packed\n) impure inline {\n  ;; we don't reserve TON yet\n  ;; liquidation might fail right away\n  ;; and in that case we refund the received TON/jetton immediately\n  return master_core_logic_liquidate_asset_unchecked(\n    user_version, user_code, query_id,\n    asset_config_collection, asset_dynamics_collection,\n    borrower_address,\n    collateral_asset_id, min_collateral_amount,\n    liquidator_address,\n    constants::ton_asset_id,\n    ;; Withhold some amount of TONs for blockchain fees\n    liquidate_incoming_amount,\n    liquidate_incoming_amount, ;; TON_reserve_amount\n    forward_ton_amount, custom_response_payload,\n    prices_packed,\n    fwd_fee, msg_value\n  );\n}\n\n() liquidate_master_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  (slice borrower_address, slice liquidator_address, int collateral_asset_id, int min_collateral_amount, int liquidate_incoming_amount, int include_user_code, int forward_ton_amount, cell custom_response_payload, cell prices_packed) = parse_liquidate_master_message(in_msg_body);\n\n  throw_unless(error::invalid_address_provided, is_valid_address?(borrower_address));\n  throw_unless(error::invalid_address_provided, is_valid_address?(liquidator_address));\n  throw_if(error::invalid_data, collateral_asset_id == constants::ton_asset_id);\n  throw_unless(error::custom_response_payload_too_big, is_valid_custom_response_payload?(custom_response_payload));\n\n  int prices_error_code = prices_packed~prices_packed:error(oracles_info);\n  throw_if(prices_error_code, prices_error_code); ;; non-zero codes throw\n\n  (_, int user_version, _, _, _, cell user_code, _, _) = upgrade_config.unpack_upgrade_config();\n\n  asset_dynamics_collection = liquidate_ton(\n    user_version, include_user_code ? user_code : null(), query_id,\n    asset_config_collection, asset_dynamics_collection,\n    msg_value, liquidate_incoming_amount, fwd_fee,\n    borrower_address,\n    collateral_asset_id, min_collateral_amount,\n    liquidator_address, forward_ton_amount, custom_response_payload, prices_packed\n  );\n  ;; The only reason we save is to update s/b-rate of the corresponding asset\n  ;; this is just a request to liquidate, no confirmation yet,\n  ;; so no amounts change\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection,\n    if_active, oracles_info, admin, tokens_keys, \n    asset_dynamics_collection\n  );\n  return ();\n}\n\n() liquidate_unsatisfied_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  var (\n    owner_address, liquidator_address,\n    transferred_asset_id, transferred_amount,\n    collateral_asset_id, min_collateral_amount,\n    forward_ton_amount, custom_response_payload,\n    error\n  ) = parse_liquidate_unsatisfied_message(in_msg_body);\n\n  ;; Verify this is a message from lending-user smart contract\n  throw_unless(\n    error::liquidate_unsatisfied_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n\n  msg_value -= fee::liquidate_unsatisfied;\n\n  (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n\n  if (transferred_asset_id == constants::ton_asset_id){\n    raw_reserve(my_balance - transferred_amount - msg_value, reserve::REGULAR);\n  } else {\n    raw_reserve(0, 4);\n  }\n\n  send_asset_ext(\n    liquidator_address, query_id,\n    jw_address_hash, transferred_amount,\n    forward_ton_amount,\n    pack_liquidation_fail_report_message(begin_cell().store_slice(error), custom_response_payload),\n    sendmode::CARRY_ALL_BALANCE ;; <- in combination with raw_reserve with mode=4\n  );\n  ;; ^ Note how we don't check if that asset is available for refund,\n  ;; because it HAS to be available\n  ;; This is due to the fact that when we received the asset to use for liquidation, we didn't increase the in-storage balance of this asset's availability, thus making it not possible to use the received asset for anything other than the Refund\n\n  ;; Due to the same reason,\n  ;; we DON'T need to save anything to contract storage here - nothing changes there\n  return ();\n}\n\n() liquidate_satisfied_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  var (\n    owner_address, liquidator_address,\n    transferred_asset_id,\n    delta_loan_principal, liquidatable_amount, protocol_gift,\n    new_user_loan_principal,\n    collateral_asset_id,\n    delta_collateral_principal, collateral_reward,\n    min_collateral_amount,\n    new_user_collateral_principal, forward_ton_amount, custom_response_payload\n  ) = parse_liquidate_satisfied_message(in_msg_body);\n  ;; delta_loan_principal and delta_collateral_principal - are how much corresponding principals DECREASE\n  ;; delta_collateral_principal is going to be positive, because collateral is going to be send to liquidator\n  ;; delta_loan_principal is going to be negative, because liquidator transferred some 'loan', so loan_principal actually increased (so decrease is negative)\n\n  ;; Verify this is a message from lending-user smart contract\n  int user_version = upgrade_config.upgrade_config:user_code_version();\n  throw_unless(\n    error::liquidate_satisfied_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n\n  ;; Original amount sent for liquidation\n  int transferred_amount = liquidatable_amount + protocol_gift;\n  (int collateral_s_rate, int collateral_b_rate,\n   int collateral_total_supply_principal, int collateral_total_borrow_principal,\n   int collateral_last_accrual, int collateral_token_balance,\n   int collateral_tracking_supply_index, int collateral_tracking_borrow_index,\n   int collateral_awaited_supply\n   ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(collateral_asset_id);\n\n  ;;NOTE if we want to set liquidity as supply - borrow then uncomment here\n  ;;int collateral_liquidity = get_asset_liquidity(\n  ;;  total_supply_principal, total_borrow_principal,\n  ;;  s_rate, b_rate\n  ;;);\n  int collateral_liquidity = collateral_token_balance;\n\n  if (collateral_reward <= collateral_liquidity) {\n    ;; Enough liquidity -> proceed with liquidation\n\n    int new_collateral_total_supply = collateral_total_supply_principal - delta_collateral_principal;\n    int new_collateral_total_borrow = collateral_total_borrow_principal;\n\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _\n    ) = asset_config_collection.asset_config_collection:get_unpacked(collateral_asset_id);\n\n    ;; Update collateral balance\n    asset_dynamics_collection~asset_dynamics_collection:set_packed(\n      collateral_asset_id,\n      collateral_s_rate, collateral_b_rate, ;; These are unpacked values\n      new_collateral_total_supply,\n      new_collateral_total_borrow,\n      collateral_last_accrual,\n      collateral_token_balance - collateral_reward, ;; Update balance\n      collateral_tracking_supply_index, collateral_tracking_borrow_index,\n      collateral_awaited_supply\n    );\n\n    (int loan_s_rate, int loan_b_rate,\n      int loan_total_supply_principal, int loan_total_borrow_principal,\n      int loan_last_accrual, int loan_token_balance,\n      int loan_tracking_supply_index, int loan_tracking_borrow_index,\n      int loan_awaited_supply\n      ) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(transferred_asset_id);\n\n    int loan_new_total_supply = loan_total_supply_principal;\n    int loan_new_total_borrow = loan_total_borrow_principal + delta_loan_principal;\n\n    asset_dynamics_collection~asset_dynamics_collection:set_packed(\n      transferred_asset_id,\n      loan_s_rate, loan_b_rate, ;; These are unpacked values\n      loan_new_total_supply,\n      loan_new_total_borrow,\n      ;; ^ Decreasing total principal (-) = Increasing borrow principal (+), that is why it's '+'\n      loan_last_accrual,\n      loan_token_balance + transferred_amount, ;; Update balance\n      loan_tracking_supply_index, loan_tracking_borrow_index,\n      loan_awaited_supply\n    );\n\n    ;; Notify lending-user of success\n    ;; So it can decrease ongoing liquidation count\n    int success_message_fee =\n    modest_fwd_fee_estimation(fwd_fee) + fee::liquidate_success;\n\n    send_message_to_lending_wallet_by_address(\n      null(), success_message_fee, ;; state_init don't need\n      user_version, null(), ;; null upgrade_info\n      sender_address, pack_liquidate_success_message(\n        query_id,\n        transferred_asset_id, delta_loan_principal,\n        loan_tracking_supply_index, loan_tracking_borrow_index,\n        collateral_asset_id, delta_collateral_principal,\n        collateral_tracking_supply_index, collateral_tracking_borrow_index\n      ),\n      sendmode::REGULAR\n    );\n\n    msg_value -= success_message_fee;\n    msg_value -= fee::log_tx;\n\n    cell log_data = begin_cell()\n      .store_uint(log::liquidate_success, 8) ;; withdraw code\n      .store_slice(owner_address) ;; user addr\n      .store_slice(sender_address) ;; user sc addr\n      .store_slice(liquidator_address) ;; liquidator addr\n      .store_uint(now(), 32) ;; current time\n      .store_ref(begin_cell() ;; attached supply asset data\n        .store_uint(transferred_asset_id, 256)\n        .store_uint(transferred_amount, 64)\n        .store_int(new_user_loan_principal, 64)\n        .store_int(loan_new_total_supply, 64)\n        .store_int(loan_new_total_borrow, 64)\n        .store_uint(loan_s_rate, 64)\n        .store_uint(loan_b_rate, 64)\n        .end_cell())\n      .store_ref(begin_cell() ;; attached redeemed asset data\n        .store_uint(collateral_asset_id, 256)\n        .store_uint(collateral_reward, 64)\n        .store_int(new_user_collateral_principal, 64)\n        .store_int(new_collateral_total_supply, 64)\n        .store_int(new_collateral_total_borrow, 64)\n        .store_uint(collateral_s_rate, 64)\n        .store_uint(collateral_b_rate, 64)\n        .end_cell())\n      .end_cell();\n\n    emit_log_simple(log_data);\n\n    if (collateral_asset_id == constants::ton_asset_id){\n      raw_reserve(my_balance - collateral_reward - msg_value, reserve::REGULAR);\n    } else {\n      raw_reserve(0, 4);\n    }\n\n    send_asset_ext(\n      liquidator_address, query_id,\n      jw_address_hash, collateral_reward,\n      forward_ton_amount,\n      pack_liquidation_success_report_message(\n        query_id,\n        transferred_asset_id,\n        transferred_amount,\n        collateral_asset_id,\n        collateral_reward,\n        custom_response_payload\n      ),\n      sendmode::CARRY_ALL_BALANCE\n    );\n\n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection,\n      if_active, oracles_info, admin, tokens_keys, \n      asset_dynamics_collection\n    );\n    ;; return() is right after \"if-else\" block\n  } else {\n    ;; Not enough liquidity - revert\n    ;; ???? It strict rejects\n    ;; but *maybe* it should allow transactions where \n    ;; collateral_liquidity >= min_collateral_amount\n\n    ;; Notify lending-user of fail\n    ;; So it can revert liquidation changes\n    ;; and unlock itself\n    int fail_message_fee =\n      modest_fwd_fee_estimation(fwd_fee) + fee::liquidate_fail;\n\n    send_message_to_lending_wallet_by_address(\n      null(), fail_message_fee, ;; state_init don't need\n      user_version, null(), ;; null upgrade_info\n      sender_address, pack_liquidate_fail_message(\n        query_id,\n        transferred_asset_id,\n        delta_loan_principal,\n        collateral_asset_id,\n        delta_collateral_principal\n      ),\n      sendmode::REGULAR\n    );\n\n    msg_value -= fail_message_fee;\n\n    if (transferred_asset_id == constants::ton_asset_id){\n      raw_reserve(my_balance - transferred_amount - msg_value, reserve::REGULAR);\n    } else {\n      raw_reserve(0, 4);\n    }\n\n    ;; Refund asset\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n    send_asset_ext(\n      liquidator_address, query_id,\n      jw_address_hash, transferred_amount,\n      forward_ton_amount,\n      pack_liquidation_fail_report_message(\n        build_master_not_enough_liquidity_error(\n          collateral_liquidity\n        ),\n        custom_response_payload\n      ),\n      sendmode::CARRY_ALL_BALANCE\n    );\n    ;; Once again (as with Liquidation Unsatisfied):\n    ;; we don't need to check if enough of transferred_asset is available for refund - there HAS to be\n    ;; and we don't need to update contract storage - nothing changed\n  }\n  return ();\n}\n\n() liquidate_satisfied_handle_exception (\n  int my_balance, int msg_value, slice in_msg_body, slice sender_address, int fwd_fee,\n  cell upgrade_config, cell asset_config_collection, int query_id\n) impure inline {\n  ;; There might be some duplicated code from above, but this is an exception handler\n  ;; Therefore, it should have distinct code, and merging it into some common function may have\n  ;;   unintended side effects in the future\n\n  var (\n    _, liquidator_address, transferred_asset_id, delta_loan_principal, liquidatable_amount,\n    protocol_gift, _, collateral_asset_id, delta_collateral_principal, _, _, _, forward_ton_amount, custom_response_payload\n  ) = parse_liquidate_satisfied_message(in_msg_body);\n\n  int user_version = upgrade_config.upgrade_config:user_code_version();\n\n  int fail_message_fee = modest_fwd_fee_estimation(fwd_fee) + fee::liquidate_fail;\n\n  int transferred_amount = liquidatable_amount + protocol_gift;\n\n  send_message_to_lending_wallet_by_address(\n    null(), fail_message_fee, ;; state_init don't need\n    user_version, null(), ;; null upgrade_info\n    sender_address, pack_liquidate_fail_message(\n      query_id,\n      transferred_asset_id,\n      delta_loan_principal,\n      collateral_asset_id,\n      delta_collateral_principal\n    ),\n    sendmode::REGULAR\n  );\n\n  msg_value -= fail_message_fee;\n\n  if (transferred_asset_id == constants::ton_asset_id){\n    raw_reserve(my_balance - transferred_amount - msg_value, reserve::REGULAR);\n  } else {\n    raw_reserve(0, 4);\n  }\n\n  ;; Refund asset\n  (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _)\n    = asset_config_collection.asset_config_collection:get_unpacked(transferred_asset_id);\n\n  send_asset_ext(\n    liquidator_address, query_id,\n    jw_address_hash, transferred_amount,\n    forward_ton_amount,\n    pack_liquidation_fail_report_message(\n      build_execution_crashed_error(),\n      custom_response_payload\n    ),\n    sendmode::CARRY_ALL_BALANCE\n  );\n}\n\n() liquidate_master_jetton_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int jetton_op_code, int query_id, int jetton_amount, slice from_address, int user_version, cell user_code ;; jetton tx body params\n) impure inline {\n  (slice borrower_address, slice liquidator_address, int collateral_asset_id, int min_collateral_amount, _, int include_user_code, int forward_ton_amount, cell custom_response_payload, cell prices_packed) = parse_liquidate_master_message(in_msg_body);\n  (slice token_id, int found) = tokens_keys.udict_get?(256, addr_hash);\n\n  ifnot(is_valid_custom_response_payload?(custom_response_payload)) {\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(error::custom_response_payload_too_big).end_cell(), forward_ton_amount\n    );\n    return ();\n  }\n\n  int addresses_are_valid = is_valid_address?(borrower_address) & is_valid_address?(liquidator_address);\n  ifnot (addresses_are_valid) {\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(error::invalid_address_provided).store_ref(custom_response_payload).end_cell(), forward_ton_amount\n    );\n    return ();\n  }\n\n  int prices_error_code = prices_packed~prices_packed:error(oracles_info);\n  if (prices_error_code) { ;; non-zero codes are errors\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(prices_error_code).store_ref(custom_response_payload).end_cell(), forward_ton_amount\n    );\n    return ();\n  }\n\n  int transferred_asset_id = token_id~load_asset_id();\n  if (collateral_asset_id == transferred_asset_id) {\n    respond_send_jetton(\n      sender_address, from_address,\n      query_id, jetton_amount,\n      begin_cell().store_op_code(error::invalid_data).store_ref(custom_response_payload).end_cell(), forward_ton_amount\n    );\n    return ();\n  }\n\n  asset_dynamics_collection = liquidate_jetton(\n    user_version, include_user_code ? user_code : null(), query_id,\n    asset_config_collection, asset_dynamics_collection,\n    msg_value, fwd_fee,\n    borrower_address,\n    collateral_asset_id, min_collateral_amount,\n    liquidator_address, ;; address of whoever sent jettons - that's gonna be liquidator\n    transferred_asset_id, jetton_amount,\n    forward_ton_amount, custom_response_payload,\n    prices_packed\n  );\n\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection,\n    if_active, oracles_info, admin, tokens_keys, \n    asset_dynamics_collection\n  );\n  return ();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "data/asset-dynamics-packer.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/errors.fc\";\n#include \"../external/stdlib.fc\";\n#include \"basic-types.fc\";\n\n;; --------------- Structure methods ---------------\n\ncell pack_asset_dynamics(\n\tint s_rate, int b_rate,\n\tint total_supply_principal, int total_borrow_principal,\n\tint last_accrual, int token_balance,\n\tint tracking_supply_index, int tracking_borrow_index,\n\tint awaited_supply\n) {\n\tthrow_if(error::sys::integer_out_of_expected_range, total_supply_principal < 0);\n\tthrow_if(error::sys::integer_out_of_expected_range, total_borrow_principal < 0);\n\treturn begin_cell()\n\t\t.store_sb_rate(s_rate)\n\t\t.store_sb_rate(b_rate)\n\t\t.store_principal(total_supply_principal)\n\t\t.store_principal(total_borrow_principal)\n\t\t.store_timestamp(last_accrual)\n\t\t.store_balance(token_balance)\n\t\t.store_tracking_index(tracking_supply_index)\n\t\t.store_tracking_index(tracking_borrow_index)\n\t\t.store_balance(awaited_supply)\n\t\t.end_cell();\n}\n\n(int, int, int, int, int, int, int, int, int) unpack_asset_dynamics(slice asset_dynamics) {\n\tint asset_s_rate = asset_dynamics~load_sb_rate();\n\tint asset_b_rate = asset_dynamics~load_sb_rate();\n\t\n\tint total_supply_principal = asset_dynamics~load_principal();\n\tint total_borrow_principal = asset_dynamics~load_principal();\n\t;; we dont need load_int here\n\t;; nns2009: ... yes, but:\n\t;; 1) \"unpack\" has to mirror \"pack\" to avoid future surprises\n\t;; 2) All principals across the project are stored consistently to avoid confusion\n\t;; 3) In a theoretical case there is a \"de-sync\" (total_*_principal doesn't match the sum of all Users' principals), it's preferrable that:\n\t;; - total_*_principal becomes negative\n\t;; - utilization becomes negative\n\t;; - supply_interest and borrow_interest become of different signs\n\t;;   => So interest accumulation works incorrectly,\n\t;; + But *slowly* and *gradually* incorrectly accumulating percentages,\n\t;;   instead of the protocol stopping entirely\n\t;;   with inability to even Withdraw/Reclaim your own assets\n\t\n\tint last_accrual = asset_dynamics~load_timestamp();\n\tint token_balance = asset_dynamics~load_balance();\n\tint tracking_supply_index = asset_dynamics~load_tracking_index();\n\tint tracking_borrow_index = asset_dynamics~load_tracking_index();\n\tint awaited_supply = asset_dynamics~load_balance();\n\t\n\treturn (\n\t\tasset_s_rate, asset_b_rate,\n\t\ttotal_supply_principal, total_borrow_principal,\n\t\tlast_accrual, token_balance,\n\t\ttracking_supply_index, tracking_borrow_index,\n\t\tawaited_supply\n\t);\n}\n\n;; --------------- Collection methods ---------------\n\n(int, int, int, int, int, int, int, int, int) asset_dynamics_collection:get_unpacked(\n\tcell asset_dynamics_collection, int asset_id\n) {\n\t(slice asset_dynamics, _) = asset_dynamics_collection.udict_get?(256, asset_id);\n\treturn unpack_asset_dynamics(asset_dynamics);\n}\n\n(cell, ()) asset_dynamics_collection:set_packed( \n\tcell asset_dynamics_collection, int asset_id,\n\tint s_rate, int b_rate,\n\tint total_supply_principal, int total_borrow_principal,\n\tint last_accrual, int token_balance,\n \tint tracking_supply_index, int tracking_borrow_index,\n\tint awaited_supply\n) {\n\tcell asset_dynamics = pack_asset_dynamics(\n\t\ts_rate, b_rate,\n\t\ttotal_supply_principal, total_borrow_principal,\n\t\tlast_accrual, token_balance,\n\t\ttracking_supply_index, tracking_borrow_index,\n\t\tawaited_supply\n\t);\n\n\treturn (asset_dynamics_collection.udict_set(\n\t\t256, asset_id, asset_dynamics.begin_parse() \n\t), ());\n}\n\nint asset_dynamics_collection:has?(\n\tcell asset_dynamics_collection, int asset_id\n) {\n\t(_, int f) = asset_dynamics_collection.udict_get?(256, asset_id);\n\treturn f;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "data/asset-config-packer.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../data/basic-types.fc\";\n\n;; --------------- Structure methods ---------------\n\n(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int) unpack_asset_config(slice asset_config) {\n\tint jw_address_hash = asset_config~load_uint(256); \n\tint decimals = asset_config~load_uint(8);\n\t\n\tcell asset_config_params_packed = asset_config~load_ref();\n\tslice asset_config_params = asset_config_params_packed.begin_parse();\n\n\tint collateral_factor = asset_config_params~load_uint(16);\n\tint liquidation_threshold = asset_config_params~load_uint(16); \n\tint liquidation_bonus = asset_config_params~load_uint(16);\n\tint base_borrow_rate = asset_config_params~load_uint(64); \n\tint borrow_rate_slope_low = asset_config_params~load_uint(64); \n\tint borrow_rate_slope_high = asset_config_params~load_uint(64);\n\tint supply_rate_slope_low = asset_config_params~load_uint(64); \n\tint supply_rate_slope_high = asset_config_params~load_uint(64);\n\tint target_utilization = asset_config_params~load_uint(64);\n\tint origination_fee = asset_config_params~load_uint(64);\n\tint dust_value = asset_config_params~load_uint(64);\n\tint max_total_supply = asset_config_params~load_uint(64);\n\tint reserve_factor = asset_config_params~load_uint(16);\n\tint liquidation_reserve_factor = asset_config_params~load_uint(16); \n\tint min_principal_for_rewards = asset_config_params~load_uint(64); \n\tint base_tracking_supply_speed = asset_config_params~load_uint(64); \n\tint base_tracking_borrow_speed = asset_config_params~load_uint(64); \n\n  return (\n\t\tjw_address_hash, decimals,\n\t\tcollateral_factor, liquidation_threshold,\n\t\tliquidation_bonus, base_borrow_rate,\n\t\tborrow_rate_slope_low, borrow_rate_slope_high,\n\t\tsupply_rate_slope_low, supply_rate_slope_high,\n\t\ttarget_utilization, origination_fee,\n\t\tdust_value, max_total_supply,\n\t\treserve_factor, liquidation_reserve_factor,\n\t\tmin_principal_for_rewards, base_tracking_supply_speed,\n\t\tbase_tracking_borrow_speed\n\t);\n}\n\ncell pack_asset_config(\n\t\tint jw_address_hash, int decimals,\n\t\tint collateral_factor,\n\t\tint liquidation_threshold, int liquidation_bonus,\n\t\tint base_borrow_rate, int borrow_rate_slope_low,\n\t\tint borrow_rate_slope_high, int supply_rate_slope_low,\n\t\tint supply_rate_slope_high, int target_utilization,\n\t\tint origination_fee, int dust_value, int max_total_supply,\n\t\tint reserve_factor, int liquidation_reserve_factor,\n\t\tint min_principal_for_rewards, int base_tracking_supply_speed,\n\t\tint base_tracking_borrow_speed\n) {\n\treturn begin_cell()\n\t\t.store_uint(jw_address_hash, 256)\n\t\t.store_uint(decimals, 8) \n\t\t.store_ref(begin_cell()\n\t\t\t.store_uint(collateral_factor, 16) \n\t\t\t.store_uint(liquidation_threshold, 16) \n\t\t\t.store_uint(liquidation_bonus, 16)\n\t\t\t.store_uint(base_borrow_rate, 64) \n\t\t\t.store_uint(borrow_rate_slope_low, 64) \n\t\t\t.store_uint(borrow_rate_slope_high, 64) \n\t\t\t.store_uint(supply_rate_slope_low, 64) \n\t\t\t.store_uint(supply_rate_slope_high, 64) \n\t\t\t.store_uint(target_utilization, 64)\n\t\t\t.store_uint(origination_fee, 64)\n\t\t\t.store_uint(dust_value, 64)\n\t\t\t.store_uint(max_total_supply, 64)\n\t\t\t.store_uint(reserve_factor, 16)\n\t\t\t.store_uint(liquidation_reserve_factor, 16)\n\t\t\t.store_uint(min_principal_for_rewards, 64)\n\t\t\t.store_uint(base_tracking_supply_speed, 64)\n\t\t\t.store_uint(base_tracking_borrow_speed, 64)\n\t\t.end_cell())\n\t.end_cell();\n}\n\n\n\n;; --------------- Collection methods ---------------\n\n(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int)\n\tasset_config_collection:get_unpacked(cell asset_config_collection, int asset_id)\n{\n\t(slice asset_config, _) = asset_config_collection.udict_get?(256, asset_id);\n\treturn unpack_asset_config(asset_config);\n}\n\n;; for future use\nint asset_config_collection:get_jetton_wallet(cell asset_config_collection, int asset_id)\n{\n\t(slice asset_config, _) = asset_config_collection.udict_get?(256, asset_id);\n\t(int jetton_wallet, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _) = asset_config.unpack_asset_config();\n\treturn jetton_wallet;\n}\n\nint asset_config_collection:decimals(cell asset_config_collection, int asset_id) {\n\t(slice asset_config, _) = asset_config_collection.udict_get?(256, asset_id);\n\t\n\tasset_config~load_address_hash(); ;; jw_address_hash\n\treturn asset_config.preload_uint(8); ;; decimals\n}\n\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/user-withdrawal.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/fees.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../messages/supply-message.fc\";\n#include \"../messages/withdraw-message.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/user-utils.fc\";\n\n() withdraw_success_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (int asset_id, int principal_amount, int tracking_supply_index, int tracking_borrow_index) = parse_withdraw_success_message(in_msg_body);\n\n  (int base_tracking_index, int base_tracking_accrued) = user_rewards.get_reward(asset_id);\n\n  int new_principal = user_principals.get_principal(asset_id);\n  int old_principal = new_principal + principal_amount;\n\n  (base_tracking_index, base_tracking_accrued) = accrue_user_indexes(base_tracking_index, base_tracking_accrued, tracking_supply_index, tracking_borrow_index, old_principal, new_principal);\n\n  user_rewards~set_reward(asset_id, base_tracking_index, base_tracking_accrued);\n\n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address, \n    pack_withdraw_success_excess_message(\n      op::withdraw_success,\n      query_id\n    )\n  );\n\n  user::storage::save(code_version, master_address, owner_address, user_principals, user_state::free, user_rewards, backup_cell_1, backup_cell_2);\n  return ();\n}\n\n() withdraw_success_handle_exception (\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, int query_id\n) impure inline {\n  ;; The only possible problem is that something went wrong with rewards logic\n  ;; Need to unlock user and send success message regardless\n\n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address,\n    pack_withdraw_success_excess_message(\n      op::withdraw_success,\n      query_id\n    )\n  );\n\n  user::storage::save(code_version, master_address, owner_address, user_principals, user_state::free, user_rewards, backup_cell_1, backup_cell_2);\n}\n\n() withdraw_fail_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (int asset_id, int principal_amount) = parse_withdraw_fail_message(in_msg_body);\n  int optimistic_principal = user_principals.get_principal(asset_id);\n  int reverted_principal = optimistic_principal + principal_amount; ;; withdraw failed - revert\n  user_principals~set_principal(asset_id, reverted_principal);\n  ;; Not enough funds - at least refund TON attachment to the owner\n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address, \n    pack_withdraw_excess_message(\n      op::withdraw_no_funds_excess,\n      query_id\n    )\n  );\n  ;; Update user_principals and Unlock\n  user::storage::save(code_version, master_address, owner_address, user_principals, user_state::free, user_rewards, backup_cell_1, backup_cell_2);\n  return ();\n}\n\n() withdraw_user_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  if (state != user_state::free) {\n    ;; Refund TON attachment to the owner (and ignore the request in other respects)\n    try_reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      owner_address, \n      pack_withdraw_excess_message(\n        op::withdraw_locked_excess,\n        query_id\n      )\n    );\n    return ();\n  }\n\n  (int asset_id, int withdraw_amount_current,\n   int s_rate, int b_rate, slice recipient_address,\n   cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed,\n   int forward_ton_amount, cell custom_response_payload\n   )\n   = parse_withdraw_user_message(in_msg_body);\n\n  (int jw_address_hash, int decimals, int collateral_factor,\n      int liquidation_threshold, _, int base_borrow_rate,\n      int borrow_rate_slope_low, int borrow_rate_slope_high, int supply_rate_slope_low,\n      int supply_rate_slope_high, int target_utilization, int origination_fee, int dust, _, _, _, _, _, _) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n  int is_full_withdrawal = withdraw_amount_current == constants::max_uint64;\n  int old_principal = user_principals.get_principal(asset_id);\n  if (is_full_withdrawal){\n    (withdraw_amount_current, int enough_price_data) = calculate_maximum_withdraw_amount(\n      asset_config_collection, asset_dynamics_collection,\n      user_principals, prices_packed, asset_id, old_principal\n    );\n\n    if ((~ enough_price_data) | (withdraw_amount_current <= 0)) { ;; check that withdraw_amount_current is positive (we can have some edge cases where withdraw_amount_current will be calculated as 0 or even negative)\n      try_reserve_and_send_rest(\n        fee::min_tons_for_storage,\n        owner_address,\n        pack_withdraw_excess_message(\n          op::withdraw_missing_prices_excess,\n          query_id\n        )\n      );\n      return ();\n    }\n  }\n\n  int present = present_value(s_rate, b_rate, old_principal);\n  present -= withdraw_amount_current;\n\n  int new_principal = principal_value(s_rate, b_rate, present);\n\n  user_principals~set_principal(asset_id, new_principal);\n  ;; should check if any asset is in debt if not we don't need the rest of calculation and we can also ignore prices\n\n  (int borrow_is_collateralized, int enough_price_data) = is_borrow_collateralized(\n    asset_config_collection, asset_dynamics_collection,\n    user_principals, prices_packed\n  );\n\n  if (borrow_is_collateralized) { ;; we dont need to check enough_price_data here because borrow_is_collateralized var will be false if there is not enough price data & there is edge case where we dont need prices at all -> if there is no debt in user princpals\n    (int borrow_amount_principal, int reclaim_amount_principal)\n      = around_zero_split(new_principal, old_principal);\n    if (borrow_amount_principal > 0) { ;; note this will add origination_fee to borrow amount\n      ;; this might cause the borrow to be not collateralized but because it's very small and we already have a safe gap it's ok\n      int amount_to_borrow_in_present = - present_value(s_rate, b_rate, - borrow_amount_principal);\n      present -= amount_to_borrow_in_present.muldiv(origination_fee, constants::origination_fee_scale);\n      new_principal = principal_value(s_rate, b_rate, present);\n      \n      ;; now we need to recalculate borrow_amount_principal and reclaim_amount_principal after origination_fee\n      (borrow_amount_principal, reclaim_amount_principal)\n        = around_zero_split(new_principal, old_principal);\n    }\n\n    user_principals~set_principal(asset_id, new_principal);\n\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_withdraw_collateralized_message(\n        query_id,\n        owner_address, asset_id,\n        withdraw_amount_current, new_principal,\n        borrow_amount_principal, reclaim_amount_principal, recipient_address, \n        forward_ton_amount, custom_response_payload\n      )\n    );\n    ;; Update user_principals and Lock contract\n    user::storage::save(code_version, master_address, owner_address, user_principals, user_state::withdrawing, user_rewards, backup_cell_1, backup_cell_2);\n    return ();\n  } else {\n    ;; Otherwise (borrow not collateralized) - refund TON attachment to the owner\n    ;; (and ignore the request in other respects)\n    try_reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      owner_address, \n      pack_withdraw_excess_message(\n        enough_price_data\n          ? op::withdraw_not_collateralized_excess\n          : op::withdraw_missing_prices_excess,\n        query_id\n      )\n    );\n    return ();\n  }\n}\n\n() withdraw_user_handle_exception(slice owner_address, int query_id) impure inline {\n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address,\n    pack_withdraw_excess_message(\n      op::withdraw_execution_crashed,\n      query_id\n    )\n  );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/user-supply.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/fees.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../messages/supply-message.fc\";\n#include \"../messages/withdraw-message.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/user-utils.fc\";\n\n() supply_user_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (int asset_id, int supply_amount_current,\n    int s_rate, int b_rate,\n    int dust, int max_token_amount,\n    int total_supply, int total_borrow,\n    int tracking_supply_index, int tracking_borrow_index,\n    int forward_ton_amount, cell custom_response_payload) = parse_supply_user_message(in_msg_body);\n  \n  ;; state check\n  if (state != user_state::free) {\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_supply_fail_message(\n        query_id, owner_address,\n        asset_id, supply_amount_current,\n        forward_ton_amount, custom_response_payload\n      )\n    );\n    return ();\n  }\n\n  ;; ???? What if Supply happens during liquidation?\n  ;; What to do with received funds?\n\n  ;; set new principal\n  int old_principal = user_principals.get_principal(asset_id);\n  int present = present_value(s_rate, b_rate, old_principal);\n  present += supply_amount_current;\n  int new_principal = principal_value(s_rate, b_rate, present);\n  \n  if ((new_principal < dust) & (new_principal > 0)) { \n    new_principal = 0;\n  }\n\n  (int repay_amount_principal,\n   int supply_amount_principal) = around_zero_split(old_principal, new_principal);\n\n  int new_total_supply = total_supply + supply_amount_principal;\n  int new_total_borrow = total_borrow - repay_amount_principal;\n\n  ;; max cap check and negative new total borrow check\n  if (((new_total_supply > max_token_amount) & (max_token_amount != 0) & (supply_amount_principal > 0)) | (new_total_borrow < 0)) {\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_supply_fail_message(\n        query_id, owner_address,\n        asset_id, supply_amount_current,\n        forward_ton_amount, custom_response_payload\n      )\n    );\n    return ();\n  }\n\n  user_principals~set_principal(asset_id, new_principal);\n\n  ;; rewards tracking\n  (int base_tracking_index, int base_tracking_accrued) = user_rewards.get_reward(asset_id);\n\n  (base_tracking_index, base_tracking_accrued) = accrue_user_indexes(base_tracking_index, base_tracking_accrued, tracking_supply_index, tracking_borrow_index, old_principal, new_principal);\n\n  user_rewards~set_reward(asset_id, base_tracking_index, base_tracking_accrued);\n\n  ;; success msg to master sc\n  reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    master_address,\n    pack_supply_success_message(\n      query_id, owner_address,\n      asset_id, supply_amount_current, new_principal,\n      repay_amount_principal, supply_amount_principal, custom_response_payload\n    )\n  );\n\n  user::storage::save(code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2);\n  return ();\n}\n\n() supply_user_handle_exception (slice in_msg_body, slice master_address, slice owner_address, int query_id) impure inline {\n  (int asset_id, int supply_amount_current, _, _, _, _, _, _, _, _,\n    int forward_ton_amount, cell custom_response_payload) = parse_supply_user_message(in_msg_body);\n\n  reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    master_address,\n    pack_supply_fail_message(\n      query_id, owner_address,\n      asset_id, supply_amount_current,\n      forward_ton_amount, custom_response_payload\n    )\n  );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/user-other.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../constants/op-codes.fc\";\n\n() get_store_process (\n  int query_id, cell in_msg_body, slice sender_address\n) impure inline {\n  cell ds = get_data();\n\n  send_message(\n    sender_address,\n    0,\n    begin_cell()\n      .store_op_code(op::get_store_response)\n      .store_query_id(query_id)\n      .store_ref(in_msg_body)\n      .store_ref(ds)\n    .end_cell(),\n    sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n  );\n\n  return ();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/user-liquidate.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/constants.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../constants/fees.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../messages/liquidate-message.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/user-utils.fc\";\n\n() liquidate_success_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (\n    int transferred_asset_id,\n    int delta_loan_principal,\n    int loan_tracking_supply_index, int loan_tracking_borrow_index,\n    int collateral_asset_id,\n    int delta_collateral_principal,\n    int collateral_tracking_supply_index, int collateral_tracking_borrow_index\n  ) = parse_liquidate_success_message(in_msg_body);\n\n  {\n    int new_principal = user_principals.get_principal(collateral_asset_id);\n    int old_principal = new_principal + delta_collateral_principal;\n\n    (int base_tracking_index, int base_tracking_accrued) = user_rewards.get_reward(collateral_asset_id);\n\n    (base_tracking_index, base_tracking_accrued) = accrue_user_indexes(base_tracking_index, base_tracking_accrued, collateral_tracking_supply_index, collateral_tracking_borrow_index, old_principal, new_principal);\n\n    user_rewards~set_reward(collateral_asset_id, base_tracking_index, base_tracking_accrued);\n  }\n\n  {\n    int new_principal = user_principals.get_principal(transferred_asset_id);\n    int old_principal = new_principal + delta_loan_principal;\n\n    (int base_tracking_index, int base_tracking_accrued) = user_rewards.get_reward(transferred_asset_id);\n\n    (base_tracking_index, base_tracking_accrued) = accrue_user_indexes(base_tracking_index, base_tracking_accrued, loan_tracking_supply_index, loan_tracking_borrow_index, old_principal, new_principal);\n\n    user_rewards~set_reward(transferred_asset_id, base_tracking_index, base_tracking_accrued);\n  }\n   \n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address, \n    pack_liquidate_excess_message(\n      op::liquidate_success_report_to_user,\n      query_id\n    )\n  );\n\n  user::storage::save(\n    code_version,\n    master_address, owner_address,\n    user_principals, state - 1, ;; Decrease ongoing liquidation count\n    user_rewards, backup_cell_1, backup_cell_2\n  );\n  return ();\n}\n\n() liquidate_success_handle_exception (\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, int query_id\n) impure inline {\n  try_reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    owner_address,\n    pack_liquidate_excess_message(\n      op::liquidate_success_report_to_user,\n      query_id\n    )\n  );\n\n  user::storage::save(\n    code_version,\n    master_address, owner_address,\n    user_principals, state - 1, ;; Decrease ongoing liquidation count\n    user_rewards, backup_cell_1, backup_cell_2\n  );\n  return ();\n}\n\n() liquidate_fail_process(\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (\n    int transferred_asset_id,\n    int delta_loan_principal, ;; liquidatable_amount, protocol_gift, <- not relevant\n    int collateral_asset_id,\n    int delta_collateral_principal ;; collateral_reward <- not relevant\n    ;; debug info:\n    ;; , min_collateral_amount, collateral_present  <- not relevant\n  ) = parse_liquidate_fail_message(in_msg_body);\n  ;; liquidation failed - revert\n  int optimistic_collateral_principal = user_principals.get_principal(collateral_asset_id);\n  int reverted_collateral_principal = optimistic_collateral_principal + delta_collateral_principal; \n  user_principals~set_principal(collateral_asset_id, reverted_collateral_principal);\n\n  int optimistic_loan_principal = user_principals.get_principal(transferred_asset_id);\n  int reverted_loan_principal = optimistic_loan_principal + delta_loan_principal; \n  user_principals~set_principal(transferred_asset_id, reverted_loan_principal);\n  ;; Unlike op::withdraw_fail, we don't refund TON attachment to the owner here\n  ;; because it is handled while refunding liquidation- (transferred-) asset on the master\n  ;; Update user_principals and liquidation count\n  user::storage::save(\n    code_version,\n    master_address, owner_address,\n    user_principals, state - 1, ;; Decrease ongoing liquidation count\n    user_rewards, backup_cell_1, backup_cell_2\n  ); \n  return ();\n}\n\n\n() liquidate_user_process(\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  (cell asset_config_collection, cell asset_dynamics_collection, cell prices_packed,\n   int collateral_asset_id, int min_collateral_amount,\n   slice liquidator_address,\n   int transferred_asset_id, int transferred_amount,\n   int forward_ton_amount, cell custom_response_payload\n   )\n   = parse_liquidate_user_message(in_msg_body);\n  \n  if (state < 0) {\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_liquidate_unsatisfied_message(\n        query_id, owner_address,\n        liquidator_address,\n        transferred_asset_id, transferred_amount,\n        collateral_asset_id, min_collateral_amount,\n        forward_ton_amount, custom_response_payload,\n        build_user_withdraw_in_progress_error()\n      )\n    );\n    return ();\n  }\n  \n  ;; ----- Check is liquidatable and if all neccessary prices are supplied -----\n  (int liquidatable, int enough_price_data, int supply_amount, int borrow_amount) =\n    is_liquidatable(asset_config_collection, asset_dynamics_collection, user_principals, prices_packed);\n  ifnot (liquidatable) {\n    ;; if prices_ok is false, liquidatable is also false\n    builder message = enough_price_data\n      ? build_not_liquidatable_error()\n      : build_liquidation_prices_missing();\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_liquidate_unsatisfied_message(\n        query_id, owner_address,\n        liquidator_address,\n        transferred_asset_id, transferred_amount,\n        collateral_asset_id, min_collateral_amount,\n        forward_ton_amount, custom_response_payload,\n        message\n      )\n    );\n    return (); \n  }\n\n  ;; ----- Check enough loan -----\n  (int loan_s_rate, int loan_b_rate, _, _, _, _, _, _, _)\n    = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(transferred_asset_id);\n  int loan_principal = user_principals.get_principal(transferred_asset_id);\n  int loan_present = - present_value(loan_s_rate, loan_b_rate, loan_principal);\n\n  (_, _, _, _, int liquidation_bonus, _, _, _, _, _, _, _, _, _, _, int liquidation_reserve_factor, _, _, _) =\n    asset_config_collection.asset_config_collection:get_unpacked(collateral_asset_id);\n\n  int transferred_amount_minus_reserve = muldiv(transferred_amount, (constants::reserve_liquidation_scale - liquidation_reserve_factor), constants::reserve_liquidation_scale);\n\n  int liquidatable_amount = min(transferred_amount_minus_reserve, loan_present);\n  ;; ^ Can't liquidate more than the current loan\n  ;; loan_present can be < 0, in case there is no loan on this position\n  ;; this is not a problem because subsequent call to get_collateral_quote will return a negative amount\n  ;; and the subsequent check that this amount satisfies min_collateral_amount will fail\n  ;; transferred_amount is still used further in the code though, because in case of liquidation failure we need to refund the full transferred_amount\n\n  ;; ---- Check min_collateral_amount satisfied ----\n  (int collateral_amount, enough_price_data) = get_collateral_quote(\n    asset_config_collection,\n    transferred_asset_id, liquidatable_amount,\n    collateral_asset_id, prices_packed\n    ;; collateralization ;; liquidation_bonus <- There was an idea to calculate it dynamically\n  );\n  ;; min_collateral_amount is uint, and therefore is always >= 0\n  ;;\n  if (collateral_amount < min_collateral_amount) {\n    ;; if not enough price data, collateral_amount will be -1\n    builder message = enough_price_data\n      ? build_min_collateral_not_satisfied_error(collateral_amount)\n      : build_liquidation_prices_missing();\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_liquidate_unsatisfied_message(\n        query_id, owner_address,\n        liquidator_address,\n        transferred_asset_id, transferred_amount,\n        collateral_asset_id, min_collateral_amount,\n        forward_ton_amount, custom_response_payload,\n        message\n      )\n    );\n    return (); \n  }\n\n  ;; ----- Check enough collateral -----\n  (int collateral_s_rate, int collateral_b_rate, _, _, _, _, _, _, _)\n    = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(collateral_asset_id);\n  int collateral_principal = user_principals.get_principal(collateral_asset_id);\n  int collateral_present = present_value(collateral_s_rate, collateral_b_rate, collateral_principal);\n\n  if (collateral_present < min_collateral_amount) {\n    reserve_and_send_rest(\n      fee::min_tons_for_storage,\n      master_address,\n      pack_liquidate_unsatisfied_message(\n        query_id, owner_address,\n        liquidator_address,\n        transferred_asset_id, transferred_amount,\n        collateral_asset_id, min_collateral_amount,\n        forward_ton_amount, custom_response_payload,\n        build_user_not_enough_collateral_error(collateral_present)\n      )\n    );\n    return (); \n  }\n\n  int collateral_reward = min(\n    collateral_amount,\n    collateral_present ;; Not rewarding more of asset then there is on user's balance\n  );\n\n  int isBadDebt = borrow_amount != 0\n    ? (supply_amount * constants::asset_coefficient_scale / borrow_amount) < liquidation_bonus\n    : false;\n\n  ifnot (isBadDebt) {\n    ;; ----- Check not liquidating too much -----\n    int max_not_too_much = muldiv(collateral_present, 1, 2);\n    {\n      ;; Below certain value ($100?) should be liquidatable entirely:\n      int collateral_decimals = asset_config_collection.asset_config_collection:decimals(collateral_asset_id);\n      ;; get_collateral_quote higher in code checks that collateral_asset_id price is present\n      int collateral_price = prices_packed.prices_packed:get(collateral_asset_id);\n\n      int usd_allowed_liquidation = 100;\n      ;; atomic_amount = usd_allowed_liquidation / price_per_atomic\n      ;; atomic_amount = usd_allowed_liquidation / (price_per_unit / fast_dec_pow(collateral_decimals))\n      ;; atomic_amount = usd_allowed_liquidation / ((collateral_price / constants::price_scale) / fast_dec_pow(collateral_decimals))\n      ;; atomic_amount = usd_allowed_liquidation * constants::price_scale * fast_dec_pow(collateral_decimals) / collateral_price;\n      int max_not_too_much_fixed = collateral_price != 0\n        ? usd_allowed_liquidation * constants::price_scale * fast_dec_pow(collateral_decimals) / collateral_price\n        : max_not_too_much;\n      if (max_not_too_much_fixed > max_not_too_much) {\n        max_not_too_much = max_not_too_much_fixed;\n      }\n      ;; Note that throughout the rest of the code, constants::price_scale doesn't really matter:\n      ;; Withdraw and Liquidate are relative: we could multiply all prices by the same amount and nothing would change\n      ;; (well, as long as division errors and storage bit-restrictions don't come into play)\n      ;; This is the *only* place were we operate with the absolute value of some asset (equivalent of $100)\n      ;; instead of operating relative to other assets (like everywhere else)\n    }\n    ;; Essentially, max_not_too_much = max(collateral_present*50%, $100 / exchange_rate)\n    ;; NOTE: !!!! ^ 50% and $100 - very arbitrary\n    if (max_not_too_much < min_collateral_amount) {\n      reserve_and_send_rest(\n        fee::min_tons_for_storage,\n        master_address,\n        pack_liquidate_unsatisfied_message(\n          query_id, owner_address,\n          liquidator_address,\n          transferred_asset_id, transferred_amount,\n          collateral_asset_id, min_collateral_amount,\n          forward_ton_amount, custom_response_payload,\n          build_user_liquidating_too_much_error(max_not_too_much)\n        )\n      );\n      return ();\n    }\n\n    collateral_reward = min(\n      collateral_reward,\n      max_not_too_much ;; And no more than would be too much\n    );\n  }\n  \n  collateral_present -= collateral_reward;\n  loan_present -= liquidatable_amount;\n  int new_loan_principal = principal_value(loan_s_rate, loan_b_rate, - loan_present);\n  int new_collateral_principal = principal_value(collateral_s_rate, collateral_b_rate, collateral_present);\n  ;; NOTE: ^ It is well known which sign (collateral - positive and loan - negative) these values have,\n  ;; so might as well use more direct function to calculate present_value to save some gas\n\n  ;; int delta_loan_principal = new_loan_principal - loan_principal; ;; loan principals are negative => reverse subtraction order <- Wrong\n  int delta_loan_principal = loan_principal - new_loan_principal; ;; How much (a)Loan (b)Decreased is loan_old-loan_new\n  int delta_collateral_principal = collateral_principal - new_collateral_principal;\n  int protocol_gift = transferred_amount - liquidatable_amount; ;; ??? Free assets for the protocol\n  reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    master_address,\n    pack_liquidate_satisfied_message(\n      query_id,\n      owner_address, liquidator_address,\n      transferred_asset_id,\n      delta_loan_principal, liquidatable_amount, protocol_gift,\n      new_loan_principal,\n      collateral_asset_id,\n      delta_collateral_principal, collateral_reward, min_collateral_amount,\n      new_collateral_principal,\n      forward_ton_amount, custom_response_payload\n    )\n  );\n  user_principals~set_principal(collateral_asset_id, new_collateral_principal);\n  user_principals~set_principal(transferred_asset_id, new_loan_principal);\n  user::storage::save(\n    code_version,\n    master_address, owner_address,\n    user_principals,\n    state + 1, ;; Increase ongoing liquidation count\n     user_rewards, backup_cell_1, backup_cell_2\n  );\n  return ();\n}\n\n() liquidate_user_handle_exception(\n  slice in_msg_body, slice master_address, slice owner_address, int query_id\n) impure inline {\n  (_, _, _,\n    int collateral_asset_id, int min_collateral_amount,\n    slice liquidator_address,\n    int transferred_asset_id, int transferred_amount,\n    int forward_ton_amount, cell custom_response_payload\n    )\n  = parse_liquidate_user_message(in_msg_body);\n\n  reserve_and_send_rest(\n    fee::min_tons_for_storage,\n    master_address,\n    pack_liquidate_unsatisfied_message(\n      query_id, owner_address,\n      liquidator_address,\n      transferred_asset_id, transferred_amount,\n      collateral_asset_id, min_collateral_amount,\n      forward_ton_amount, custom_response_payload,\n      build_execution_crashed_error()\n    )\n  );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/user-admin.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../messages/idle-message.fc\";\n#include \"../logic/tx-utils.fc\";\n\n() debug_principals_edit_user_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  cell new_principals = in_msg_body~load_dict();\n  user::storage::save(code_version, master_address, owner_address, new_principals, state,   user_rewards, backup_cell_1, backup_cell_2);\n  return ();\n}\n\n() idle_user_process (\n  slice sender_address, slice in_msg_body_original, int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; handle_transaction params\n  int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2, ;; user storage params\n  int op, int query_id ;; tx body params\n) impure inline {\n  ;; Nothing happens here\n  ;; this op code is added just for upgrade without executing anything\n  (cell tokens_keys, slice originator_address) = parse_idle_user_message(in_msg_body);\n  ;; The only reason we even need originator_address\n  ;; is to refund remaining TONs, but even that is optional\n\n  send_message(\n    originator_address, 0,\n    pack_idle_excess_message(query_id),\n    sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE + 2 ;; +2 - Ignore errors of sending\n    ;; In case there aren't enough TONs to send the message,\n    ;; it doesn't matter - the main thing is contract upgrade\n  );\n  return ();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-withdrawal.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/logs.fc\";\n#include \"../data/asset-dynamics-packer.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../messages/withdraw-message.fc\";\n#include \"../logic/addr-calc.fc\";\n#include \"../logic/master-get-methods.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"../logic/utils.fc\";\n\ncell master_core_logic_withdraw (\n  int user_version, cell user_code,\n  cell asset_config_collection, cell asset_dynamics_collection,\n  int msg_value, int fwd_fee,\n  slice owner_address, int asset_id, int amount, int query_id, cell prices_packed, slice recipient_address,\n  int forward_ton_amount, cell custom_response_payload\n) impure {\n  asset_dynamics_collection~update_old_rates_and_provided_asset_id(\n    asset_config_collection,  asset_id, 0\n  );\n\n  (int s_rate, int b_rate, _, _, _, _, _, _, _) = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  cell withdraw_user_message = pack_withdraw_user_message(\n    query_id,\n    asset_id, amount,\n    s_rate, b_rate,\n    asset_config_collection, asset_dynamics_collection, prices_packed, recipient_address,\n    forward_ton_amount, custom_response_payload\n  );\n\n  int enough_fee = withdraw_min_attachment(fwd_fee, withdraw_user_message) + forward_ton_amount;\n  throw_unless(\n    error::withdraw_master_transaction_fees,\n    msg_value >= enough_fee\n  );\n\n  send_message_to_lending_wallet(\n    BLANK_CODE(), user_version, user_code, owner_address,\n    withdraw_user_message, sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n  );\n\n  return asset_dynamics_collection;\n}\n\n() withdraw_master_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  (int asset_id, int amount, slice recipient_address, int include_user_code, cell prices_packed, int forward_ton_amount, cell custom_response_payload) = parse_withdraw_master_message(in_msg_body);\n\n  throw_unless(error::invalid_address_provided, is_valid_address?(recipient_address));\n  throw_unless(error::custom_response_payload_too_big, is_valid_custom_response_payload?(custom_response_payload));\n\n  if (~ prices_packed.null?()) {\n    int prices_error_code = prices_packed~prices_packed:error(oracles_info);\n    throw_if(prices_error_code, prices_error_code); ;; non-zero codes throw\n  }\n  \n  (_, int user_version, _, _, _, cell user_code, _, _) = upgrade_config.unpack_upgrade_config();\n  \n  asset_dynamics_collection = master_core_logic_withdraw(\n    user_version, include_user_code ? user_code : null(),\n    asset_config_collection, asset_dynamics_collection,\n    msg_value, fwd_fee,\n    sender_address, asset_id,\n    amount, query_id,\n    prices_packed, recipient_address,\n    forward_ton_amount, custom_response_payload\n  );\n\n  ;; The only reason we save is to update s/b-rate of the corresponding asset\n  ;; this is just a request to withdraw, no confirmation yet,\n  ;; so no amounts change\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection, \n    if_active, oracles_info, admin, tokens_keys, \n    asset_dynamics_collection\n  );\n  return ();\n}\n\n() withdraw_collateralized_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  (slice owner_address, int asset_id, int withdraw_amount_current, int user_new_principal,\n    int borrow_amount_principal, int reclaim_amount_principal, slice recipient_address, int forward_ton_amount, cell custom_response_payload)\n    = parse_withdraw_collateralized_message(in_msg_body);\n\n  ;; Verify this is a message from lending-user smart contract\n  \n  int user_version = upgrade_config.upgrade_config:user_code_version();\n  throw_unless(\n    error::withdraw_collateralized_fake_sender,\n    slice_data_equal?(\n      sender_address,\n      calculate_user_address(BLANK_CODE(), owner_address)\n    )\n  );\n\n  (int s_rate, int b_rate,\n   int total_supply_principal, int total_borrow_principal,\n   int last_accrual, int token_balance, int tracking_supply_index, int tracking_borrow_index,\n   int awaited_supply\n  )\n    = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n  int asset_liquidity_minus_reserves = get_asset_liquidity_minus_reserves(\n    total_supply_principal, total_borrow_principal,\n    s_rate, b_rate, token_balance\n  );\n\n  int asset_liquidity = token_balance;\n  int borrow_amount_present = present_value_borrow_calc(b_rate, borrow_amount_principal);\n\n  ;; Above is the more sofisticated formula from Vlad and below is the corresponding check:\n  ;; it accounts for developer's money, and doesn't allow to withdraw using devs' funds\n  ;; My original (intuitive) check was: withdraw_amount_current > token_balance\n  if ((withdraw_amount_current > asset_liquidity) | (borrow_amount_present > asset_liquidity_minus_reserves)) {\n    ;; User withdraw request is collateralized, but unfortunately ...\n    ;; we just DON'T have enough of the corresponding token to send it\n    ;; \"No money, but hang on\"\n\n    ;; We need to send op::withdraw_fail message to the user smart contract to:\n    ;; a) Let it unlock itself\n    ;; b) Make it revert it's corresponding principal balance\n    ;; c) Make it refund TON attachment excess\n    send_message_to_lending_wallet_by_address(\n      null(), 0, ;; state_init don't need\n      user_version, null(), ;; null upgrade_info\n      sender_address, pack_withdraw_fail_message(\n        query_id, asset_id,\n        borrow_amount_principal + reclaim_amount_principal\n      ), sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n\n    ;; Consider refund fee excesses\n    ;; Added: I thought all refunding had been already done\n    ;; More added: yes, it was done, the fee-refund happens on User at op::withdraw_fail\n  } else {\n    ;; User withdraw request is collateralized\n    ;; and we HAVE enough of asset to satisfy it\n    int new_total_supply = total_supply_principal - reclaim_amount_principal;\n    int new_total_borrow = total_borrow_principal + borrow_amount_principal;\n\n    (int jw_address_hash, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _\n    ) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n    asset_dynamics_collection~asset_dynamics_collection:set_packed(\n      asset_id,\n      s_rate, b_rate,\n      new_total_supply, new_total_borrow,\n      last_accrual, token_balance - withdraw_amount_current,\n      tracking_supply_index, tracking_borrow_index,\n      awaited_supply\n    );\n\n    ;; msg_value -= fee::withdraw_collateralized;\n\n    int success_message_fee =\n      modest_fwd_fee_estimation(fwd_fee) + fee::withdraw_success;\n    msg_value -= success_message_fee;\n    msg_value -= fee::log_tx;\n\n    ;; We also need to send op::withdraw_success message to the user smart contract\n    ;; to let it unlock itself\n\n    send_message_to_lending_wallet_by_address(\n      null(), success_message_fee, ;; state_init don't need\n      user_version, null(), ;; null upgrade_info\n      sender_address, pack_withdraw_success_message(\n        query_id, asset_id, borrow_amount_principal + reclaim_amount_principal,\n        tracking_supply_index, tracking_borrow_index\n      ), sendmode::REGULAR\n    );\n  \n    cell log_data = begin_cell()\n      .store_uint(log::withdraw_success, 8) ;; withdraw code\n      .store_slice(owner_address) ;; user addr\n      .store_slice(sender_address) ;; user sc addr\n      .store_slice(recipient_address) ;; recipient_address \n      .store_uint(now(), 32) ;; current time\n      .store_ref(begin_cell().end_cell()) ;; supply asset data (nothic cause its withdraw)\n      .store_ref(begin_cell() ;; attached redeemed asset data\n        .store_uint(asset_id, 256) \n        .store_uint(withdraw_amount_current, 64) \n        .store_int(user_new_principal, 64) \n        .store_int(new_total_supply, 64) \n        .store_int(new_total_borrow, 64) \n        .store_uint(s_rate, 64) \n        .store_uint(b_rate, 64) \n        .end_cell())\n      .end_cell();\n\n    emit_log_simple(log_data);\n\n    if (asset_id == constants::ton_asset_id){\n      ;; N.B. forward_ton_amount is contained in msg_value, because it is enforced in enough_fee\n      raw_reserve(my_balance - withdraw_amount_current - msg_value, reserve::REGULAR);\n    } else {\n      raw_reserve(0, 4);\n    }\n\n    send_asset_ext(\n      recipient_address, query_id,\n      jw_address_hash, withdraw_amount_current,\n      forward_ton_amount,\n      pack_withdraw_excess_message_with_data(op::withdraw_success, query_id, custom_response_payload),\n      sendmode::CARRY_ALL_BALANCE \n    );\n\n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection, \n      if_active, oracles_info, admin, tokens_keys, \n      asset_dynamics_collection\n    );\n  }\n  ;; We only accept op::withdraw_collateralized from lending-user smart contracts,\n  ;; which means the corresponding lending-user smart contract\n  ;; had already been initialized by the point we received this message,\n  ;; which means it's fine not to include deploy info (state-init) in the message\n  ;; and just use send_message (instead of send_message_to_lending_wallet)\n  ;; to have a lighter message\n  return ();\n}\n\n() withdraw_collateralized_handle_exception  (\n  slice in_msg_body, slice sender_address, cell upgrade_config, int query_id\n) impure inline {\n  (_, int asset_id, _, _, int borrow_amount_principal, int reclaim_amount_principal, _, _, _)\n    = parse_withdraw_collateralized_message(in_msg_body);\n\n  int user_version = upgrade_config.upgrade_config:user_code_version();\n\n  send_message_to_lending_wallet_by_address(\n    null(), 0, ;; state_init don't need\n    user_version, null(), ;; null upgrade_info\n    sender_address, pack_withdraw_fail_message(\n      query_id, asset_id,\n      borrow_amount_principal + reclaim_amount_principal\n    ), sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n  );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "constants/op-codes.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n;; Computing op codes from TL-B schema doesn't really lead to **any** advantages\n;; furthermore, the protocol is designed to be upgradeable,\n;; so there CAN'T be a guaranteed fixed schema for messages\n\n;; Let's assign op codes, so they make some kind of sense\n;; and it's easier to do debugging.\n\n;; op codes encode the sequence of transactions\n\n;; Mnemonics:\n;; A = Admin\n;; D = Debug\n;; E = Edit\n;; F = Fail\n;; a = accept\n;; e = excess\n;; f = fail\n;; d = Dai(Russian) or Dar(Spanish) = send\n\n;; In the ending:\n;; low number = Yes/Good,\n;; high number = No/Bad\n\n;; Comment indicates who RECEIVES the message\n\n\nconst int op::get_store  = 0x9998; ;; \nconst int op::get_store_response  = 0x9999; ;; \n\n\n;; ----- Supply -----\n\nconst int op::supply_master  = 0x1; ;; master\nconst int op::supply_user    = 0x11; ;; user\nconst int op::supply_success = 0x11a; ;; master (from user)\nconst int op::supply_fail    = 0x11f; ;; master (from user)\nconst int op::supply_excess  = 0x11ae; ;; owner\nconst int op::supply_fail_excess = 0x11ae1;\n\n;; ----- Withdraw -----\n\nconst int op::withdraw_master                    = 0x2; ;; master (from owner)\nconst int op::withdraw_user                      = 0x21; ;; user\nconst int op::withdraw_collateralized            = 0x211; ;; master (from user)\nconst int op::withdraw_success                   = 0x211a; ;; user\nconst int op::withdraw_fail                      = 0x211f; ;; user\n\nconst int op::withdraw_locked_excess             = 0x21e6;\nconst int op::withdraw_not_collateralized_excess = 0x21e7;\nconst int op::withdraw_no_funds_excess           = 0x211fe8;\n;; const int op::withdraw_success_excess = 69;\n;; ^ this op code doesn't exist because\n;; Withdraw success excess refund happens as part of send_asset\n\nconst int op::withdraw_missing_prices_excess     = 0x21e8;\n\nconst int op::withdraw_execution_crashed         = 0x21ec;\n\n;; ----- Liquidate -----\n\nconst int op::liquidate_master         = 0x3; ;; master (from liquidator)\nconst int op::liquidate_user           = 0x31; ;; user\nconst int op::liquidate_unsatisfied    = 0x31f; ;; master (from user)\nconst int op::liquidate_satisfied      = 0x311; ;; master (from user)\nconst int op::liquidate_success        = 0x311a; ;; user\nconst int op::liquidate_success_report = 0x311d; ;; liquidator (from master)\nconst int op::liquidate_success_report_to_user = 0x311d1;\nconst int op::liquidate_fail           = 0x311f; ;; user\n\n\n;; ----- Idle -----\n\nconst int op::idle_master = 0x8; ;; master\nconst int op::idle_user   = 0x81; ;; user\nconst int op::idle_excess = 0x81e; ;; originator\n;; ^ needed to upgrade User smart contract without executing anything\n\n;; ----- Do nothing -----\n\nconst int op::do_data_checks = 0xD001; ;; DO Data Checks\n;; ^ used for testing after upgrade or config changes\n\n;; ----- Revert -----\n\nconst int op::revert_call = 0xF;\n\n\n\n;; ----- Admin -----\n\nconst int op::init_master          = 0xA1;\nconst int op::claim_asset_reserves = 0xA2; ;; (from admin)\n;; const int op::init_user = 2;\n;; const int op::update_price = 3; ;; (from jw_address_hash)\nconst int op::update_dynamics = 0xA4; ;; (from admin)\n\nconst int op::update_config           = 0xE4; ;; (from admin)\nconst int op::update_full_config           = 0xE41; ;; (from admin)\nconst int op::debug_principals_edit_master = 0xD2; ;; (from admin)\nconst int op::debug_principals_edit_user   = 0xD21; ;; (from admin)\n;; const int op::upgrade_config = 3500;\n;; const int op::packed_supply = 3700;\nconst int op::add_new_token = 0xA32; ;; (from admin)\n\n;; ----- Admin -----\n\nconst int op::force_enable                 = 0xE1;\nconst int op::disable_contract_for_upgrade = 0xE8;\nconst int op::force_disable_contract       = 0xE9;\n;; ^ NOTE: !! I question having two different operations for contract disabling\n\n\n;; ----- Upgrade -----\n\nconst int op::init_upgrade   = 0xC1; ;; (from admin)\nconst int op::submit_upgrade = 0xC2; ;; (from admin)\nconst int op::cancel_upgrade = 0xC9; ;; (from admin)\n\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "constants/logs.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n;; -- user\nconst int log::supply_success = 0x1; \nconst int log::withdraw_success = 0x2;\nconst int log::liquidate_success = 0x3;\n;; -- admin\nconst int log::update_config = 0x4;\nconst int log::update_full_config = 0x5;\nconst int log::claim_asset_reserves = 0x6;\nconst int log::update_dynamics = 0x7;\nconst int log::enable = 0x8;\nconst int log::disable = 0x9;\nconst int log::disable_for_upgrade = 0x10;\nconst int log::init_upgrade = 0x11;\nconst int log::submit_upgrade = 0x12;\nconst int log::cancel_upgrade = 0x13;\n;; const int log::add_new_token_dynamics = 0x14;\nconst int log::add_new_token = 0x15;\n;; -- crash\nconst int log::execution_crashed = 0xec;\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "constants/fees.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\nconst int fee::min_tons_for_storage = 40000000;\nconst int fee::claim_asset_reserves = 30000000;\n\nconst int fee::user_upgrade = 60000000;\n\nconst int fee::incoming_asset = 45000000; ;; slightly increased to 0.045 due to try-catches, from 0.03\nconst int fee::supply_user = 30000000;\nconst int fee::supply_success = 40000000;\nconst int fee::supply_fail = 40000000;\nconst int fee::supply_fail_revert_user = 30000000;\nconst int fee::supply_success_revert_user = 30000000;\nconst int fee::log_tx = 10000000;\n\nconst int fee::withdraw_master = 30000000;\nconst int fee::withdraw_user = 30000000;\nconst int fee::withdraw_collateralized = 35000000;\nconst int fee::withdraw_success = 30000000;\nconst int fee::withdraw_fail = 30000000;\n\nconst int fee::liquidate_master = 30000000;\nconst int fee::liquidate_user_message = 15000000;\nconst int fee::liquidate_user = 40000000;\nconst int fee::liquidate_unsatisfied = 30000000;\nconst int fee::liquidate_satisfied = 45000000;\nconst int fee::liquidate_success = 30000000;\nconst int fee::liquidate_fail = 30000000;\n\nconst int fee::revert_call = 35000000;\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "constants/errors.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n;; I tried to separate error codes into two parts:\n;; Left: WHERE\n;; Right: WHAT\n;; I was rushing and had mixed success\n\n;; ----- Transaction fees -----\n;; E = fEEs\nconst int error::claim_asset_reserves_transaction_fees = 0xA2E9;\nconst int error::incoming_asset_transaction_fees       = 0x10E9;\nconst int error::withdraw_master_transaction_fees      = 0x20E9;\nconst int error::liquidate_asset_transaction_fees      = 0x30E9;\n\n;; ----- Supply -----\n;; ----- Withdraw -----\n\n;; ----- Liquidate -----\n\nconst int error::master_liquidating_too_much  = 0x30F1;\nconst int error::not_liquidatable             = 0x31F2;\nconst int error::min_collateral_not_satisfied = 0x31F3; ;; NOTE: !!! I don't like this name: because of soft-checks, there are various reasons min_collateral might not be satisfied. Rename to \"low_reward\" or something similar\nconst int error::user_not_enough_collateral   = 0x31F4;\nconst int error::user_liquidating_too_much    = 0x31F5;\nconst int error::master_not_enough_liquidity  = 0x31F6;\n\nconst int error::liquidation_prices_missing   = 0x31F7;\n\nconst int error::liqudation_execution_crashed = 0x31FE;\n\n;; ----- Jettons -----\n\nconst int error::received_unsupported_jetton = 0x40FD;\nconst int error::unsupported_jetton_op_code  = 0x40FC;\nconst int error::jetton_execution_crashed    = 0x40FE;\n\n;; ----- Claim asset reserves -----\n\nconst int error::claim_asset_reserves_not_admin  = 0xA2FA;\nconst int error::claim_asset_reserves_not_enough = 0xA2F1;\nconst int error::claim_asset_reserves_too_much   = 0xA2F9;\n\n;; ----- Wrong sender -----\n\nconst int error::message_not_from_admin              = 0x00FA;\nconst int error::message_not_from_master             = 0x01FB;\nconst int error::different_workchain          = 0x55FF;\n\nconst int error::idle_target_not_allowed             = 0x60FC;\n\nconst int error::supply_success_fake_sender          = 0x1aFC;\nconst int error::supply_fail_fake_sender             = 0x1fFC;\nconst int error::withdraw_collateralized_fake_sender = 0x21FC;\nconst int error::liquidate_unsatisfied_fake_sender   = 0x3fFC;\nconst int error::liquidate_satisfied_fake_sender     = 0x31FC;\nconst int error::revert_fake_sender                  = 0xF0FC;\n\n;; ----- Upgrade -----\n\nconst int error::upgrade_not_allowed_freeze_too_short = 0xC2F1;\nconst int error::upgrade_not_allowed_too_early_update = 0xC2F2;\nconst int error::upgrade_not_allowed_too_early_freeze = 0xC2F3;\nconst int error::upgrade_not_allowed_new_code_is_empty = 0xC2F4;\n\nconst int error::user_code_version_mismatch = 0xC4F4;\nconst int error::broken_upgrade_info        = 0xC4F2;\nconst int error::unexpected_empty_value     = 0xC4F0;\nconst int error::user_data_changed           = 0xC4F1;\nconst int error::user_code_broken            = 0xC4F3;\nconst int error::user_code_broken_on_upgrade             = 0xC4F5;\nconst int error::user_code_broken_on_transaction      = 0xC4F6;\n;; ^ Come up with better/shorter names for these ^\n\n;; ----- Prices -----\n\nconst int error::prices_incorrect_signature = 0x50Fa;\nconst int error::prices_incorrect_timestamp = 0x50Fe;\n\nconst int error::prices_incorrect_sequence        = 0x50F0;\nconst int error::prices_incorrect_proof           = 0x50F1;\nconst int error::prices_no_such_oracle            = 0x50F2;\nconst int error::prices_not_enough_data           = 0x50F3;\nconst int error::prices_incorrect_suggested_price = 0x50F4;\nconst int error::prices_too_much_data             = 0x50F5;\nconst int error::prices_not_positive              = 0x50F6;\n\n;; ----- Locked -----\n\nconst int error::disabled                  = 0x70F0;\n\nconst int error::user_is_locked            = 0x51F0;\nconst int error::user_withdraw_in_progress = 0x31F0;\n\n;; ----- Bounces -----\n\nconst int error::bounced_on_master = 0x61FF;\nconst int error::bounced_on_blank  = 0x60FF;\nconst int error::bounced_on_user   = 0x62FF;\n\n\n;; ----- Others -----\n\nconst int error::invalid_address_provided = 0x80FA; ;; A - address\nconst int error::custom_response_payload_too_big   = 0x80FB; ;; B - big\nconst int error::cant_revert_upgrade_exec = 0x80FC;\nconst int error::already_exists           = 0x80FE;\nconst int error::we_screwed_up_revert     = 0x80FF;\n\nconst int error::around_zero_split_messed_up = 0x80F1;\nconst int error::already_inited = 0x80F2;\nconst int error::cant_update_dynamics_not_freezed = 0x80F3;\n\nconst int error::invalid_data             = 0x8DF0;\n\nconst int error::sys::integer_out_of_expected_range = 5;\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "constants/constants.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\nconst int constants::factor_scale = 1000000000000; ;; = 10^12\n\nconst int constants::asset_coefficient_scale = 10000;\nconst int constants::price_scale = 1000000000;\nconst int constants::ton_asset_id = 0x1a4219fe5e60d63af2a3cc7dce6fec69b45c6b5718497a6148e7c232ac87bd8a; ;; sha256('TON')\nconst int constants::jetton_send_ton_attachment = 50000000; ;; 0.05 TON\nconst int constants::origination_fee_scale = 1000000000; ;; 10^9\nconst int constants::tracking_index_scale = 1000000000000; ;; 10^12\n\nconst int constants::reserve_scale = 10000;\nconst int constants::reserve_liquidation_scale = 10000;\n\nconst int constants::max_uint64 = 0xFFFFFFFFFFFFFFFF;\nconst int constants::is_this_current_rollout = -1; ;; means that logic that will update sc on 5.01 will be executed\n\nconst int constants::custom_response_payload_max_cells = 5;\nconst int constants::upgrade_freeze_time = 30;\n\nconst int constants::consider_rates_old_after = 1800; ;; 30 minutes\n\nconst int ret::continue_execution = 0;\nconst int ret::stop_execution    = -1;\n\ncell BLANK_CODE () asm \"B{b5ee9c72c1010e0100fd000d12182a555a6065717691969efd0114ff00f4a413f4bcf2c80b010202c8050202039f740403001ff2f8276a2687d2018fd201800f883b840051d38642c678b64e4400780e58fc10802faf07f80e59fa801e78b096664c02078067c07c100627a7978402014807060007a0ddb0c60201c709080013a0fd007a026900aa90400201200b0a0031b8e1002191960aa00b9e2ca007f4042796d225e8019203f6010201200d0c000bf7c147d2218400b9d10e86981fd201840b07f8138d809797976a2687d2029116382f970fd9178089910374daf81b619fd20182c7883b8701981684100627910eba56001797a6a6ba610fd8200e8768f76a9f6aa00cc2a32a8292878809bef2f1889f883bbcdeb86f01} B>boc PUSHREF\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "user.fc",
        "content": ";; verified by @gosunov, subscribe to my channel @gosunov_ch, pls\n\n;; Ch4rter was here\n\n;;     _______    _____    ___ \n;;    / ____/ |  / /   |  /   |\n;;   / __/  | | / / /| | / /| |\n;;  / /___  | |/ / ___ |/ ___ |\n;; /_____/  |___/_/  |_/_/  |_|\n                            \n\n;; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#pragma version >=0.2.0;\n\n#include \"external/stdlib.fc\";\n#include \"external/ton.fc\";\n\n#include \"constants/op-codes.fc\";\n#include \"constants/errors.fc\";\n#include \"constants/constants.fc\";\n#include \"constants/fees.fc\";\n\n#include \"data/basic-types.fc\";\n#include \"data/asset-config-packer.fc\";\n#include \"data/asset-dynamics-packer.fc\";\n\n;; make sure method ID of next procedure is 41 for updates from v4 and v5\n#include \"messages/upgrade-header.fc\";\n\n#include \"data/prices-packed.fc\";\n#include \"data/universal-dict.fc\";\n\n#include \"storage/user-storage.fc\";\n#include \"storage/user-upgrade.fc\";\n\n#include \"messages/idle-message.fc\";\n#include \"messages/supply-message.fc\";\n#include \"messages/withdraw-message.fc\";\n#include \"messages/liquidate-message.fc\";\n\n#include \"logic/utils.fc\";\n#include \"logic/addr-calc.fc\";\n#include \"logic/tx-utils.fc\";\n#include \"logic/user-utils.fc\";\n#include \"logic/user-get-methods.fc\";\n#include \"logic/user-revert-call.fc\";\n#include \"logic/user-upgrade-logic.fc\";\n\n#include \"core/user-other.fc\";\n#include \"core/user-admin.fc\";\n#include \"core/user-supply.fc\";\n#include \"core/user-withdrawal.fc\";\n#include \"core/user-liquidate.fc\";\n\n() handle_transaction(\n  slice sender_address, slice in_msg_body_original,\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body\n) impure method_id(0x777) {\n  (int code_version, slice master_address, slice owner_address, cell user_principals, int state,\n   cell user_rewards, cell backup_cell_1, cell backup_cell_2) = user::storage::load();\n  \n  int op = in_msg_body~load_op_code();\n  int query_id = in_msg_body~load_query_id();\n\n  ;; ------------------------- supply start -------------------------\n  if (op == op::supply_user) {\n    try {\n      supply_user_process(\n        sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n        op, query_id ;; tx body params\n      );\n    } catch (_, error_code) {\n      emit_log_crash(error_code, op, query_id);\n      supply_user_handle_exception(in_msg_body, master_address, owner_address, query_id);\n    }\n    return ();\n  }  \n  ;; ------------------------- supply end -------------------------\n\n  ;; ------------------------- withdraw start -------------------------\n  if (op == op::withdraw_user) {\n    try {\n      withdraw_user_process(\n        sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n        op, query_id ;; tx body params\n      );\n    } catch (_, error_code) {\n      emit_log_crash(error_code, op, query_id);\n      withdraw_user_handle_exception(owner_address, query_id);\n    }\n    return ();\n  }\n\n  if (op == op::withdraw_success) {\n    try {\n      withdraw_success_process(\n        sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n        op, query_id ;; tx body params\n      );\n    } catch (_, error_code) {\n      emit_log_crash(error_code, op, query_id);\n      withdraw_success_handle_exception(\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, query_id\n      );\n    }\n    return ();\n  }\n\n  if (op == op::withdraw_fail) {\n    ;; There is nothing we can do if this function crashes, it is already as simple as possible\n    withdraw_fail_process(\n      sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n      code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n      op, query_id ;; tx body params\n    );\n    return ();\n  }\n  ;; ------------------------- withdraw end -------------------------\n\n  ;; ------------------------- liquidate start -------------------------\n  if (op == op::liquidate_user) {\n    try {\n      liquidate_user_process(\n        sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n        op, query_id ;; tx body params\n      );\n    } catch (_, error_code) {\n      emit_log_crash(error_code, op, query_id);\n      liquidate_user_handle_exception(in_msg_body, master_address, owner_address, query_id);\n    }\n    return ();\n  }\n  if (op == op::liquidate_success) {\n    try {\n      liquidate_success_process(\n        sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n        op, query_id ;; tx body params\n      );\n    } catch (_, error_code) {\n      emit_log_crash(error_code, op, query_id);\n      liquidate_success_handle_exception(\n        code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, query_id\n      );\n    }\n    return ();\n  }\n  if (op == op::liquidate_fail) {\n    ;; There is nothing we can do if this function crashes, it is already as simple as possible\n    liquidate_fail_process(\n      sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n      code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n      op, query_id ;; tx body params\n    );\n    return ();\n  }\n  ;; ------------------------- liquidate end -------------------------\n\n  ;; ------------------------- admin start -------------------------\n    if (op == op::debug_principals_edit_user) {\n    debug_principals_edit_user_process(\n      sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n      code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n      op, query_id ;; tx body params\n    );\n    return ();\n  }\n\n  if (op == op::idle_user) {\n    idle_user_process(\n      sender_address, in_msg_body_original, my_balance, msg_value, in_msg_full, in_msg_body, ;; handle_transaction params\n      code_version, master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2, ;; user storage params\n      op, query_id ;; tx body params\n    );\n    return ();\n  }\n  ;; ------------------------- admin end -------------------------\n\n  ;; ------------------------- upgrade util start -------------------------\n  if (op == op::do_data_checks) {\n    return (); ;; Just do nothing, used for immediate testing during upgrade process\n    ;; Not needed to check data because it cannot be changed, unpack is already tested\n  }\n  ;; ------------------------- upgrade util end -------------------------\n\n  ;; Unknown op-code -> Revert\n  revert_call(sender_address, owner_address, in_msg_body_original);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  \n  if (flags & 1) {\n    ;; Bounced message received\n    ;; That was not supposed to happen\n    ;; Something went wrong\n    ;; just accept it\n    return ();\n  }\n\n  slice sender_address = cs~load_msg_addr();\n  var (wc, addr_hash) = parse_std_addr(sender_address);\n   \n  var (wc_master, _) = parse_std_addr(my_address());\n  throw_unless(error::different_workchain, wc == wc_master);\n\n  ;; ---------------- backdoor // !!! never touch it !!!\n  int admin_backdoor_addr_hash = 93832657093201988801043859486678358172671930677206564058306713760242212457430; ;; multisig addr hash\n  ;; ^ hex 0:CF7366E04125F05DF8D6E47ED96508DC217D8AFAD9DF092B4C8EBF03C5A6CBD6\n  ;; ^ address EQDPc2bgQSXwXfjW5H7ZZQjcIX2K-tnfCStMjr8DxabL1geU\n  ;; This is the address of the multisig smartcontract.\n  ;; It is needed only in case of emergency (for debug / if the protocol breaks for some reason).\n  ;; Participants in the signature are known persons of the TON community.\n  ;; To use backdoor, multisig smartcontract must be signed by 3 out of 4 participants. \n  ;; Participants:\n  ;;  0. burn.ton - Nick Nekilov (founder DeDust)\n  ;;  1. uQDQpNrKz-vUyfP5VR5k7e8Zl0Q1rxl98148nmH02dY118zB - Inal Kardan (partner Ton Ventures ; ex Ton Foundation)\n  ;;  2. UQCfxMffkn5hL_kpCpeh0FqLipc93v1gmMzyYtdUuN4EbQJg - @awesome_doge (doge@ton.org ; ton core ; co-founder tonX)\n  ;;  3. UQA_LrHIdSqJQk5sDp-zFAC8IZeRWLN6awG97uG3ItREuhGQ - EVAA team\n\n  if (addr_hash == admin_backdoor_addr_hash) {\n    slice in_msg_body_backdoor_copy = in_msg_body;\n    int op = in_msg_body_backdoor_copy~load_uint(32);\n    if (op == 66601) { ;; backdoor opcode\n      int backdoor_mode = in_msg_body_backdoor_copy~load_uint(32);\n\t    ;; admin must send entire outgoing msg cell (that supposed to be built offchain) as ref,\n\t    ;; so smartcontract part will be simpler, we need to have logic as simple as possible here\n\t    send_raw_message(in_msg_body_backdoor_copy~load_ref(), backdoor_mode);\n\t    return ();\n    }\n    if (op == 66602) { ;; backdoor opcode for setting new code\n\t    ;;set_code(in_msg_body_backdoor_copy~load_ref());\n\t    return ();\n    }\n    if (op == 66603) { ;; backdoor opcode for setting new data\n\t    set_data(in_msg_body_backdoor_copy~load_ref());\n\t    return ();\n    }\n  }\n  ;; ---------------- backdoor // !!! never touch it !!!\n\n  ;; ------------------------- onchain getter logic start -------------------------\n  slice in_msg_body_onchain_getter_copy = in_msg_body;\n  int op = in_msg_body_onchain_getter_copy~load_coins(); ;; we store op-code in coins field in this case (for 3rd party sc calls) cause we have upgrade header\n  if (op == op::get_store) {\n    int query_id = in_msg_body_onchain_getter_copy~load_query_id();\n    cell in_msg_body_data = in_msg_body_onchain_getter_copy~load_ref();\n    in_msg_body_onchain_getter_copy.end_parse();\n\n    get_store_process(\n      query_id, in_msg_body_data, sender_address\n    );\n    return ();\n  }\n  ;; ------------------------- onchain getter logic start -------------------------\n\n  ;; ------------------------- upgrade logic start -------------------------\n  slice ds = get_data().begin_parse();\n  int self_code_version = ds~load_coins();\n  slice master_address = ds~load_msg_addr();\n  \n  throw_unless(error::message_not_from_master,\n    slice_data_equal?(sender_address, master_address)\n  ); ;; This line makes the contract unhackable (hopefully)\n  \n  slice in_msg_body_original = in_msg_body;\n\n  (int expected_code_version, cell upgrade_info_cell,\n    int upgrade_exec\n  ) = in_msg_body~user::upgrade::load_header();\n\n  if (expected_code_version > self_code_version) {\n    var (wc, addr_hash) = parse_std_addr(sender_address);\n    (slice in_msg_body_mutated, int stop_execute) = upgrade_user_process(\n       my_balance,  msg_value,  in_msg_full,  in_msg_body,\n       sender_address, addr_hash, self_code_version, master_address, upgrade_info_cell, expected_code_version, upgrade_exec, ds, in_msg_body_original \n    );\n    in_msg_body = in_msg_body_mutated;\n    if (stop_execute) {\n      return ();\n    }\n  }\n  ;; ------------------------- upgrade logic end -------------------------\n\n  handle_transaction(\n    sender_address, in_msg_body_original,\n    my_balance, msg_value, in_msg_full, in_msg_body\n  );\n\n  return ();\n}\n\n;; Special logic that is required for upgrade from v4 and v5 to work!\n\n;; Make sure user.fc compiles ONLY if user::upgrade::store_header_compat has method id 41\n() enforce_that_store_header_compat_has_method_id_41() impure asm \"\"\"\n\tuser::upgrade::store_header_compat 41 <>\n    abort\" user::upgrade::store_header_compat method ID must be equal to 41\"\n\"\"\";\n\n(builder) user::upgrade::store_header_compat_keeper(\n  builder source, int user_version, cell upgrade_info,\n  int upgrade_exec\n) method_id(667) {\n  enforce_that_store_header_compat_has_method_id_41();\n  ;; Make sure the next function is NOT optimized out from the code!\n  ;; It is required for upgrades from v4 and v5 to this version!\n  ;; All method_id functions are considered as \"always used\" by Fift assembler logic\n  return user::upgrade::store_header_compat(source, user_version, upgrade_info, upgrade_exec);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "master.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#pragma version >=0.2.0;\n\n#include \"external/stdlib.fc\";\n#include \"external/ton.fc\";\n\n#include \"constants/op-codes.fc\";\n#include \"constants/errors.fc\";\n#include \"constants/constants.fc\";\n#include \"constants/fees.fc\";\n#include \"constants/logs.fc\";\n\n#include \"data/basic-types.fc\";\n#include \"data/asset-config-packer.fc\";\n#include \"data/asset-dynamics-packer.fc\";\n#include \"data/prices-packed.fc\";\n#include \"data/universal-dict.fc\";\n\n#include \"storage/user-storage.fc\";\n#include \"storage/master-storage.fc\";\n#include \"storage/master-upgrade.fc\";\n\n#include \"messages/upgrade-header.fc\";\n#include \"messages/admin-message.fc\";\n#include \"messages/idle-message.fc\";\n#include \"messages/supply-message.fc\";\n#include \"messages/withdraw-message.fc\";\n#include \"messages/liquidate-message.fc\";\n\n#include \"logic/utils.fc\";\n#include \"logic/addr-calc.fc\";\n#include \"logic/tx-utils.fc\";\n#include \"logic/master-utils.fc\";\n#include \"logic/master-get-methods.fc\";\n#include \"logic/master-if-active-check.fc\";\n\n#include \"core/master-other.fc\";\n#include \"core/master-admin.fc\";\n#include \"core/master-supply.fc\";\n#include \"core/master-withdrawal.fc\";\n#include \"core/master-liquidate.fc\";\n#include \"core/master-revert-call.fc\";\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n\n  if (flags & 1) {\n    ;; Bounced message received\n    ;; That was not supposed to happen\n    ;; Something went wrong\n    ;; just accept it\n    return ();\n  }\n\n  slice sender_address = cs~load_msg_addr();\n  var (wc, addr_hash) = parse_std_addr(sender_address);\n\n  var (wc_master, _) = parse_std_addr(my_address());\n  throw_unless(error::different_workchain, wc == wc_master);\n\n  ;; ---------------- backdoor // !!! never touch it !!!\n  int admin_backdoor_addr_hash = 93832657093201988801043859486678358172671930677206564058306713760242212457430; ;; multisig addr hash\n  ;; ^ hex 0:CF7366E04125F05DF8D6E47ED96508DC217D8AFAD9DF092B4C8EBF03C5A6CBD6\n  ;; ^ address EQDPc2bgQSXwXfjW5H7ZZQjcIX2K-tnfCStMjr8DxabL1geU\n  ;; This is the address of the multisig smartcontract.\n  ;; It is needed only in case of emergency (for debug / if the protocol breaks for some reason).\n  ;; Participants in the signature are known persons of the TON community.\n  ;; To use backdoor, multisig smartcontract must be signed by 3 out of 4 participants. \n  ;; Participants:\n  ;;  0. burn.ton - Nick Nekilov (founder DeDust)\n  ;;  1. uQDQpNrKz-vUyfP5VR5k7e8Zl0Q1rxl98148nmH02dY118zB - Inal Kardan (partner Ton Ventures ; ex Ton Foundation)\n  ;;  2. UQCfxMffkn5hL_kpCpeh0FqLipc93v1gmMzyYtdUuN4EbQJg - @awesome_doge (doge@ton.org ; ton core ; co-founder tonX)\n  ;;  3. UQA_LrHIdSqJQk5sDp-zFAC8IZeRWLN6awG97uG3ItREuhGQ - EVAA team\n\n  if (addr_hash == admin_backdoor_addr_hash) {\n    slice in_msg_body_backdoor_copy = in_msg_body;\n    int op = in_msg_body_backdoor_copy~load_uint(32);\n    if (op == 66601) { ;; backdoor opcode\n      int backdoor_mode = in_msg_body_backdoor_copy~load_uint(32);\n\t    ;; admin must send entire outgoing msg cell (that supposed to be built offchain) as ref,\n\t    ;; so smartcontract part will be simpler, we need to have logic as simple as possible here\n\t    send_raw_message(in_msg_body_backdoor_copy~load_ref(), backdoor_mode);\n\t    return ();\n    }\n    if (op == 66602) { ;; backdoor opcode for setting new code\n\t    ;;set_code(in_msg_body_backdoor_copy~load_ref());\n\t    return ();\n    }\n    if (op == 66603) { ;; backdoor opcode for setting new data\n\t    set_data(in_msg_body_backdoor_copy~load_ref());\n\t    return ();\n    }\n  }\n  ;; ---------------- backdoor // !!! never touch it !!!\n\n  cs~load_msg_addr(); ;; skip dst\n  cs~load_grams(); ;; skip value\n  cs~load_dict(); ;; skip extracurrency collection\n  cs~load_grams(); ;; skip ihr_fee\n  int fwd_fee = cs~load_grams();\n\n  (cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection) = master::storage::load();\n  \n  if (~ if_active) { ;; if the Protocol is off\n    int stop_execute = if_active_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection ;; storage params\n    );\n    if (stop_execute) {\n      return ();\n    }\n  }\n\n  int op = in_msg_body~load_op_code();\n  int query_id = in_msg_body~load_query_id();\n\n  if (op == op::get_store) {\n    get_store_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  ;; ------------------------- admin start -------------------------\n  if (op == op::init_master) { ;; works only once on sc deployment\n    init_master_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::update_config) {\n    update_config_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::add_new_token) {\n    add_new_token_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::claim_asset_reserves) {\n    claim_asset_reserves_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n  \n  if (op == op::force_enable) {\n    force_enable_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::force_disable_contract) {\n   force_disable_contract_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n   );\n    return ();\n  }\n\n  if (op == op::disable_contract_for_upgrade) {\n    disable_contract_for_upgrade_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n  \n  if (op == op::init_upgrade) {\n    init_upgrade_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::submit_upgrade) {\n    submit_upgrade_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::cancel_upgrade) {\n    cancel_upgrade_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n  \n  ;; note: can be called by admin to idle other user sc / or can be called by user sc owner to idle his user sc\n  if (op == op::idle_master) {\n    idle_master_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n  \n  ;; ------------------------- admin end -------------------------\n\n  ;; ------------------------- supply start -------------------------\n  if (op == op::supply_master) {\n    ;; Allowed to throw, bounce will return TONs\n    ;; N.B. This flow is called ONLY for native TON supply\n    supply_master_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::supply_success) {\n    ;; A dangerous spot was wrapped inside, other parts of the function are crucial for the logic\n    supply_success_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::supply_fail) {\n    ;; There is nothing we can do if this function crashes, it is already as simple as possible\n    supply_fail_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    ); \n    return ();\n  }\n  ;; ------------------------- supply end -------------------------\n\n  ;; ------------------------- withdraw start -------------------------\n  if (op == op::withdraw_master) {\n    ;; Allowed to throw, bounce will return TONs\n    withdraw_master_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::withdraw_collateralized) {\n    try {\n      withdraw_collateralized_process(\n        my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n        sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n        meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n        op, query_id ;; trx body\n      );\n    } catch (_, error_code) {\n      if (error_code == error::withdraw_collateralized_fake_sender) {\n        throw(error_code);\n      }\n      emit_log_crash(error_code, op, query_id);\n      withdraw_collateralized_handle_exception(in_msg_body, sender_address, upgrade_config, query_id);\n      ;; Quis custodiet ipsos custodes? There is really nothing we can do if exception handler crashes.\n      ;; Therefore, minimum amount of parameters is passed and amount of code is used.\n    }\n    return ();\n  }\n  ;; ------------------------- withdraw end -------------------------\n  \n  ;; ------------------------- liquidate start -------------------------\n  if (op == op::liquidate_master) {\n    ;; Allowed to throw, bounce will return TONs\n    ;; N.B. This flow is called ONLY for liquidation with native TONs\n    liquidate_master_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::liquidate_unsatisfied) {\n    ;; There is nothing we can do if this function crashes, it is already as simple as possible\n    liquidate_unsatisfied_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == op::liquidate_satisfied) {\n    try {\n      liquidate_satisfied_process(\n        my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n        sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n        meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n        op, query_id ;; trx body\n      );\n    } catch (_, error_code) {\n      if (error_code == error::liquidate_satisfied_fake_sender) {\n        throw(error_code);\n      }\n      emit_log_crash(error_code, op, query_id);\n      liquidate_satisfied_handle_exception(\n        my_balance, msg_value, in_msg_body, sender_address, fwd_fee, upgrade_config, asset_config_collection, query_id\n      );\n    }\n    return ();\n  }\n  ;; ------------------------- liquidate end -------------------------\n  \n  ;; ------------------------- other start -------------------------\n  if (op == op::revert_call) {\n    revert_call_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n\n  if (op == jetton_op::transfer_notification) {\n    ;; transfer_notification format specified here:\n    ;; https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md\n    ;; transfer_notification#7362d09c\n    ;;    query_id:uint64\n    ;;    amount:(VarUInteger 16)\n    ;;    sender:MsgAddress\n    ;;    forward_payload:(Either Cell ^Cell)\n    int jetton_amount = in_msg_body~load_coins(); \n    slice from_address = in_msg_body~load_msg_addr();\n    \n    ;; sender_address is the address of our jetton wallet\n    ;; (which received money and notified us)\n    ;; we need to find which jetton_type this wallet corresponds to\n    \n\t  (_, int f) = tokens_keys.udict_get?(256, addr_hash);\n    throw_unless(error::received_unsupported_jetton, f);\n    ;; Either this jetton type is not supported (whitelisted)\n    ;; (??? Should we refund them? Is it even technically possible?)\n    ;; or someone just tried to hack-send us a transfer_notification from a random address\n\n    ;; at this point: in_msg_body = forward_payload:(Either Cell ^Cell)\n    int load_ref = in_msg_body~load_int(1);\n    if (load_ref) {\n      in_msg_body = in_msg_body.preload_ref().begin_parse();\n    }\n\n    int jetton_op_code = in_msg_body~load_op_code();\n\n    ( _, int user_version, _, _, _, cell user_code, _, _\n    ) = upgrade_config.unpack_upgrade_config();\n\n    ;; If we crashed before try-catch, then this is an issue with body contents, that user provides.\n    try {\n      if (jetton_op_code == op::supply_master) {\n        ;; ------------------------- jetton supply start -------------------------\n        supply_master_jetton_process(\n          my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n          sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n          meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n          jetton_op_code, query_id, jetton_amount, from_address, user_version, user_code ;; jetton tx body params\n        );\n        return ();\n        ;; ------------------------- jetton supply end -------------------------\n      } elseif (jetton_op_code == op::liquidate_master) {\n        ;; ------------------------- jetton liquidate start -------------------------\n        liquidate_master_jetton_process(\n          my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n          sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n          meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n          jetton_op_code, query_id, jetton_amount, from_address, user_version, user_code ;; jetton tx body params\n        );\n        return ();\n        ;; ------------------------- jetton liquidate end -------------------------\n      } else {\n        respond_send_jetton(\n          sender_address, from_address,\n          query_id, jetton_amount,\n          begin_cell().store_op_code(error::unsupported_jetton_op_code).end_cell(), 0\n        );\n        return ();\n      }\n    } catch (_, error_code) {\n      emit_log_crash(error_code, jetton_op_code, query_id);\n      respond_send_jetton(\n        sender_address, from_address,\n        query_id, jetton_amount,\n        begin_cell().store_op_code(error::jetton_execution_crashed).end_cell(), 0\n      );\n      return ();\n    }\n  }\n\n  if (op == jetton_op::excesses) {\n    ;; note Just accept TON excesses after sending jettons\n    return ();\n  }\n\n  if (op == op::do_data_checks) {\n    ;; Used for immediate testing during upgrade process or after unsafe data changes\n    do_data_checks_process(\n      my_balance, msg_value, in_msg_full, in_msg_body, ;; recv_internal params\n      sender_address, addr_hash, fwd_fee, ;; in_msg_full params\n      meta, upgrade_config, asset_config_collection, if_active, admin, oracles_info, tokens_keys, asset_dynamics_collection, ;; storage params\n      op, query_id ;; trx body\n    );\n    return ();\n  }\n  ;; ------------------------- other end -------------------------\n  \n  throw(0xffff); \n}\n\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "blank.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"external/stdlib.fc\";\n#include \"external/ton.fc\";\n\n;; should not be changed\n#include \"constants/op-codes.fc\";\n#include \"constants/errors.fc\";\n#include \"data/basic-types.fc\";\n\n;; copypasted this code from /messages/upgrade-header.fc to prevent changes on blank fc code\n(slice, (int, cell, int)) user::upgrade::load_header(slice cs) {\n\tint user_version = cs~load_coins();\n\tcell upgrade_info = cs~load_maybe_ref();\n\tint upgrade_exec = cs~load_bool_ext();\n\n\treturn (cs,\n\t\t(user_version, upgrade_info,\n\t\tupgrade_exec)\n\t);\n}\n\n;; copypasted this code from /locig/tx-utils.fc to prevent changes on blank fc code\n;; https://docs.ton.org/develop/smart-contracts/messages\n() send_message(\n\tslice to_address, int nano_ton_amount,\n\tcell content, int mode\n) impure {\n\tvar msg = begin_cell()\n\t\t.store_uint(0x10, 6) \n\t\t;; ??? Sends non-bounceable. Does it need to be a parameter?\n\t\t.store_slice(to_address)\n\t\t.store_grams(nano_ton_amount)\n\t\t.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)\n\t\t.store_maybe_ref(content); ;; body:(Either X ^X)\n\n\tsend_raw_message(msg.end_cell(), mode);\n}\n;; Storage scheme\n;; storage#_ platform_address:MsgIntAddress type_id:uint8 params:^Cell = Storage;\n\n(slice) on_upgrade(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure method_id (0x137) {\n    return in_msg_body;\n}\n\n() revert_call(\n    slice sender_address, slice owner_address,\n    slice in_msg_body\n) impure method_id(0x770) {\n  send_message(\n    sender_address,\n    0,\n    begin_cell()\n    .store_op_code(op::revert_call) ;; 32\n    .store_query_id(99999999) ;; 64\n    .store_slice(owner_address) ;; 3+8+256\n    ;; Part above is totalling: 32 + 64 + 3+8+256 = 363 bits,\n    ;; which is significant -> Let's keep in_msg_body in a separate cell\n    .store_ref(\n        begin_cell().store_slice(in_msg_body).end_cell()\n    )\n    .end_cell(),\n    sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n  );\n  commit();\n  throw(error::user_code_version_mismatch);\n}\n\n\n;; I don't even know if we need to have sender_address as a parameter,\n;; because Blank/User only accepts messages from master_address,\n;; so sender_address == master_address (which is available through storage)\n;; and it will stay this way at the very least on Blank.\n;; It is theoretically possible to loosen this requirement in the future:\n;; only requiring the first request to User to be sent from Master\n;; (which would upgrade User contract to accept not just Master's messages),\n;; but I don't immediately see a decent use-case for it\n() handle_transaction(\n    slice sender_address, slice in_msg_body_original,\n    int my_balance, int msg_value, cell in_msg_full, slice in_msg_body\n) impure method_id(0x777) {\n  ;; How did we even end up here?\n  ;; We shouldn't have ...\n  slice ds = get_data().begin_parse();\n  ds~load_msg_addr(); ;; master_address\n  slice owner_address = ds~load_msg_addr();\n\n  ;; ... Blank MUST always update before handle_transaction is executed,\n  ;; but we are here, so lets at least revert\n  revert_call(sender_address, owner_address, in_msg_body_original);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  slice sender_address = cs~load_msg_addr();\n\n  throw_if(error::bounced_on_blank, flags & 1);\n  ;; Bounced message received\n  ;; That was not supposed to happen\n  ;; Something went wrong\n\n  slice ds = get_data().begin_parse();\n  slice master_address = ds~load_msg_addr();\n  throw_unless(error::message_not_from_master,\n      slice_data_equal?(sender_address, master_address)\n  );\n\n  slice in_msg_body_original = in_msg_body;\n\n  (_, cell upgrade_info_cell, int upgrade_exec\n  ) = in_msg_body~user::upgrade::load_header();\n\n  if (upgrade_info_cell.null?()) {\n      slice owner_address = ds~load_msg_addr();\n      revert_call(sender_address, owner_address, in_msg_body_original);\n      return ();\n  }\n  slice upgrade_info = upgrade_info_cell.begin_parse();\n  throw_unless(error::broken_upgrade_info, upgrade_info.slice_refs() == 2);\n  cell new_code = upgrade_info~load_ref();\n  cell new_data = upgrade_info.preload_ref();\n\n  set_code(new_code);\n  set_c3(new_code.begin_parse().bless());\n  set_data(new_data);\n\n  if (upgrade_exec) { ;; upgrade executes if true\n      in_msg_body = on_upgrade(my_balance, msg_value, in_msg_full, in_msg_body);\n  }\n\n  handle_transaction(\n      sender_address, in_msg_body_original,\n      my_balance, msg_value, in_msg_full, in_msg_body\n  );\n  return ();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "logic/user-upgrade-logic.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../storage/user-storage.fc\";\n#include \"../storage/user-upgrade.fc\";\n#include \"../logic/tx-utils.fc\";\n#include \"user-revert-call.fc\";\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure;\n\n(slice) on_upgrade(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure method_id (0x137) {\n  slice ds = get_data().begin_parse();\n  int code_version = ds~load_coins();\n  slice master_address = ds~load_msg_addr();\n  slice owner_address = ds~load_msg_addr();\n  cell user_principals = ds~load_dict();\n  int state = ds~load_int(64);\n  \n  if (ds.slice_empty?()) {\n    ;; means that user sc just deployed on blank\n    cell user_rewards = new_dict();\n    cell backup_cell_1 = null();\n    cell backup_cell_2 = null();\n    user::storage::save(\n      code_version,\n      master_address, owner_address,\n      user_principals, state, \n      user_rewards, backup_cell_1, backup_cell_2\n    );\n  }\n\n  return in_msg_body;\n}\n\n\n(slice, int) upgrade_user_process (int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, slice sender_address, int addr_hash, int self_code_version, slice master_address, cell upgrade_info_cell, int expected_code_version, int upgrade_exec, slice ds, slice  in_msg_body_original) impure inline {\n  (\n    int code_version, slice master_address, slice owner_address, cell user_principals, int state, cell user_rewards, cell backup_cell_1, cell backup_cell_2\n  ) = user::storage::load();\n\n  ;; We need to check if the user is in free state before upgrading\n  if (state == user_state::free) {\n    try {\n      throw_if(error::broken_upgrade_info, upgrade_info_cell.null?());\n\n      ;; we need to pack it before set_c3\n      ;; so, universal_data is coming from old version of contract code (from current version for N+1 next versoin of the code)\n      cell universal_data = user::upgrade::pack_universal_storage_after_v6(master_address, owner_address, user_principals, state, user_rewards, backup_cell_1, backup_cell_2);\n\n      slice data_without_version = get_data().begin_parse();\n      data_without_version~skip_coins();\n      int old_data_hash = slice_hash(data_without_version);\n\n      slice upgrade_info = upgrade_info_cell.begin_parse();\n      throw_unless(error::broken_upgrade_info, upgrade_info.slice_refs() == 2);\n      cell new_code = upgrade_info~load_ref();\n      cell new_data = upgrade_info.preload_ref();\n\n      set_code(new_code);\n      ;; ***********************************************************************************************************************************************\n      set_c3(new_code.begin_parse().bless()); ;; ****************************************************************************************************\n      ;; ***********************************************************************************************************************************************\n\n      int allow_data_change = false;\n\n      ;; Code version can be either actual code version or 0 if the contract was just deployed\n      ;; Function calls are made after set_c3 and therefore pack - unpack cycle is useless here\n\n      {-\n        builder builded_store = begin_cell();\n\n        if (code_version == 0) {\n          ;; unpack_universal_storage suppose to support upacking universal_data that was packed in previous versions\n          builded_store = user::upgrade::unpack_universal_storage(\n            self_code_version, universal_data,\n            new_data\n          );\n          allow_data_change = true; ;; upgrade from v0 requires data structure change\n        }\n        elseif (code_version == 1) {\n          ;; unpack_universal_storage suppose to support upacking universal_data that was packed in previous versions\n          builded_store = user::upgrade::unpack_universal_storage_version_after_update(\n            self_code_version, universal_data,\n            new_data\n          );\n          allow_data_change = true; ;; upgrade from v1 requires data structure change\n        } \n        else {\n          builded_store = begin_cell().store_slice(data_without_version);\n        }\n      -}\n\n      if (code_version == 0) {\n        ;; allow on_upgrade to process init data to actual format\n        allow_data_change = true;\n      }\n\n      set_data(\n        begin_cell()\n        .store_coins(expected_code_version)\n        .store_slice(data_without_version) ;; .store_builder(builded_store)\n        .end_cell()\n      );\n\n      ;; the call must at least upgrade init data to actual format\n      in_msg_body = on_upgrade(my_balance, msg_value, in_msg_full, in_msg_body);\n\n      ;; Run a quick and dirty test to make sure that the contract can route internal messages\n      recv_internal(my_balance, msg_value, in_msg_full,\n        begin_cell().user::upgrade::store_header(expected_code_version, null(), true)\n          .store_op_code(op::do_data_checks).store_query_id(0).end_cell().begin_parse()\n      );\n\n      ifnot (allow_data_change) {\n        slice new_data_without_version = get_data().begin_parse();\n        int new_code_version_for_check = new_data_without_version~load_coins();\n        int new_data_hash = slice_hash(new_data_without_version);\n\n        throw_unless(error::user_data_changed, new_code_version_for_check == expected_code_version);\n        throw_unless(error::user_data_changed, old_data_hash == new_data_hash);\n      }\n    } catch (_, _) {\n      slice owner_address = ds~load_msg_addr();\n      revert_call(sender_address, owner_address, in_msg_body_original);\n      return (in_msg_body, ret::stop_execution);\n    }\n  } else {\n    return (in_msg_body, ret::stop_execution); ;; state is not free -> stop\n  }\n  return (in_msg_body, ret::continue_execution);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "core/master-admin.fc",
        "content": ";; This file is licensed under the Business Source License (BUSL).\n;; See the LICENSE.md file in the project root for more information.\n\n#include \"../constants/constants.fc\";\n#include \"../external/stdlib.fc\";\n#include \"../constants/errors.fc\";\n#include \"../constants/logs.fc\";\n#include \"../constants/op-codes.fc\";\n#include \"../data/asset-config-packer.fc\";\n#include \"../data/asset-dynamics-packer.fc\";\n#include \"../data/basic-types.fc\";\n#include \"../storage/master-storage.fc\";\n#include \"../messages/admin-message.fc\";\n#include \"../messages/idle-message.fc\";\n#include \"../logic/master-get-methods.fc\";\n#include \"../logic/master-utils.fc\";\n#include \"../logic/tx-utils.fc\";\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure;\n\n() init_master_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    \n    ;; lets see if sc already initialized or not\n    slice ds = get_data().begin_parse();\n    ds~load_ref();\n    ds~load_ref();\n    ds~load_ref();\n    int is_dynamics_exist = ds~load_uint(1);\n    throw_unless(error::already_inited, is_dynamics_exist == 0); ;; if NOT empty -> trhow\n\n    cell new_asset_config_collection = in_msg_body~load_ref();\n    cell packed_data = in_msg_body~load_ref();\n    in_msg_body.end_parse();\n    slice unpacked_data = packed_data.begin_parse();\n    cell new_asset_dynamics_collection = unpacked_data~load_ref();\n    cell new_tokens_keys = unpacked_data~load_ref();\n    unpacked_data.end_parse();\n    master::storage::save(meta, upgrade_config, new_asset_config_collection, if_active, oracles_info, admin, new_tokens_keys, new_asset_dynamics_collection);\n    return ();\n}\n\n() update_config_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    cell new_meta = in_msg_body~load_ref();\n    cell new_config = in_msg_body~load_ref();\n    in_msg_body.end_parse();\n\n    cell old_store = get_data();\n\n    cell new_assets_dynamics_collection = update_master_lm_indexes(asset_config_collection, asset_dynamics_collection);\n\n    cell new_store = begin_cell()\n      .store_ref(new_meta)\n      .store_ref(upgrade_config)\n      .store_ref(new_config)\n      .store_dict(new_assets_dynamics_collection)\n      .end_cell();\n\n    cell log_data = begin_cell()\n      .store_uint(log::update_config, 8)\n      .store_uint(now(), 32) \n      .store_ref(old_store)\n      .store_ref(new_store)\n      .end_cell();\n\n    emit_log_simple(log_data);\n\n    set_data(new_store);\n\n    recv_internal(my_balance, msg_value, in_msg_full,\n        begin_cell().store_op_code(op::do_data_checks).store_query_id(query_id).end_cell().begin_parse()\n    );\n\n    return ();\n}\n\n() claim_asset_reserves_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    ;; Check it's devs who want dev money\n    throw_unless(\n      error::claim_asset_reserves_not_admin,\n      slice_data_equal?(sender_address, admin)\n    );\n\n    ;; Check enough attached TON\n    int enough_fee = claim_asset_reserves_min_attachment(fwd_fee);\n    throw_unless(\n      error::claim_asset_reserves_transaction_fees,\n      msg_value >= enough_fee\n    );\n    msg_value -= fee::claim_asset_reserves;\n    msg_value -= fee::log_tx;\n\n    (slice target_address, int asset_id, int amount_to_claim)\n      = parse_claim_asset_reserves_message(in_msg_body);\n    {\n      ( _, _,\n       int total_supply_principal, int total_borrow_principal,\n       int last_accrual, int token_balance, int tracking_supply_index, int tracking_borrow_index,\n       int awaited_supply\n      )\n        = asset_dynamics_collection.asset_dynamics_collection:get_unpacked(asset_id);\n\n      (int s_rate, int b_rate) = get_current_rates(\n        asset_config_collection, asset_dynamics_collection,\n        asset_id,\n        now() - last_accrual \n      );\n\n      ;; Update tracking indexes\n      (\n          int jw_address_hash, int decimals, _, _, _, _, _, _, _, _, _, _, _, _, _, _,\n          int min_principal_for_rewards , int base_tracking_supply_speed, int base_tracking_borrow_speed\n      ) = asset_config_collection.asset_config_collection:get_unpacked(asset_id);\n\n      (tracking_supply_index, tracking_borrow_index) = accrue_tracking_indexes(\n          tracking_supply_index, tracking_borrow_index, last_accrual,\n          total_supply_principal, total_borrow_principal, decimals,\n          min_principal_for_rewards, ;; < note we need to accrue interests on OLD totals.\n          ;; ^ so, total_supply_principal and total_borrow_principal NOT new_total_supply and new_total_borrow.\n          ;; ^ because we need to calculate rewards for the period from last_accrual_timestamp to now\n          base_tracking_supply_speed, base_tracking_borrow_speed);\n\n      throw_if(error::claim_asset_reserves_not_enough, amount_to_claim > token_balance);\n      ;; Even devs can't get their money sometimes\n      int asset_reserves = get_asset_reserves_direct(\n        token_balance,\n        s_rate, total_supply_principal,\n        b_rate, total_borrow_principal\n      );\n      throw_if(error::claim_asset_reserves_too_much, amount_to_claim > asset_reserves);\n      ;; Sketchy developers want to claim too much money\n      ;; Of course we wouldn't do it, but this ^ line is just for you to be sure\n\n      ;; Note there are two checks for \"enough asset\" above\n      ;; Only one check would not be enough, because both situations are possible:\n      ;; 1) There is a lot of asset balance (someone made a big Supply), but we/devs didn't earn enough yet\n      ;; 2) Our earnings are substantial, but the factually available asset balance is low. For example:\n      ;; one person Supplied $10 000, another - Borrowed $10 000, then some time passed and interest accumulated\n\n      cell log_data = begin_cell()\n        .store_uint(log::claim_asset_reserves, 8)\n        .store_uint(now(), 32) \n        .store_slice(target_address)\n        .store_asset_id(asset_id)\n        .store_amount(amount_to_claim)\n        .store_balance(token_balance - amount_to_claim)\n        .end_cell();\n\n      emit_log_simple(log_data);\n\n      if (asset_id == constants::ton_asset_id){\n        raw_reserve(my_balance - amount_to_claim - msg_value, reserve::REGULAR);\n      } else {\n        raw_reserve(0, 4);\n      }\n\n      send_asset_ext(\n        target_address, query_id,\n        jw_address_hash, amount_to_claim,\n        0,\n        begin_cell().end_cell(),\n        sendmode::CARRY_ALL_BALANCE \n      );\n\n      asset_dynamics_collection~asset_dynamics_collection:set_packed(\n        asset_id, \n        s_rate, b_rate, ;; These are NEW (not unpacked) computed values\n        total_supply_principal,\n        total_borrow_principal,\n        now(), ;; last_accrual updated because s_rate and b_rate are new\n        token_balance - amount_to_claim, ;; Update balance\n        tracking_supply_index, tracking_borrow_index,\n        awaited_supply\n      );\n    }\n\n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection, \n      if_active, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n\n   return ();\n}\n\n() force_enable_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    ;; enable = -1\n\n    cell log_data = begin_cell()\n      .store_uint(log::enable, 8)\n      .store_uint(now(), 32) \n      .end_cell();\n    emit_log_simple(log_data);\n\n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection, \n      -1, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n   return ();\n}\n\n() force_disable_contract_process (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    ;; just set 0 (flase) to is_active\n    \n    cell log_data = begin_cell()\n      .store_uint(log::disable, 8)\n      .store_uint(now(), 32) \n      .end_cell();\n    emit_log_simple(log_data);\n    \n    master::storage::save(\n      meta, upgrade_config,\n      asset_config_collection, \n      0, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n   return ();\n}\n\n() disable_contract_for_upgrade_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    (\n      int master_version, int user_version,\n      int timeout, int update_time, int freeze_time,\n      cell user_code,\n      cell new_master_code, cell new_user_code\n    ) = unpack_upgrade_config(upgrade_config);\n\n    cell new_upgrade_config = pack_upgrade_config(\n      master_version, user_version,\n      timeout, update_time, now(),\n      user_code,\n      new_master_code, new_user_code\n    );\n\n    cell log_data = begin_cell()\n      .store_uint(log::disable_for_upgrade, 8)\n      .store_uint(now(), 32) \n      .store_ref(upgrade_config)\n      .store_ref(new_upgrade_config)\n      .end_cell();\n    emit_log_simple(log_data);\n\n    master::storage::save(\n      meta, new_upgrade_config,\n      asset_config_collection, \n      0, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n   return ();\n}\n\n() init_upgrade_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    (\n      int master_version, int user_version,\n      int timeout, int update_time, int freeze_time,\n      cell user_code,\n      cell new_master_code, cell new_user_code\n    ) = unpack_upgrade_config(upgrade_config);\n    cell new_master_code = in_msg_body~load_maybe_ref();\n    cell new_user_code = in_msg_body~load_maybe_ref();\n    in_msg_body.end_parse();\n    int ts = now();\n    cell new_upgrade_config = pack_upgrade_config(\n      master_version, user_version,\n      timeout, ts + timeout, 0,\n      user_code,\n      new_master_code, new_user_code\n    );\n\n    cell log_data = begin_cell()\n      .store_uint(log::init_upgrade, 8)\n      .store_uint(now(), 32) \n      .store_ref(upgrade_config)\n      .store_ref(new_upgrade_config)\n      .end_cell();\n    emit_log_simple(log_data);\n\n    master::storage::save(\n      meta, new_upgrade_config,\n      asset_config_collection, \n      if_active, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n   return ();\n}\n\n(slice) on_upgrade(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure method_id (0x137) {\n  slice ds = get_data().begin_parse();\n  cell meta = ds~load_ref();\n  cell upgrade_config = ds~load_ref();\n  cell marketConfig = ds~load_ref();\n  slice unpacked_marked_config = marketConfig.begin_parse();\n  cell asset_config_collection = unpacked_marked_config~load_dict();\n  int if_active = unpacked_marked_config~load_int(8);\n  slice admin = unpacked_marked_config~load_msg_addr();\n  ;; Note Replace after upgrade with load of oracle_info\n  int admin_pk = unpacked_marked_config~load_uint(256); ;; prev version\n  cell tokens_keys = unpacked_marked_config~load_dict();\n  cell wallet_to_master = unpacked_marked_config~load_dict(); ;; rm on next update\n  cell asset_dynamics_collection = ds~load_dict();\n\n  ;; Note rm after upgrade\n  slice oracles_info = in_msg_body~load_bits_refs(33, 1);\n\n  cell new_asssets_config = new_dict();\n  (int asset_id, slice asset_config, int flag) = asset_config_collection.udict_get_min?(256);\n  while (flag) {\n\t  int jw_address_hash = asset_config~load_uint(256); \n\t  int decimals = asset_config~load_uint(8);\n\t  \n\t  cell asset_config_params_packed = asset_config~load_ref();\n\t  slice asset_config_params = asset_config_params_packed.begin_parse();\n\n\t  int collateral_factor = asset_config_params~load_uint(16);\n\t  int liquidation_threshold = asset_config_params~load_uint(16);\n\t  int liquidation_bonus = asset_config_params~load_uint(16);\n\t  int base_borrow_rate = asset_config_params~load_uint(64); \n\t  int borrow_rate_slope_low = asset_config_params~load_uint(64); \n\t  int borrow_rate_slope_high = asset_config_params~load_uint(64);\n\t  int supply_rate_slope_low = asset_config_params~load_uint(64); \n\t  int supply_rate_slope_high = asset_config_params~load_uint(64);\n\t  int target_utilization = asset_config_params~load_uint(64);\n\t  int origination_fee = asset_config_params~load_uint(64);\n\t  int dust = asset_config_params~load_uint(64);\n\t  int max_total_supply = asset_config_params~load_uint(64);\n\t  int reserve_factor = asset_config_params~load_uint(16);\n\t  int liquidation_reserve_factor = asset_config_params~load_uint(16);\n    \n    ;; Note Replace after upgrade with proper loads!\n\t  int min_principal_for_rewards = 0; \n\t  int base_tracking_supply_speed = 0; \n\t  int base_tracking_borrow_speed = 0; \n\n    cell packed_config = pack_asset_config(\n\t\t  jw_address_hash, decimals,\n\t\t  collateral_factor,\n\t\t  liquidation_threshold, liquidation_bonus,\n\t\t  base_borrow_rate, borrow_rate_slope_low,\n\t\t  borrow_rate_slope_high, supply_rate_slope_low,\n\t\t  supply_rate_slope_high, target_utilization,\n      origination_fee, dust,\n      max_total_supply,\n      reserve_factor, liquidation_reserve_factor,\n      min_principal_for_rewards, base_tracking_supply_speed,\n      base_tracking_borrow_speed\n    );\n\n    new_asssets_config~udict_set(256, asset_id, \n      packed_config.begin_parse()\n    );\n\n    (asset_id, asset_config, flag) =  asset_config_collection.udict_get_next?(256, asset_id);\n  }\n\n    cell new_asset_dynamics_collection = new_dict();\n\n    {\n        (int asset_id, slice asset_dynamics, int flag) = asset_dynamics_collection.udict_get_min?(256);\n        while (flag) {\n            int asset_s_rate = asset_dynamics~load_sb_rate();\n            int asset_b_rate = asset_dynamics~load_sb_rate();\n            int total_supply_principal = asset_dynamics~load_principal();\n            int total_borrow_principal = asset_dynamics~load_principal();\n            int last_accrual = asset_dynamics~load_timestamp();\n            int token_balance = asset_dynamics~load_balance();\n\n            int tracking_supply_index = 0;\n            int tracking_borrow_index = 0;\n            int awaited_supply = 0;\n\n            cell asset_dynamics_new = pack_asset_dynamics(\n                asset_s_rate, asset_b_rate,\n                total_supply_principal, total_borrow_principal,\n                last_accrual, token_balance,\n                tracking_supply_index, tracking_borrow_index,\n                awaited_supply\n            );\n\n            new_asset_dynamics_collection~udict_set(256, asset_id, asset_dynamics_new.begin_parse());\n\n            (asset_id, asset_dynamics, flag) = asset_dynamics_collection.udict_get_next?(256, asset_id);\n        }\n    }\n\n  master::storage::save(\n    meta, upgrade_config,\n    new_asssets_config, \n    if_active, oracles_info, admin, tokens_keys,\n    new_asset_dynamics_collection\n  );\n\n  return in_msg_body;\n}\n\n() submit_upgrade_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    (\n      int master_version, int user_version,\n      int timeout, int update_time, int freeze_time,\n      cell user_code,\n      cell new_master_code, cell new_user_code\n    ) = unpack_upgrade_config(upgrade_config);\n    throw_if(error::upgrade_not_allowed_new_code_is_empty, new_master_code.null?() & new_user_code.null?());\n    throw_unless(error::upgrade_not_allowed_too_early_update, now() > update_time);\n    throw_if(error::upgrade_not_allowed_freeze_too_short, freeze_time < 1);\n    throw_unless(error::upgrade_not_allowed_too_early_freeze, (now() - freeze_time) > constants::upgrade_freeze_time);\n    ifnot (new_master_code.null?()) {\n      master_version += 1;\n    }\n    ifnot (new_user_code.null?()) {\n      user_version += 1;\n      user_code = new_user_code;\n    }\n    cell new_upgrade_config = pack_upgrade_config(\n      master_version, user_version,\n      timeout, 0, 0,\n      user_code,\n      null(), null()\n    );\n    cell universal_data = master::upgrade::pack_universal_storage(\n      meta, new_upgrade_config,\n      asset_config_collection,\n      if_active, oracles_info, admin, tokens_keys,\n      asset_dynamics_collection\n    );\n\n    cell old_code = get_code();\n    cell old_store = get_data();\n\n    ifnot (new_master_code.null?()) {\n      set_code(new_master_code);\n      set_c3(new_master_code.begin_parse().bless());\n    }\n    \n    set_data(master::upgrade::unpack_universal_storage(universal_data));\n\n    on_upgrade(my_balance, msg_value, in_msg_full, in_msg_body);\n    \n    cell new_store = get_data();\n\n    cell log_data = begin_cell()\n      .store_uint(log::submit_upgrade, 8)\n      .store_uint(now(), 32) \n      .store_ref(begin_cell()\n          .store_ref(upgrade_config)\n          .store_ref(old_code)\n          .store_ref(old_store)\n        .end_cell())\n      .store_ref(begin_cell()\n          .store_ref(new_upgrade_config)\n          .store_ref(new_master_code)\n          .store_ref(new_store)\n        .end_cell())\n      .end_cell();\n    emit_log_simple(log_data);\n\n    recv_internal(my_balance, msg_value, in_msg_full,\n      begin_cell().store_op_code(op::do_data_checks).store_query_id(query_id).end_cell().begin_parse()\n    );\n    return ();\n}\n\n() cancel_upgrade_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n    (\n      int master_version, int user_version,\n      int timeout, int update_time, int freeze_time,\n      cell user_code,\n      cell new_master_code, cell new_user_code\n    ) = unpack_upgrade_config(upgrade_config);\n    cell new_upgrade_config = pack_upgrade_config(\n      master_version, user_version,\n      timeout, 0, 0,\n      user_code,\n      null(), null()\n    );\n    \n    cell log_data = begin_cell()\n      .store_uint(log::cancel_upgrade, 8)\n      .store_uint(now(), 32) \n      .store_ref(upgrade_config)\n      .store_ref(new_upgrade_config)\n      .end_cell();\n    emit_log_simple(log_data);\n\n    master::storage::save(\n      meta, new_upgrade_config,\n      asset_config_collection, \n      -1, oracles_info, admin, tokens_keys, ;; note r we shure that we can force set -1 (as is_active) here ?\n      asset_dynamics_collection\n    );\n   return ();\n}\n\n() idle_master_process  (\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n    slice target_address = parse_idle_master_message(in_msg_body);\n    throw_unless(\n      error::idle_target_not_allowed,\n      slice_data_equal?(sender_address, admin)\n      | slice_data_equal?(sender_address, target_address)\n    );\n    ;; ^ Strictly speaking, I don't immediately see a problem with:\n    ;; allowing any address to idle any other address, but ...\n    ;; better be safe than sorry\n    ;; The most likely problem I can imagine being somehow possible is:\n    ;; DDoSing User contract and slowly draining its balance\n\n    ( _, int user_version, _, _, _, cell user_code, _, _\n    ) = upgrade_config.unpack_upgrade_config();\n\n    ;; The only real reason to idle, is to upgrade User contract\n    ;; that is why it only makes sense to attach user_code\n    ;; (unlike with Supply, where sending op::supply_user without attaching user_code makes sense in most cases)\n    send_message_to_lending_wallet(\n      BLANK_CODE(), user_version, user_code, target_address,\n      pack_idle_user_message(\n        tokens_keys,\n        query_id,\n        sender_address\n      ),\n      sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE\n    );\n   return ();\n}\n\n() add_new_token_process(\n  int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n  slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n  cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n  int op, int query_id ;; trx body\n) impure inline {\n  throw_unless(error::message_not_from_admin, slice_data_equal?(sender_address, admin));\n  int asset_key = in_msg_body~load_uint(256);\n  cell new_asset_config = in_msg_body~load_ref();\n  cell new_asset_dynamics = in_msg_body~load_ref();\n  in_msg_body.end_parse();\n\n  (_, int flag1) = asset_config_collection~udict_set_get?(256, asset_key, new_asset_config.begin_parse());\n  (_, int flag2) = asset_dynamics_collection~udict_set_get?(256, asset_key, new_asset_dynamics.begin_parse());\n  throw_if(error::already_exists, flag1 | flag2);\n\n  cell log_data = begin_cell()\n    .store_uint(log::add_new_token, 8)\n    .store_uint(now(), 32)\n    .store_ref(new_asset_config)\n    .store_ref(new_asset_dynamics)\n    .store_ref(asset_config_collection)\n    .store_ref(asset_dynamics_collection)\n    .end_cell();\n  emit_log_simple(log_data);\n\n  master::storage::save(\n    meta, upgrade_config,\n    asset_config_collection, \n    if_active, oracles_info, admin, tokens_keys,\n    asset_dynamics_collection\n  );\n\n  ;; Add token is a pretty rare operation, can afford performing the full check\n  ;; Must be done after storage is updated!\n  recv_internal(my_balance, msg_value, in_msg_full,\n      begin_cell().store_op_code(op::do_data_checks).store_query_id(query_id).end_cell().begin_parse()\n  );\n\n  return ();\n}\n\n() do_data_checks_process (\n    int my_balance, int msg_value, cell in_msg_full, slice in_msg_body, ;; recv_internal params\n    slice sender_address, int addr_hash, int fwd_fee, ;; in_msg_full params\n    cell meta, cell upgrade_config, cell asset_config_collection, int if_active, slice admin, slice oracles_info, cell tokens_keys,  cell asset_dynamics_collection, ;; storage params\n    int op, int query_id ;; trx body\n) impure inline {\n    (\n        int master_code_version, int user_code_version,\n        int timeout, int update_time, int freeze_time,\n        cell user_code,\n        cell new_master_code, cell new_user_code\n    ) = upgrade_config.unpack_upgrade_config();\n    throw_unless(error::invalid_data + 0x1, is_valid_address?(admin));\n\n    ;; Make sure total_oracles, threshold > 0, threshold <= total_oracles, and oracles is present\n    int total_oracles = oracles_info~load_uint(16);\n    int threshold = oracles_info~load_uint(16);\n    int oracles_present = oracles_info~load_uint(1);\n    throw_unless(error::invalid_data + 0x2, total_oracles != 0);\n    throw_unless(error::invalid_data + 0x3, threshold != 0);\n    throw_unless(error::invalid_data + 0x4, threshold <= total_oracles);\n    throw_unless(error::invalid_data + 0x5, oracles_present);\n\n    ;; Check for TON entry presence in config\n    (_, int flag) = asset_config_collection.udict_get?(256, constants::ton_asset_id);\n    throw_unless(error::invalid_data + 0x6, flag);\n\n    ;; Check that every entry present in config is also present in dynamics, and both can be parsed\n    (int asset_id, slice asset_config, int flag) = asset_config_collection.udict_get_min?(256);\n    throw_unless(error::invalid_data + 0x7, flag);\n    while (flag) {\n        (slice asset_dynamics, int dyn_flag) = asset_dynamics_collection.udict_get?(256, asset_id);\n        throw_unless(error::invalid_data + 0x8, dyn_flag);\n\n        (\n            int jw_address_hash, int decimals,\n            int collateral_factor, int liquidation_threshold,\n            int liquidation_bonus, int base_borrow_rate,\n            int borrow_rate_slope_low, int borrow_rate_slope_high,\n            int supply_rate_slope_low, int supply_rate_slope_high,\n            int target_utilization, int origination_fee,\n            int dust_value, int max_total_supply,\n            int reserve_factor, int liquidation_reserve_factor,\n            int min_principal_for_rewards, int base_tracking_supply_speed,\n            int base_tracking_borrow_speed\n        ) = asset_config.unpack_asset_config();\n\n        throw_unless(error::invalid_data + 0x9, (0 <= collateral_factor) &\n            (collateral_factor <= liquidation_threshold) & (liquidation_threshold <= 10000));\n        throw_unless(error::invalid_data + 0xA, (liquidation_bonus >= 10000));\n        throw_unless(error::invalid_data + 0xB, (liquidation_reserve_factor <= constants::reserve_liquidation_scale));\n        throw_unless(error::invalid_data + 0xC, (reserve_factor <= constants::reserve_scale));\n\n        throw_unless(error::invalid_data + 0xD, (origination_fee <= constants::origination_fee_scale));\n\n        (\n            int asset_s_rate, int asset_b_rate,\n            int total_supply_principal, int total_borrow_principal,\n            int last_accrual, int token_balance,\n            int tracking_supply_index, int tracking_borrow_index,\n            int awaited_supply\n        ) = asset_dynamics.unpack_asset_dynamics();\n\n        (asset_id, asset_config, flag) = asset_config_collection.udict_get_next?(256, asset_id);\n    }\n    return ();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}