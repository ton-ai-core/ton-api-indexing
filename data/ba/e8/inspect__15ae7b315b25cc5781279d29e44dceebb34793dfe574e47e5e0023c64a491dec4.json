{
  "code": "b5ee9c7201023a010009c2000114ff00f4a413f4bcf2c80b0102016202030202ce0405020120131402012006070065421d749ab02705203aa008e23aa0303f00114a002a45301ba8e1323d74ac0019c5b01d430d020d749ab021270dede02e46c218047f3e09dbc400b434c0fe900c083e9100dc6c23c88c4cccc835d2708fe3c5200835c874c7cc2084139cdd12ee80b6cf2c38c02497c0f8b800f4c7f6cf1584b0002021081f09004f34c1c069b40830bffcb852483042b729be4830bffcb8524830443729b80830bfc870442c3cb852600330db3c5610c00193705711de104c103b4a98db3c085533db3c1f0c12042ce30f5540db3c105c104b103a497810561045103440330a0b0c0d03a257121110d30721c07922c06eb122c06423c077b121b1f2e04020b39e21d15616c000f2bd56152ebdf2bede22c064e30022c077925717e30d11168e1330041115040311140302111302571157115f03e30d0e0f1003341111d33f56165616db3ce30f0b11100b10bf10be10bd10bc10ab2122230028c88101001026cf0113cb0fcb0f01fa0201fa02c90104db3c1202d8810100561652a2f40e6fa120b3951112a41112de56122ebbf2e04182103b9aca0001111b01a120c200f2e042111a8e82db3c93307020e25613c0009401561aa094561aa001e25301a02cbef2e0432ad765755614b603aa00b609b9f2e04401db3c81010012561740bbf443082f2503a45611c0008f2156150410391028011118011111db3c015618a18212540be400be8e845613db3cde8ea3571781010056155292f40e6fa131f2e045c88101001256164099f4435613db3c4f0702e24f1f50770629303002fe5614c0ff56142dbab0b38e9d1114c000f2e07981010056135272f40e6fa1f2e07adb3c30c200f2e07b925714e211148020f00201d11113c079561356118307f40e6fa120b38e1982103b9aca005613d76595800f7aa984e401111801bef2e07b925717e2561695f404d31f3094306df823e25614228307f40e6fa131f2d07c2f11016cf82303c8ca0013cb1f021114018307f443c8f40001111201cb1f02011112010f8307f44311128e830ddb3c913de20c11100c10bf10bc30004a0cc8cb071bcb0f5009fa025007fa0215cc13f400f400cb1fcbffcb07cb1fcb1ff400c9ed540201201516020120191a0109bbf19db3c81f02016217180175af3bed9e2b882f87b6acc183fa0737d0f97042fa02183fc70fc0808029107a3e37d2904f816900698f98112cb781a802378101c8997100d9f32dc01f0109ac8b6d9e403302016e1b1c015dbbd05db3c57105f0f6d7f8e1f228307f47c6fa5208e1002f40431d31f3052106f0250036f02029132e201b3e6303181f0201201d1e0117ae3eed9e0837af8798b759c01f0276aa39db3c5f06509a5f096d7f8ea98101005230f47c6fa5208e9802db3c810100546380f40e6fa1312355206f0450036f02029132e201b3e6135f031f2f0244ab59db3c5f06509a5f098101002359f40e6fa1f2e056db3c8101004430f40e6fa1311f2f0154ed44d0d307d30ffa00fa00d401d0db3c05f404f404d31fd3ffd307d31fd31ff4043010bc10ab109a108920001c810100d701d30fd30ffa00fa0030001e01c0ff71f833d0810100d70358bab001e85b5712571257125712f8008210f96f732452e0ba8eb93b11117009a15380c1019a5088a020c100923727de8e16305305a8812710a9045301bc923020de5188a008a107e25077db3c270a11110a080a925712e22ac0018e198210ee6f454c52d0ba92703bde8210f374484c1dba92723ade913ce22404b85613c2005614c108b0821047657424561501bab182104e73744b561501bab1f2e0465613c001305613c0028f24d3071039102856180201111201db3c5619a18212540be400be8e845614db3cde11104870de5613c003e3005613c0062630272803ba707f8e988101005230f47c6fa5208e8702db3c3013a0029132e201b3e6306d7f8f378101005240f47c6fa5208f2602db3c25c2009f547715a98412a020c100923070de01dea070db3c8101005412015055f443029132e201b3e6145f042f2f25000ec858fa0201fa020172707f218eb0810100542270f47c6fa532218e9c3254411348705266db3c5217ba05a45304be927f36de103847634550de01b322b112e65f0401290268810100d7018101005462a0f40e6fa131f2e0474930185618011112db3c015619a18212540be400be8e845614db3cde1110487012293004d68f2024c103f2e071db3c6c21f9005360bd99343503a44413f823039130e25614db3cde5613c0078eb7f8237f8e2c56148307f47c6fa5208e1c02f40431d31f305230a18208278d00bc9a2011168307f45b301115de9132e201b3e65b5614db3cde821047657424561401ba3430302a03b2810100546550f40e6fa1f2bcdb3ca08212540be4005230a15210bc93306c14e0810100544666f45b30810100544655f45b3001a55124a182103b9aca005250be8f11705006db3c6d80101023102670db3c1023923434e243302f393804e08f3024c201f2e06f24c202f82325a124a63cbcb1f2e070821047657424c8cb1f5220cb3fc9db3c708018804010341023db3cde5613c0048e235616c0ff56162fbab0f2e04982103b9aca0001111901a120c200f2e04a51eea00e1118de5613c005925714e30d82104e73744b561301ba37382b2c04a85611c000f2e04a5616c0ff56162fbab0f2e04bfa0021c200f2e04e29db3c8212540be400561a01a101a15220bbf2e04c51f1a120c100923070de7f2fdb3c6d8010245970db3c561858a15619a18212540be400be2d39382e014e8e173005111605041115040311140302111302571157115f04e30d0f11100f10ef10de10cd10bc31013e707f8e988101005230f47c6fa5208e8702db3ca013a0029132e201b3e630312f011c8e841114db3c925714e20d11130d30000afa00fa00300114706d8010804072a0db3c3804d63e5f050fc0ff51e6ba1eb0f2e04e08c000f2e04f25f2e05082103b9aca001fbef2e05609fa0020db3c82103b9aca005230a18218746a5288005240bef2e0518212540be40001111001a15230bbf2e052535fbef2e0532edb3c5260bef2e0542d6ef2e05571db3c31f9007032333435001cd3ff31d31fd31f31d3ff31d431d100848028f833206e985b8218178411b200e0d0d30731fa00d31fd30fd30fd30f31d30f31d30fd30f305053a8ab075033a8ab075023a8ab0759a8ab075220a9b41fa0b60800268022f83320d0d30701c012f289d31fd31f3058035cdb3cdb3c1110c8cb1f1ccb3f5006cf16c9801871041110041038db3c0e11100e1f103e102d10bc107b50990743133637380022800ff833d0d31f31d31f31d31f31d70b1f011a71f833d0810100d7037f01db3c390048226eb32091719170e203c8cb055006cf165004fa02cb6a039358cc019130e201c901fb00001c74c8cb0212ca07810100cf01c9d0",
  "code_hash": "9a3ec14bc098f6b44064c305222caea2800f17dda85ee6a8198a7095ede10dcf",
  "methods": [
    {
      "id": 112473,
      "method": "get_nominator_data"
    },
    {
      "id": 111161,
      "method": "list_nominators"
    },
    {
      "id": 130309,
      "method": "list_votes"
    },
    {
      "id": 81689,
      "method": "get_pool_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "pool.fc",
        "content": ";; The validator has his own wallet in the masterchain, on which he holds his own coins for operating.\n;; From this wallet he sends commands to this nominator pool (mostly `new_stake`, `update_validator_set` and `recover_stake`).\n;; Register/vote_for complaints and register/vote_for config proposals are sent from validator's wallet.\n;;\n;; Pool contract must be in masterchain.\n;; Nominators' wallets must be in the basechain.\n;; The validator in most cases have two pools (for even and odd validation rounds).\n\nint op::new_stake() asm \"0x4e73744b PUSHINT\"; ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L621\nint op::new_stake_error() asm \"0xee6f454c PUSHINT\"; ;; return_stake https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L169\nint op::new_stake_ok() asm \"0xf374484c PUSHINT\"; ;; send_confirmation https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L173\n\nint op::recover_stake() asm \"0x47657424 PUSHINT\"; ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L625\nint op::recover_stake_error() asm \"0xfffffffe PUSHINT\"; ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L407\nint op::recover_stake_ok() asm \"0xf96f7324 PUSHINT\"; ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L426\n\nint ADDR_SIZE() asm \"256 PUSHINT\";\nint BOUNCEABLE() asm \"0x18 PUSHINT\";\nint NON_BOUNCEABLE() asm \"0x10 PUSHINT\";\nint SEND_MODE_PAY_FEE_SEPARATELY() asm \"1 PUSHINT\"; ;; means that the sender wants to pay transfer fees separately\nint SEND_MODE_IGNORE_ERRORS() asm \"2 PUSHINT\"; ;; means that any errors arising while processing this message during the action phase should be ignored\nint SEND_MODE_REMAINING_AMOUNT() asm \"64 PUSHINT\"; ;; is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message\nint ONE_TON() asm \"1000000000 PUSHINT\";\nint MIN_TONS_FOR_STORAGE() asm \"10000000000 PUSHINT\"; ;; 10 TON\nint DEPOSIT_PROCESSING_FEE() asm \"1000000000 PUSHINT\"; ;; 1 TON\nint MIN_STAKE_TO_SEND() asm \"500000000000 PUSHINT\"; ;; 500 TON\nint VOTES_LIFETIME() asm \"2592000 PUSHINT\"; ;; 30 days\n\nint binary_log_ceil(int x) asm \"UBITSIZE\";\n\n;; hex parse same with bridge https://github.com/ton-blockchain/bridge-func/blob/d03dbdbe9236e01efe7f5d344831bf770ac4c613/func/text_utils.fc\n(slice, int) ~load_hex_symbol(slice comment) {\n    int n = comment~load_uint(8);\n    n = n - 48;\n    throw_unless(329, n >= 0);\n    if (n < 10) {\n        return (comment, (n));\n    }\n    n = n - 7;\n    throw_unless(329, n >= 0);\n    if (n < 16) {\n        return (comment, (n));\n    }\n    n = n - 32;\n    throw_unless(329, (n >= 0) & (n < 16));\n    return (comment, n);\n}\n\n(slice, int) ~load_text_hex_number(slice comment, int byte_length) {\n    int current_slice_length = comment.slice_bits() / 8;\n    int result = 0;\n    int counter = 0;\n    repeat (2 * byte_length) {\n        result = result * 16 + comment~load_hex_symbol();\n        counter = counter + 1;\n        if (counter == current_slice_length) {\n            if (comment.slice_refs() == 1) {\n                cell _cont = comment~load_ref();\n                comment = _cont.begin_parse();\n                current_slice_length = comment.slice_bits() / 8;\n                counter = 0;\n            }\n        }\n    }\n    return (comment, result);\n}\n\nslice make_address(int wc, int addr) inline_ref {\n    return begin_cell()\n           .store_uint(4, 3).store_int(wc, 8).store_uint(addr, ADDR_SIZE()).end_cell().begin_parse();\n}\n\n;; https://github.com/ton-blockchain/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L584\nint is_elector_address(int wc, int addr) inline_ref {\n  return (wc == -1) & (config_param(1).begin_parse().preload_uint(ADDR_SIZE()) == addr);\n}\n\nslice elector_address() inline_ref {\n    int elector = config_param(1).begin_parse().preload_uint(ADDR_SIZE());\n    return make_address(-1, elector);\n}\n\n;; https://github.com/ton-blockchain/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L721\nint max_recommended_punishment_for_validator_misbehaviour(int stake) inline_ref {\n    cell cp = config_param(40);\n    if (cell_null?(cp)) {\n        return 101000000000; ;; 101 TON - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/lite-client/lite-client.cpp#L3678\n    }\n\n    slice cs = cp.begin_parse();\n\n    (int prefix,\n     int default_flat_fine, int default_proportional_fine,\n     int severity_flat_mult, int severity_proportional_mult,\n     int unpunishable_interval,\n     int long_interval, int long_flat_mult, int long_proportional_mult) =\n        (cs~load_uint(8),\n         cs~load_coins(), cs~load_uint(32),\n         cs~load_uint(16), cs~load_uint(16),\n         cs~load_uint(16),\n         cs~load_uint(16), cs~load_uint(16), cs~load_uint(16)\n        );\n\n     ;; https://github.com/ton-blockchain/ton/blob/master/lite-client/lite-client.cpp#L3721\n     int fine = default_flat_fine;\n     int fine_part = default_proportional_fine;\n\n     fine *= severity_flat_mult; fine >>= 8;\n     fine_part *= severity_proportional_mult; fine_part >>= 8;\n\n     fine *= long_flat_mult; fine >>= 8;\n     fine_part *= long_proportional_mult; fine_part >>= 8;\n\n     return min(stake, fine + muldiv(stake, fine_part, 1 << 32)); ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L529\n}\n\n;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/block/block.tlb#L632\n;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L118\nint get_validator_config() inline_ref {\n    slice cs = config_param(15).begin_parse();\n    (int validators_elected_for, int elections_start_before, int elections_end_before, int stake_held_for) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32), cs.preload_uint(32));\n    return stake_held_for;\n}\n\n;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/block/block.tlb#L712\n(int, int, cell) get_current_validator_set() inline_ref {\n    cell vset = config_param(34); ;; current validator set\n    slice cs = vset.begin_parse();\n    ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/block/block.tlb#L579\n    ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/config-code.fc#L49\n    throw_unless(9, cs~load_uint(8) == 0x12);  ;; validators_ext#12 only\n    int utime_since = cs~load_uint(32); ;; actual start unixtime of current validation round\n    int utime_until = cs~load_uint(32); ;; supposed end unixtime of current validation round (utime_until = utime_since + validators_elected_for); unfreeze_at = utime_until + stake_held_for\n    return (utime_since, utime_until, vset);\n}\n\n;; check the validity of the new_stake message\n;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L208\nint check_new_stake_msg(slice cs) impure inline_ref {\n    var validator_pubkey = cs~load_uint(256);\n    var stake_at = cs~load_uint(32);\n    var max_factor = cs~load_uint(32);\n    var adnl_addr = cs~load_uint(256);\n    var signature = cs~load_ref().begin_parse().preload_bits(512);\n    cs.end_parse();\n    return stake_at; ;; supposed start of next validation round (utime_since)\n}\n\nbuilder pack_nominator(int amount, int pending_deposit_amount) inline_ref {\n    return begin_cell().store_coins(amount).store_coins(pending_deposit_amount);\n}\n\n(int, int) unpack_nominator(slice ds) inline_ref {\n    return (\n        ds~load_coins(), ;; amount\n        ds~load_coins()  ;; pending_deposit_amount\n    );\n}\n\ncell pack_config(int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake) inline_ref {\n    return begin_cell()\n        .store_uint(validator_address, ADDR_SIZE())\n        .store_uint(validator_reward_share, 16)\n        .store_uint(max_nominators_count, 16)\n        .store_coins(min_validator_stake)\n        .store_coins(min_nominator_stake)\n        .end_cell();\n}\n\n(int, int, int, int, int) unpack_config(slice ds) inline_ref {\n    return (\n        ds~load_uint(ADDR_SIZE()), ;; validator_address\n        ds~load_uint(16), ;; validator_reward_share\n        ds~load_uint(16), ;; max_nominators_count\n        ds~load_coins(), ;; min_validator_stake\n        ds~load_coins() ;; min_nominator_stake\n    );\n}\n\n() save_data(int state, int nominators_count, int stake_amount_sent, int validator_amount, cell config, cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) impure inline_ref {\n    set_data(begin_cell()\n        .store_uint(state, 8)\n        .store_uint(nominators_count, 16)\n        .store_coins(stake_amount_sent)\n        .store_coins(validator_amount)\n        .store_ref(config)\n        .store_dict(nominators)\n        .store_dict(withdraw_requests)\n        .store_uint(stake_at, 32)\n        .store_uint(saved_validator_set_hash, 256)\n        .store_uint(validator_set_changes_count, 8)\n        .store_uint(validator_set_change_time, 32)\n        .store_uint(stake_held_for, 32)\n        .store_dict(config_proposal_votings)\n        .end_cell());\n}\n\n(int, int, int, int, (int, int, int, int, int), cell, cell, int, int, int, int, int, cell) load_data() inline_ref {\n    slice ds = get_data().begin_parse();\n    return (\n        ds~load_uint(8), ;; state\n        ds~load_uint(16), ;; nominators_count\n        ds~load_coins(), ;; stake_amount_sent\n        ds~load_coins(), ;; validator_amount\n        unpack_config(ds~load_ref().begin_parse()), ;; config\n        ds~load_dict(), ;; nominators\n        ds~load_dict(), ;; withdraw_requests\n        ds~load_uint(32), ;; stake_at\n        ds~load_uint(256), ;; saved_validator_set_hash\n        ds~load_uint(8), ;; validator_set_changes_count\n        ds~load_uint(32), ;; validator_set_change_time\n        ds~load_uint(32), ;; stake_held_for\n        ds~load_dict() ;; config_proposal_votings\n    );\n}\n\n() send_msg(slice to_address, int amount, cell payload, int flags, int send_mode) impure inline_ref {\n    int has_payload = ~ cell_null?(payload);\n\n    builder msg = begin_cell()\n        .store_uint(flags, 6)\n        .store_slice(to_address)\n        .store_coins(amount)\n        .store_uint(has_payload ? 1 : 0, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n\n    if (has_payload) {\n        msg = msg.store_ref(payload);\n    }\n\n    send_raw_message(msg.end_cell(), send_mode);\n}\n\n() send_excesses(slice sender_address) impure inline_ref {\n    send_msg(sender_address, 0, null(), NON_BOUNCEABLE(), SEND_MODE_REMAINING_AMOUNT() + SEND_MODE_IGNORE_ERRORS()); ;; non-bouneable, remaining inbound message amount, fee deducted from amount, ignore errors\n}\n\n(cell, cell, int, int) withdraw_nominator(int address, cell nominators, cell withdraw_requests, int balance, int nominators_count) impure inline_ref {\n    (slice nominator, int found) = nominators.udict_get?(ADDR_SIZE(), address);\n    throw_unless(60, found);\n    (int amount, int pending_deposit_amount) = unpack_nominator(nominator);\n    int withdraw_amount = amount + pending_deposit_amount;\n\n    if (withdraw_amount > balance - MIN_TONS_FOR_STORAGE()) {\n        return (nominators, withdraw_requests, balance, nominators_count);\n    }\n\n    nominators~udict_delete?(ADDR_SIZE(), address);\n    withdraw_requests~udict_delete?(ADDR_SIZE(), address);\n    nominators_count -= 1;\n    balance -= withdraw_amount;\n\n    if (withdraw_amount >= ONE_TON()) {\n        send_msg(make_address(0, address), withdraw_amount, null(), NON_BOUNCEABLE(), 0); ;; non-bouneable, fee deducted from amount, revert on errors\n    }\n    return (nominators, withdraw_requests, balance, nominators_count);\n}\n\n(cell, cell, int, int) process_withdraw_requests(cell nominators, cell withdraw_requests, int balance, int nominators_count, int limit) impure inline_ref {\n    int count = 0;\n    int address = -1;\n    int need_break = 0;\n    do {\n        (address, slice cs, int f) = withdraw_requests.udict_get_next?(ADDR_SIZE(), address);\n        if (f) {\n            (nominators, withdraw_requests, int new_balance, nominators_count) = withdraw_nominator(address, nominators, withdraw_requests, balance, nominators_count);\n            need_break = (new_balance == balance);\n            balance = new_balance;\n            count += 1;\n            if (count >= limit) {\n                need_break = -1;\n            }\n        }\n    } until ((~ f) | (need_break));\n\n    return (nominators, withdraw_requests, nominators_count, balance);\n}\n\nint calculate_total_nominators_amount(cell nominators) inline_ref {\n    int total = 0;\n    int address = -1;\n    do {\n        (address, slice cs, int f) = nominators.udict_get_next?(ADDR_SIZE(), address);\n        if (f) {\n            (int amount, int pending_deposit_amount) = unpack_nominator(cs);\n            total += (amount + pending_deposit_amount);\n        }\n    } until (~ f);\n    return total;\n}\n\ncell distribute_share(int reward, cell nominators) inline_ref {\n    int total_amount = 0;\n    int address = -1;\n    do {\n        (address, slice cs, int f) = nominators.udict_get_next?(ADDR_SIZE(), address);\n        if (f) {\n            (int amount, int pending_deposit_amount) = unpack_nominator(cs);\n            total_amount += amount;\n        }\n    } until (~ f);\n\n    cell new_nominators = new_dict();\n    address = -1;\n    do {\n        (address, slice cs, int f) = nominators.udict_get_next?(ADDR_SIZE(), address);\n        if (f) {\n            (int amount, int pending_deposit_amount) = unpack_nominator(cs);\n            if (total_amount > 0) {\n                amount += muldiv(reward, amount, total_amount);\n                if (amount < 0) {\n                    amount = 0;\n                }\n            }\n            amount += pending_deposit_amount;\n            new_nominators~udict_set_builder(ADDR_SIZE(), address, pack_nominator(amount, 0));\n        }\n    } until (~ f);\n\n    return new_nominators;\n}\n\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    int balance = pair_first(get_balance());\n\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    slice sender_address = cs~load_msg_addr();\n    (int sender_wc, int sender_addr) = parse_std_addr(sender_address);\n\n    if (flags & 1) { ;; bounced messages\n        if (in_msg_body.slice_bits() >= 64) {\n            in_msg_body~skip_bits(32); ;; skip 0xFFFFFFFF bounced prefix\n            int op = in_msg_body~load_uint(32);\n            if ((op == op::new_stake()) & (is_elector_address(sender_wc, sender_addr))) {\n                ;; `new_stake` from nominator-pool should always be handled without throws by elector\n                ;; because nominator-pool do `check_new_stake_msg` and `msg_value` checks before sending `new_stake`.\n                ;; If the stake is not accepted elector will send `new_stake_error` response message.\n                ;; Nevertheless we do process theoretically possible bounced `new_stake`.\n\n                (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n                if (state == 1) {\n                    state = 0;\n                }\n                save_data(\n                    state,\n                    nominators_count,\n                    stake_amount_sent,\n                    validator_amount,\n                    pack_config(validator_address, validator_reward_share, max_nominators_count, min_validator_stake, min_nominator_stake),\n                    nominators,\n                    withdraw_requests,\n                    stake_at,\n                    saved_validator_set_hash,\n                    validator_set_changes_count,\n                    validator_set_change_time,\n                    stake_held_for,\n                    config_proposal_votings\n                );\n            }\n        }\n        return (); ;; ignore other bounces messages\n    }\n\n    int op = in_msg_body~load_uint(32);\n\n   (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n\n    if (op == 0) {\n        ;; We use simple text comments for nominator operations so nominators can do it from any wallet app.\n        ;; In other cases, they will need to put a stake on a browser extension, or use scripts, which can be inconvenient.\n\n        ;; Throw on any unexpected request so that the stake is bounced back to the nominator in case of a typo.\n\n        int action = in_msg_body~load_uint(8);\n        int is_vote = (action == 121) | (action == 110); ;; \"y\" or \"n\"\n        throw_unless(64, (action == 100) | (action == 119) | is_vote); ;; \"d\" or \"w\" or \"y\" or \"n\"\n\n        if (~ is_vote) {\n            in_msg_body.end_parse();\n            throw_unless(61, sender_wc == 0); ;; nominators only in basechain\n            throw_unless(62, sender_addr != validator_address);\n        }\n\n        if (action == 100) { ;; \"d\" - deposit nominator (any time, will take effect in the next round)\n            (slice nominator, int found) = nominators.udict_get?(ADDR_SIZE(), sender_addr);\n\n            if (~ found) {\n                nominators_count += 1;\n            }\n            throw_unless(65, nominators_count <= max_nominators_count);\n\n            msg_value -= DEPOSIT_PROCESSING_FEE();\n            throw_unless(66, msg_value > 0);\n\n            (int amount, int pending_deposit_amount) = found ? unpack_nominator(nominator) : (0, 0);\n            if (state == 0) {\n                amount += msg_value;\n            } else {\n                pending_deposit_amount += msg_value;\n            }\n            throw_unless(67, amount + pending_deposit_amount >= min_nominator_stake);\n            throw_unless(68, cell_depth(nominators) < max(5, binary_log_ceil(nominators_count) * 2) ); ;; prevent dict depth ddos\n            nominators~udict_set_builder(ADDR_SIZE(), sender_addr, pack_nominator(amount, pending_deposit_amount));\n        }\n\n        if (action == 119) { ;; \"w\" - withdraw request (any time)\n            if (state == 0) {\n                (nominators, withdraw_requests, int new_balance, nominators_count) = withdraw_nominator(sender_addr, nominators, withdraw_requests, balance, nominators_count);\n                if (new_balance - msg_value >= MIN_TONS_FOR_STORAGE()) {\n                    send_excesses(sender_address);\n                }\n            } else {\n                (slice nominator, int found) = nominators.udict_get?(ADDR_SIZE(), sender_addr);\n                throw_unless(69, found);\n                withdraw_requests~udict_set_builder(ADDR_SIZE(), sender_addr, begin_cell());\n                send_excesses(sender_address);\n            }\n        }\n\n        if (is_vote) {\n            int authorized = (sender_wc == -1) & (sender_addr == validator_address);\n\n            if (~ authorized) {\n                throw_unless(121, sender_wc == 0);\n                (slice nominator, authorized) = nominators.udict_get?(ADDR_SIZE(), sender_addr);\n                throw_unless(122, authorized);\n                (int amount, int pending_deposit_amount) = unpack_nominator(nominator);\n                throw_unless(123, amount > 0);\n            }\n\n            int proposal_hash = in_msg_body~load_text_hex_number(32);\n            in_msg_body.end_parse();\n            int support = action == 121;\n\n            (slice votes_slice, int found) = config_proposal_votings.udict_get?(256, proposal_hash);\n\n            if (~ found) {\n                ;; require higher fee to prevent dictionary spam\n                int fee = ONE_TON();\n                int power = cell_depth(config_proposal_votings);\n                repeat (power) {\n                    fee = muldiv(fee, 15, 10);\n               }\n               throw_unless(123, msg_value >= fee);\n            }\n\n            (cell votes_dict, int votes_create_time) = found ? (votes_slice~load_dict(), votes_slice~load_uint(32)) : (new_dict(), now());\n\n            (_, int vote_found) = votes_dict.udict_get?(256, sender_addr);\n            throw_if(124, vote_found);\n            votes_dict~udict_set_builder(256, sender_addr, begin_cell().store_int(support, 1).store_uint(now(), 32));\n\n            builder new_votes = begin_cell().store_dict(votes_dict).store_uint(votes_create_time, 32);\n            config_proposal_votings~udict_set_builder(256, proposal_hash, new_votes);\n\n            if (found) {\n                send_excesses(sender_address);\n            }\n        }\n\n    } else {\n\n        int query_id = in_msg_body~load_uint(64);\n\n        if (is_elector_address(sender_wc, sender_addr)) { ;; response from elector\n\n            accept_message();\n\n            if (op == op::recover_stake_ok()) {\n                state = 0;\n\n                int reward = msg_value - stake_amount_sent;\n                int nominators_reward = 0;\n\n                if (reward <= 0) {\n                    validator_amount += reward;\n                    if (validator_amount < 0) {\n                        ;; even this should never happen\n                        nominators_reward = validator_amount;\n                        validator_amount = 0;\n                    }\n                } else {\n                    int validator_reward = (reward * validator_reward_share) / 10000;\n                    if (validator_reward > reward) { ;; Theoretical invalid case if validator_reward_share > 10000\n                        validator_reward = reward;\n                    }\n                    validator_amount += validator_reward;\n                    nominators_reward = reward - validator_reward;\n                }\n\n                nominators = distribute_share(nominators_reward, nominators); ;; call even if there was no reward to process deposit requests\n                stake_amount_sent = 0;\n            }\n\n            if (state == 1) {\n                if (op == op::new_stake_error()) { ;; error when new_stake; stake returned\n                    state = 0;\n                }\n\n                if (op == op::new_stake_ok()) {\n                    state = 2;\n                }\n            }\n\n            ;; else just accept coins from elector\n\n        } else {\n\n            ;; throw on any unexpected request so that the coins is bounced back to the sender in case of a typo\n            throw_unless(70, ((op >= 1) & (op <= 7)) | (op == op::recover_stake()) | (op == op::new_stake()));\n\n            if (op == 1) {\n                ;; just accept coins\n            }\n\n            if (op == 2) { ;; process withdraw requests (at any time while the balance is enough)\n                int limit = in_msg_body~load_uint(8);\n\n                (nominators, withdraw_requests, nominators_count, int new_balance) = process_withdraw_requests(nominators, withdraw_requests, balance, nominators_count, limit);\n\n                if (new_balance - msg_value >= MIN_TONS_FOR_STORAGE()) {\n                    send_excesses(sender_address);\n                }\n            }\n\n            if (op == 3) { ;; emergency process withdraw request  (at any time if the balance is enough)\n                int request_address = in_msg_body~load_uint(ADDR_SIZE());\n                (slice withdraw_request, int found) = withdraw_requests.udict_get?(ADDR_SIZE(), request_address);\n                throw_unless(71, found);\n                (nominators, withdraw_requests, int new_balance, nominators_count) = withdraw_nominator(request_address, nominators, withdraw_requests, balance, nominators_count);\n                if (new_balance - msg_value >= MIN_TONS_FOR_STORAGE()) {\n                    send_excesses(sender_address);\n                }\n            }\n\n            if (op == 6) { ;; update current valudator set hash (anyone can invoke)\n                throw_unless(113, validator_set_changes_count < 3);\n                (int utime_since, int utime_until, cell vset) = get_current_validator_set();\n                int current_hash = cell_hash(vset);\n                if (saved_validator_set_hash != current_hash) {\n                    saved_validator_set_hash = current_hash;\n                    validator_set_changes_count += 1;\n                    validator_set_change_time = now();\n                }\n                send_excesses(sender_address);\n            }\n\n            if (op == 7) { ;; clean up outdating votings\n                int t = now();\n                int proposal_hash = -1;\n                do {\n                    (proposal_hash, slice votes_slice, int found) = config_proposal_votings.udict_get_next?(256, proposal_hash);\n                    if (found) {\n                        (cell votes_dict, int votes_create_time) = (votes_slice~load_dict(), votes_slice~load_uint(32));\n                        if (t - votes_create_time > VOTES_LIFETIME()) {\n                            config_proposal_votings~udict_delete?(256, proposal_hash);\n                        }\n                    }\n                } until (~ found);\n                send_excesses(sender_address);\n            }\n\n            if (op == op::recover_stake()) { ;; send recover_stake to elector (anyone can send)\n\n                ;; We need to take all credits from the elector at once,\n                ;; because if we do not take all at once, then it will be processed as a fine by pool.\n                ;; In the elector, credits (`credit_to`) are accrued in three places:\n                ;; 1) return of surplus stake in elections (`try_elect`)\n                ;; 2) reward for complaint when punish (`punish`) - before unfreezing\n                ;; 3) unfreeze round (`unfreeze_without_bonuses`/`unfreeze_with_bonuses`)\n                ;; We need to be guaranteed to wait for unfreezing round and only then send `recover_stake`.\n                ;; So we are waiting for the change of 3 validator sets.\n\n                ;; ADDITIONAL NOTE:\n                ;; In a special case (if the network was down), the config theoretically can refuse the elector to save a new round after election - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/config-code.fc#L494\n                ;; and the elector will start a new election - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L364\n                ;; in this case, our pool will have to skip the round, but it will be able to recover stake later\n\n                throw_unless(111, validator_set_changes_count >= 2);\n                throw_unless(112, (validator_set_changes_count > 2) | (now() - validator_set_change_time > stake_held_for + 60));\n                ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L887\n\n                cell payload = begin_cell().store_uint(op::recover_stake(), 32).store_uint(query_id, 64).end_cell();\n                send_msg(elector_address(), 0, payload, BOUNCEABLE(), SEND_MODE_REMAINING_AMOUNT()); ;; bounceable,  carry all the remaining value of the inbound message, fee deducted from amount, revert on errors\n            }\n\n            ;; message from validator\n\n            if (op == 4) { ;; deposit validator (any time)\n                throw_unless(73, (sender_wc == -1) & (sender_addr == validator_address));\n                msg_value -= DEPOSIT_PROCESSING_FEE();\n                throw_unless(74, msg_value > 0);\n                validator_amount += msg_value;\n            }\n\n            if (op == 5) { ;; withdraw validator (after recover_stake and before new_stake)\n                throw_unless(74, state == 0); ;; no withdraw request because validator software can wait right time\n                throw_unless(75, (sender_wc == -1) & (sender_addr == validator_address));\n                int request_amount = in_msg_body~load_coins();\n                throw_unless(78, request_amount > 0);\n\n                int total_nominators_amount = calculate_total_nominators_amount(nominators);\n                ;; the validator can withdraw everything that does not belong to the nominators\n                throw_unless(76, request_amount <= balance - MIN_TONS_FOR_STORAGE() - total_nominators_amount);\n                validator_amount -= request_amount;\n                if (validator_amount < 0) {\n                    validator_amount = 0;\n                }\n                send_msg(make_address(-1, validator_address), request_amount, null(), NON_BOUNCEABLE(), 0); ;; non-bouneable, fee deducted from amount, revert on errors\n                int new_balance = balance - request_amount;\n                if (new_balance - msg_value >= MIN_TONS_FOR_STORAGE()) {\n                    send_excesses(sender_address);\n                }\n            }\n\n            if (op == op::new_stake()) {\n                throw_unless(78, (sender_wc == -1) & (sender_addr == validator_address));\n\n                throw_unless(79, state == 0);\n\n                throw_unless(80, query_id); ;; query_id must be greater then 0 to receive confirmation message from elector\n\n                throw_unless(86, msg_value >= ONE_TON()); ;; must be greater then new_stake sending to elector fee\n\n                int value = in_msg_body~load_coins();\n\n                slice msg = in_msg_body;\n\n                stake_at = check_new_stake_msg(in_msg_body);\n\n                stake_amount_sent = value - ONE_TON();\n\n                throw_unless(81, value >= MIN_STAKE_TO_SEND());\n\n                throw_unless(82, value <= balance - MIN_TONS_FOR_STORAGE());\n\n                throw_unless(83, validator_amount >= min_validator_stake);\n\n                throw_unless(84, validator_amount >= max_recommended_punishment_for_validator_misbehaviour(stake_amount_sent));\n\n                throw_unless(85, cell_null?(withdraw_requests)); ;; no withdraw requests\n\n                state = 1;\n                (int utime_since, int utime_until, cell vset) = get_current_validator_set();\n                saved_validator_set_hash = cell_hash(vset); ;; current validator set, we will be in next validator set\n                validator_set_changes_count = 0;\n                validator_set_change_time = utime_since;\n                stake_held_for = get_validator_config(); ;; save `stake_held_for` in case the config changes in the process\n\n                send_msg(elector_address(), value, begin_cell().store_uint(op, 32).store_uint(query_id, 64).store_slice(msg).end_cell(), BOUNCEABLE(), SEND_MODE_PAY_FEE_SEPARATELY()); ;; pay fee separately, rever on errors\n            }\n        }\n    }\n\n    save_data(\n        state,\n        nominators_count,\n        stake_amount_sent,\n        validator_amount,\n        pack_config(validator_address, validator_reward_share, max_nominators_count, min_validator_stake, min_nominator_stake),\n        nominators,\n        withdraw_requests,\n        stake_at,\n        saved_validator_set_hash,\n        validator_set_changes_count,\n        validator_set_change_time,\n        stake_held_for,\n        config_proposal_votings\n    );\n}\n\n;; Get methods\n\n_ get_pool_data() method_id {\n    return load_data();\n}\n\nint has_withdraw_requests() method_id {\n    (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n    return ~ cell_null?(withdraw_requests);\n}\n\n(int, int, int) get_nominator_data(int nominator_address) method_id {\n    (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n\n    (slice nominator, int found) = nominators.udict_get?(ADDR_SIZE(), nominator_address);\n    throw_unless(86, found);\n    (int amount, int pending_deposit_amount) = unpack_nominator(nominator);\n    (slice withdraw_request, int withdraw_found) = withdraw_requests.udict_get?(ADDR_SIZE(), nominator_address);\n\n    return (amount, pending_deposit_amount, withdraw_found);\n}\n\nint get_max_punishment(int stake) method_id {\n    return max_recommended_punishment_for_validator_misbehaviour(stake);\n}\n\ntuple list_nominators() method_id {\n    (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n    var list = null();\n    int address = -1;\n    do {\n        (address, slice nominator, int found) = nominators.udict_get_next?(ADDR_SIZE(), address);\n        if (found) {\n            (int amount, int pending_deposit_amount) = unpack_nominator(nominator);\n            (_, int withdraw_requested) = withdraw_requests.udict_get?(ADDR_SIZE(), address);\n            list = cons(tuple4(address, amount, pending_deposit_amount, withdraw_requested), list);\n        }\n    } until (~ found);\n    return list;\n}\n\ntuple list_votes() method_id {\n    (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n    var list = null();\n    int proposal_hash = -1;\n    do {\n        (proposal_hash, slice votes_slice, int found) = config_proposal_votings.udict_get_next?(256, proposal_hash);\n        if (found) {\n            (cell votes_dict, int votes_create_time) = (votes_slice~load_dict(), votes_slice~load_uint(32));\n            list = cons(pair(proposal_hash, votes_create_time), list);\n        }\n    } until (~ found);\n    return list;\n}\n\ntuple list_voters(int proposal_hash) method_id {\n    (int state, int nominators_count, int stake_amount_sent, int validator_amount, (int validator_address, int validator_reward_share, int max_nominators_count, int min_validator_stake, int min_nominator_stake), cell nominators, cell withdraw_requests, int stake_at, int saved_validator_set_hash, int validator_set_changes_count, int validator_set_change_time, int stake_held_for, cell config_proposal_votings) = load_data();\n    var list = null();\n    (slice votes_slice, int found) = config_proposal_votings.udict_get?(256, proposal_hash);\n    throw_unless(133, found);\n    cell votes_dict = votes_slice~load_dict();\n\n    int address = -1;\n    do {\n        (address, slice cs, int found) = votes_dict.udict_get_next?(ADDR_SIZE(), address);\n        if (found) {\n            (int support, int vote_time) = (cs~load_int(1), cs~load_uint(32));\n            list = cons(triple(address, support, vote_time), list);\n        }\n    } until (~ found);\n    return list;\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      }
    ]
  }
}