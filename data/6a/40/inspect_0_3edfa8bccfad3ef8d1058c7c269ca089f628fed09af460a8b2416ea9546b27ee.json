{
  "code": "b5ee9c720202019e0001000058fc00000114ff00f4a413f4bcf2c80b0001020162000200030202c80004000502012000130014020120002100220201200006000702012000080009020120000a000b0201620057005802014800680069020272000c000d020166000f001001c54207001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e20171804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e28000e0059421c0009c3120c8cc5210cc5210ccccc98e1901a55301f0ca5312f0ca5323f0ca5034f0cac8cc13ccccccc9e2802d48218706b7449647950036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019602015800110012003bd7c20b788f6a23880e800eba44080bf00e800c183eb926b85ffdd7970414002f3e105bc47b5120405780740060c1f5c935c2ffeebcb820600035341c35d22040a780740060c1f5c935c2fffe105bc4406ebcb820e0020120007200730201200015001602012001170118020120001700180201200019001a02012001780179020120014c014d020120001b001c020158001d001e020120001f002002e1a6f90480c69cdedcc6ca92dcccdeeca006de04ecb0de04de04db90de0442df100791969ee240e50202bce04126a6137315d0be0cd84442de2244df114a418403c6010202bc479e6342279e82039e2e43800326d843931c300380052e02de2592039993c042de279204de259203999993c501950196003ba4a104a032bb32b73a40af727fe49ffb91970b0201b19e822797ff999993006caa52830602d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e20104a856010002012000230024020120004000410201620025002602015800360037021bd2a9011ed9e7c20b7884898718740027002800736807400740875d2c8b5d2d40cef5484ef44ac64d7c0dc238808300024d7c0dff81fdc24c8b0802754d035d214d075d23c0184ac007a0517c138a01f421d0d303700271b098317f028020d72159de7f20706d04fa40fa4031fa0031f401fa003101fa4401c300f2d7ff5307c7008e2e6c3305d31fd33ffa0020d74981010bbe9c3827800b8307d724d70bff08de20c702953625d74c06df081035443012df02fa003073a9b400107b50a9105810471046503305046f0c002903fe82015b3ced43d8f07cc00092f082dec700dcf8416f13f8416f1b5c8e29eda2edfb218210e33b9873ba915b8e18218210f65ce988ba935bf0769a21c000935bdb31e0f077e2e2d8218210e33b9873ba93f2c106de218210f65ce988bae30f206f10f8416f15f82ca1f8416f16f8416f1aa1a15301bef2a501a170fb027f7122002a002b002c0004f861029a31f08182015b3ced43d8f07d9430706f018f39f08370532001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2727fdb3c1023db3ced54e2018e018e016221c000945b706f018ea682015b3ced43d8f07df2e1038e97eda2edfb21821066e22a24ba983182010b35ed43d8e30ed8e2002d02626f88925cb98ae810235f038ea388718010c8cb05f8416f197074c8cb02ca07cbffc9d0cf1670fa02cb6accc98306fb00de0031019b01fe218210536feb09ba9a31820102a1ed43d8db31e0218210421c1a25ba9a3182011055ed43d8db31e02182105388cd88ba9a31820185e1ed43d8db31e021821022f3ac09ba9a318201cdd8ed43d8db31e0218210b7680bc6ba9a318201b786ed43d8db31e0218210caae25a1ba9a318201c416ed43d8db31e021821024c8efb6002e02feba9a3182013811ed43d8db31e021821051bc9996ba9a3182013333ed43d8db31e0218210349d9aa5ba9a3182016411ed43d8db31e021821059a58cc2ba9a318201f803ed43d8db31e0218210ad13b0d1ba9a3182013f6fed43d8db31e021821091721efcba9a31820146a6ed43d8db31e00182107508b830bae30230f2c105002f003000128201cc1fed43d8db3100046f0001f253316f81206f1003a450338ee8eda2edfb2182186576656e74ba8e5731801070f07f218210e33b9873056f11415001f8416f1401c8cb1fcb3f58fa02f8416f197074c8cb02ca07cbffc9d0cf16ccc94130717105c8cb05037074c8cb02ca07cbffc9d013cf165003fa0213cb6accc901fb007fe30ed813b002003202fe218240616374696f6e43616c6cba8e6031206f1170226f12036f13413001f8416f1401c8cb1fcb3f58fa02f8416f197074c8cb02ca07cbffc9d0cf16ccc96d708018c8cb05047074c8cb02ca07cbffc9d014cf1670fa02216e947132cb6a957701cb6bcce2ccc9830658b1fb0070db31e02182287061796d656e74bae3022100330034016c318010717020f838226f12a0026f11881023707105c8cb05037074c8cb02ca07cbffc9d013cf165003fa0213cb6accc901fb007fdb31019b014682306469737061746368ba9531f066db31e00182206465706c6f79bae30230f2c10770003500ec206f12216f115c76c8cb04ccccc9f900236f13246f14056f15415001f8416f1401c8cb1fcb3f58fa02f8416f197074c8cb02ca07cbffc9d0cf16ccc976c8cb0412cc12ccc9708018c8cb05047074c8cb02ca07cbffc9d014cf1670fa02216e947132cb6a957701cb6bcce2ccc9830658b1fb0070db3102015800380039020148003e003f020120003a003b020120003c003d00910875d24875d268205fa06f238c6342343616e6e6f7420636f6e636174656e6174653a20737472696e6720746f6f206c6f6e678083f850c3e406102ac3cbc37b21633c58073c5b2742000053c0d20007722c20870402640a2c4b63c0d0068d63788700026600c3232c1f2743c0d37a4c870802384c85eaa42298c3232c1f274007c0d405eaa41007a0c7c0d6000053c0da0008d48b0821c000998030c8cb07c9d0f034de9321c2008e2c21a93803c10a9e21a93803a630c8cb07c9d001f0358e1021a93803a641a6f6c8cb07c9d001f035e201ab0301e831f0358001b4018b23a208f03501f037fe1430802014800420043020120004b004c020158004400450183b643f20105e12d452da449e50b8cf7dd27861f146122afe1b546bb8b70fc8216f0c614139f8f752261c003060fe8b660413327a060ff24b6e1e5ffb4231d046111bf019b03f7420c00398308b575696e74388e020c00499308b675696e7431368e020c00599308b675696e7433328e020c00699308b675696e7436348e020c0089a308b775696e743235368e020c00798308b5636f696e738e020c0089a308b7616464726573738e020c0099a308b7646963743235368e020c009e30220c009e302800460047004802bd4eda2edfb5c01d001a712a65074d724d70b032020c10991ae923070e221c0008e365b7102d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c300e001c109e3023080049004a0012308b66f626a52656680014308b763656c6c52656680026c000968b4626f6f6c8e08b7756e6b6e6f776e8006802d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2db31005401d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e200c3a33810b78911378980fc20b78a00e4658fe59fac7d017c20b78cb83a6465816503e5ffe4e8678b6664904207fca098400c12378a38201a7c1c5001b788a181b83882e4658281b83a6465816503e5ffe4e809e78b2801fd0109e5b5666480fd803fc0020120004d004e0201f4004f00500201580053005400153e105bc47c1feebcb840a0012723a43b68bb7ec8608408bceb026ea456f8c3b620005101fa218210536feb09ba2282105388cd88bab1955bf0eadb31e0218210421c1a25ba9531f0ebdb31e030208210b7680bc6ba218210caae25a1bab19530f0ecdb31e020821024c8efb6ba9d30f8416f11f07fbaf2e102db31e020821091721efcba218210ad13b0d1bab19330db31e020821066e22a24ba9530f0eadb31e0200052005c821051bc9996ba218210349d9aa5bab121821059a58cc2bab19530f0ecdb31e082107508b830ba92db31e0f2c10502012000550056002b5ed447001d001d74881015e01d0018307d724d70bff800192040978074005c75c91c75c0a00019204097c074005c75c91c75c0a00201200059005a01dff103838816800d38953282e5302396b926b8580a91153033d6b926b858490e0004b98916b9200eb81cdaceba46828896b9200eb81f1618010b8c183816800d38953282e5302396b926b8580a91153033d6b926b858490e0004b98916b9200eb81cdaceba46828896b9200eb81f1113940062020120005b005c020120005d005e001d3b511c00740075d21c00740075d220002f3b511c00740075d22040978074005c75c91c75c0bcb8406003b93e105bc47c1feebcb840bb511c00740075d2204097c074005c75c91c75c0bcb4413b511c1700740069c4a9941729811cb5c935c2c05488a9841cb5c935c2c048700024cc75d225d675d2340075d2389cfb5136cf1c5ff6cf36cf3b5520018e018e018e010120005f01d830ed44706f01217101d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e22070802002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c0002171006001e4830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c000b12172802002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c000b10173006102a2830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c000b1f2d08f798201775aed43d81023db3c758201775aed43d8db3c01018e018e01d8830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22373830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22474006301d8830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22575830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22676006401d8830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22777830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2087800650286804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2107810671056104510344130db3c20012e006601f88ef2eda2edfb2074830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22176830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e20278d820810455bdf2f2006700c8804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e222c00021c300b0955f038104038e2022c30001f823bbb0965b810402db31e020c30002bab095810401db31e0810455e2020120006a006b01dfb640e0e205a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c5860042e3008005a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c444e5006f016b69c20c180b40069c4a9941729811cb5c935c2c05488a9819eb5c935c2c248700025cc48b5c90075c0e6d675d2341444b5c90075c0f8a006c01b5f103800e800d38953282e5302396b926b8580a9115308396b926b858090e0004998eba44baceba46800eba47110b880e800d38953282e5302396b926b8580a9115308396b926b858090e0004998eba44baceba46800eba47101394006d02d08230636f696e73416d7477586f026f016dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e201950196016a830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e212006e02e88240657874656e6465644d647950046f027950036f0278586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019601c4830602d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2237301d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e22474007001c401d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e22575830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22676007101d601d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e207777802d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e210671056104510344130db3c015e020120007400750201200088008902012000760077020120008400850201200078007902012000a300a4020120007a007b0201480080008102015800960097020120007c007d0095a742030403ff2dda87b00243f20105e12d452da449e50b8cf7dd27861f146122afe1b546bb8b70fc8216f0c614139f8f7526b6dae12e03060fe81cdf43c529ae17feff2660e0e1c5b860ff020120007e007f01e3a0e89201fea422a8081601fea4108a01fea422a8080e01fea410234096a8088ea8094e06814d8681425ad82709fd4e16d826040fe2f2c7cb510cab000238c4cce4832021c35cc05f3c591c233c05c14492854c941040d9675cd04b3c5904133c048b5d2562848b5d28408f5ccb3c5b278c3a00b402e9a0b60841c185d1a1d54015bc09e14011bc09d5400dbc09e161bc09bc11b721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a019501960057a4bc03a0034e254ca0b94c08e5ae49ae1602a4454c20e5ae49ae16024380012663ae912eb3ae91a003ae91c502012000820083007da05887e4020bc25a8a5b4893ca1719efba4f0c3e28c2455fc36a8d7716e1f9042de18c28273f1eea4d6db5c25c060c1fd039be878a535c2ffdfe4cc1c1c38a01bba0d7b511c1bc05cc8fc21c408f6cf3b5520ba10da185b9b995b0e8e995d995b9d0e8e915417d0d191d7d3d0541417d4d155163c20166086195d995b9d00e09406576656e74815ee4ffc93ff7232e160403633d044f2fff333325bc09be32018e02012000c400c50201200086008702012000cb00cc02012000d500d6020120008a008b02012000940095020120008c008d02016a00900091020158008e008f02012000f100f202012000e100e20203796000e800e9020120009200930013a679da88e003a003ae9102eba1ee088141858dad95d1e54011bc09e5400dbc09d961bc09e1c1bc09bc11b721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a0195019602d7a066086135913d89a9e5400dbc09e561bc09bc09b721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a0195019602012000f800f90201200109010a0103a286009802012000a100a201e2ed44706f0102d02070d7480171d748217001d001d7487101d001d74884078e30eda2edfb01d0018e2220d74b20c0009c3031a93802c300f2d441db31e0c301018103f8bdb1f2d441d74cd0e430f2c441d822d02072d748d02070d7482271d7480271d7480381029e8040d724d70b3f1303009902e2d02081015e71d72471d7022181015f8307d724d70bff2281025f8307d724d70bff0372d7487001d0018307d724d70bff4130038e2c5f0303d02081015e8307d724d70bff2181025e8307d724d70bff0272d7487001d0018307d724d70bff1245059136e220c00026c000b122c000b1e30f009a009b014010355f056c1281017e01d0018307d724d70bff8210a2b5fbae70541300810090009c01c204a420103740562604d02072d748d005c8cbff05830770d73115cf16c9825037ffffffffffffffffffffff82d06c7a53656e64615ee067b829ee200393ff1e4037980e4ffd9bff26ffc8cbffcb5d057072d73015cf1613cb3fcbffcbffccc95342009e03f282404d7367526563656970747950056f027750046f027750036f0274586f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e201950196009d03f2ed447001d001d7487001d001d74882184d644f626a7950036f0279586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e21201950196019703948409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e26c31e30f019b009f00a0019a6c420281008a23f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c0181017e01d0018307d724d70bff8210a2b5fbae7054140081008a019301d23120f900c8cbffc9542420717fc8ca00cb075220cb3fccc9db3c102402d02072d748d0c8217071d730cf1614cc037072d73213cf16c9c82381029e72d730cf1612cb3fcc018102de73d731cf16c9ed5482104002b790018240616374696f6e43616c6c55206f046f8c018d0113bdf705433334403db3c8012e003bbf3ed447201d001d7487201d001d74881015e01d0018040d724d70b3fa5802016200a500a602012000b800b90103a15600a70155a250822b63b511c80740075d21c80740075d2204057807400601035c935c2cfc0acd6afac485bac7cb4236016402f68ef9eda2edfbed44706f0102d02072d748d02181028e78d724d70b072281015e8306d724d70b7f238101de8306d724d70b7f2470d7482470d7482671d7482781025e8010d724d70b0f2881026e78d724d70b07298102768010d724d70b0f0a81028678d724d70b070971d748108a1079106810571046103544302700a800a901d0d02072d748d02181015e8040d724d70b3f2183078306d724d70b7f228101808306d724d70b7f2471d7480470d7480581019e8307d724d70bff103544305611d02072d7487101d001d748218102de8306d724d70b7f2271d7480381025e8040d724d70b3f4130533900aa0002d802a08409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2316c12945f0f5f08e30d019b00ab03c28e3ceda2edfb206e9230708e3020f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba943070db31e0d0d70bffe2d85612f900ba965f0f5f07db31e1503988702070c8ca00cb07cb3fccc9db3c01111401019b018d00ac02f001d02072d748d0c8217071d730cf1613cc027072d73212cf16c9c82281035e72d730cf16cc017071d732cf16c9065611b9958100885712de514fb9958100895711de56112fb99581008b5711de70205612c0009a01111301106e105d6cc1e30d02ed5481017e01d0018307d724d70bff598210a2b5fbae0700ad00ae018e5b05a4533001d02081015e8020d724d70b1f2181017e8307d724d70bff2281027e8020d724d70b1f0381029e8307d724d70bff413004c8cb3f13cb1fcbffcb1fcbff71f904030d00af00fe02d0d45023c803d081015e72d73013cf16cb3fcbffc9c8cc01cf16c955200482884d73675265636569707493ff1c57b71ded097bc8cb978100c6cf4114cc12cb7fcb7fcb0fc9ed447001d001d7487001d001d748824004d644f626a93ff24ffdc8cb738100eacf4112ccccc9128240616374696f6e43616c6c55206f046f8c04d2d020c70093306f008e536f009421c700b38e4801d3ff0101d33f01126f02126f8c21d749810140be9e01d3ff0101d33f01126f02126f8cde21d749810140be9e01d3ff0101d33f01126f02126f8cde21d74ac2009501d74cd001dee831e2206f888ae430538abce30f00b000b100b200b300526f8d6f22021115027020c2009a236f1021a014706f8503de82287061796d656e7455206f046f8c111301f620105c514d104c103b40a924807fa908aa0205807fa90422807fa908aa0203807fa90408d025aa0223aa025381a05361a05096b609c27f5385b6098103f8bcb1f2d4432ac0008e31333920c80870d73017cf164708cf01705124a1532504103659d73412cf164104cf0122d74958a122d74a1023d732cf16c9e30e00b401fe2c105c5141104a103950cb24807fa908aa0205807fa90422807fa908aa0203807fa90408d025aa0223aa025381a05361a05096b609c27f5385b6098103f8bcb1f2d4432ac0008e31333920c80870d73017cf164708cf01705124a1532504103659d73412cf164104cf0122d74958a122d74a1023d732cf16c9e30e1046103500b401c882c84368616e6e656c3a3a6576656e743a3a5041434b45545f53454e542c515c5151105a1049103950aa03c8cc13ccc982b8706b7453656e74715edc77b93ff24ffd9bff1897b829ee6ffdc8cbdf807ecf4117cb7f15cb7f14cb3f13cbffccccccc94bb000b702fe34366f00708ef25303ba534bbab08e565303ba8e20c8533970d730cf16546a91cf0123d749539aa0a124d74a2559d732cf16126f8c8e2e530aba8e20c8533670d730cf16546761cf0123d7495367a0a124d74a2559d732cf16126f8c97c823cf16126f8ce2e2e30d22d74ac2009502d74cd002de01a4530abee6195f09530100b500b60074532870d7305398a070538ba12ba153165530d73424d7495378a0a125d74a2659d732c85003cf16546cb1cf0101cf16546871cf0101cf16126f8c00266f81c99322c2009802a55c6f8113ccc9e86c2100a8f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c5185a154222002d0c82181025e74d730cf1612cb3f81029e708040211045d734cf16cb7fc91078407702012000ba00bb02014800be00bf02015800bc00bd006ba553002005a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c50081bab830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e27074c8cb02ca07cbffc9d08006bbd320f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba973082104e554c4c94d0d70b4fe28018da085660805b887b50f600487e4020bc25a8a5b4893ca1719efba4f0c3e28c2455fc36a8d7716e1f9042de18c28273f1eea4d6db5c274060c1fd03dbe864cc1b5c385ff8b70c222019b01d7a13fb68bb7efb51081e00740069c4a9941729811cb5c935c2c05488a9841cb5c935c2c048700024cc75d225d675d2340075d238881c201000b40069c4a9941729811cb5c935c2c05488a9819eb5c935c2c248700025cc48b5c90075c0e6d675d2341444b5c90075c0f8889de00c002fe01d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e22070804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e220a55363b920b3058409a05280b915b09134e30d5350b920b3028409a0527000c100c2003e33513501d02081015e8040d724d70b3f0170d748d059a171d72471d702401301bab912b08e1c302401d02081015e8040d724d70b3f0170d748d059a171d72471d7029131e2935f0470e1955f0373db31e0017901d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e22200c301ac8409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2135f03c001925b74e0bb9372db31e071019b02014800c600c702dfac9141082827a7a7bb38b7813ce44204e7a064b781378136e4378110b7c401e465a7b890394080af381049a984dcc5742f83361110b7889137c452906100f1804080af11e798d089e7a080e78b90e000c9b610e4c70c00e0014b80b7896480e664f010b789e48137896480e66664f1400195019602012000c800c90103a44500ca0041a183e0abb511db232c104b333326103fe507ca23e09dbc400dc3e0de85c006d8260103a0420101018682206c7a53656e6476706f0278706f0278706f0278706f027950076f0277500b6f0277500a6f027950096f027950086f027950066f0210394870105a103441301a6f0a014202016e00cd00ce02e2aad182186576656e747850046f027950036f0279586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2019501960103bb3800cf0065fc0b40069c4a9941729811cb5c935c2c05488a9819eb5c935c2c248700025cc48b5c90075c0e6d675d2341444b5c90075c0f8a0296ed44706f0102f0c8217101d001d748db3c217001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2521001f90001f900baf2e08f2171014800d003a2804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2208ad801f2e08c547412db3ced4479067301d001d7487001d001d748230164010000d1042e88702070c8ca00cb07cb3fccc9db3c4160db3ced54236e019b018d018e00d204fe8ffa338854411482205061636b65747950046f027950036f0276586f0278706f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2029130e2019b0195019600d301a21382e84368616e6e656c3a3a6576656e743a3a5041434b45545f4e494c49464945445003f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c017300d400ea830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e282107b3f2a63ed447001d001d7487001d001d74814824004d644f626a93ff24ffdc8cb738100eacf4112ccccc941308240616374696f6e43616c6c55206f046f8c02016200d700d80104ab6f00dc02014800d900da00b7bd902d02081015e8040d724d70b3f0170d748d05121a15131a1c8533470d730cf165215a114cf4184095004a11270d73212cf16c9d0d7615121a0c85003cf1601cf40c982380504f4f4f615ee4ffcc8cb738100eacf4112cb3fccc980103ac6000db02e7ac608c1498dd915c10d999de14011bc09e1400dbc09d961bc09bc0db721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a00195019602e8ed44706f0102f0a27a228102de01d0018306d724d70b7f2270830602d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2a01023db3ced5482d84368616e6e656c3a3a6576656e743a3a5a524f5f4445504f534954454401018e015f02e0ed44706f0102db3c71830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e282108698f936227701d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e27000ea00dd01c2804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2037801d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e27000de016a804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e21300df03fa8240634e6f6e6365496e666f7650036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2ed447001d001d7487001d001d7480195019600e002fa82184d644f626a7950036f0279586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2128240616374696f6e43616c6c55206f046f8c019501960103a04200e3006fa16c8be4020bc25a8a5b4893ca1719efba4f0c3e28c2455fc36a8d7716e1f9042de18c28273f1eea61b049b44a0c1fd05e540a0c1fd05f8a011682286368616e6e656c790400e404fe82386261736553746f726578586f0270706f0270706f0279886f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2146f027950036f027858019b0195019600e5033a6f02797f7054700054700020db3c6f0276706f0279886f0276706f0279012e019b00e603e08210504f4f4f76716f0279c88409cf40c96f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e26f02790195019600e704f28210504f4f4f76716f0279c88409cf40c96f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e26f0279886f0277706f026f0b01950196019b014203f7a376a2383780816d9e103800e800d38953282e5302396b926b8580a9115308396b926b858090e0004998eba44baceba46800eba4716d9e10384020016800d38953282e5302396b926b8580a91153033d6b926b858490e0004b98916b9200eb81cdaceba46828896b9200eb81f141008ea7f6a1ec6181c92f81f1874000ea00eb00ec02f5a4c12026b9b3a932b1b2b4b83a3ca802b7813ba80237813ba801b7813a2c3781378236e4378110b7c401e465a7b890394080af381049a984dcc5742f83361110b7889137c452906100f1804080af11e798d089e7a080e78b90e000c9b610e4c70c00e0014b80b7896480e664f010b789e48137896480e66664f1400195019601c62071830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2017001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e20100ed016a70804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e200ee01e80171830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e282105e178f330270804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2037800ef02d682204d64416464727950036f0278586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019602ca82186e6f6e636576586f026f016dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019601c001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e270804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e21300f003de8240634e6f6e6365496e666f7650036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019601970203971000f300f402012000f500f602dff20901b1e9c9958dd9c1c995c1d9400dbc09dd61bc09bc09b721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a0195019602d9a4c11026b220b232393ca801b7813c2c3781378136e4378110b7c401e465a7b890394080af381049a984dcc5742f83361110b7889137c452906100f1804080af11e798d089e7a080e78b90e000c9b610e4c70c00e0014b80b7896480e664f010b789e48137896480e66664f1400195019600a9a5ee030403ff2dda87b0a60203a0034e254ca0e9ae49ae1606418213235d2460e1c42405a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c50103a72f00f7018482306c6962536e64436277500c6f0277500b6f0279500a6f027950096f027950086f027450076f027350066f027450056f027350046f027950036f0273586f026f0b014202012000fa00fb020158010301040076a99621f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba935b6d709d018307f40f6fa193306d70e17fe20104a81100fc0296ed44706f0102f0c8217101d001d748db3c217001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2521001f90001f900baf2e08f0171014800fd016a804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22000fe04d882186e6f6e636576586f026f016dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2218ad83154342301950196016400ff0412db3cdb3c307f21db3c010001250101010204ec885882205061636b65747950046f027950036f0276586f0278706f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2019b019501960166045c82384c7a526563765374737050036f0276586f0277706f0279886f0279886f0278706f0279886f0273706f026f08019b019b019b014203acdb3c30226ee3001382d84368616e6e656c3a3a6576656e743a3a5041434b45545f4255524e45445003f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c2273014e01050106006ba56b060e05a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c5018da442030403ff2dda87b00243f20105e12d452da449e50b8cf7dd27861f146122afe1b546bb8b70fc8216f0c614139f8f7526b6dae13a03060fe81edf432660dae1c2ffc5b86111019b03f4328854613182205061636b65747950046f027950036f0276586f0278706f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e202019b019501960178830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e203821095c3838203010703f08218706b7449647950036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2ed447001d001d7487001d001d7480195019601080058824004d644f626a93ff24ffdc8cb738100eacf4112ccccc943308240616374696f6e43616c6c55206f046f8c020120010b010c020120010f011002d4a9ac8230636f696e73416d7477586f026f016dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e20195019602016e010d010e0179bda88702070c8ca00cb07cb3fccc9740121c0009c3120c8cc5210cc5210ccccc98e1901a55301f0ca5312f0ca5323f0ca5034f0cac8cc13ccccccc9e28019b0095ba15982016e21ed43d80121f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba935b6d7097018307f40e6fa1e294d70bff7f93307070e2dc307f80201200111011202016a01150116004ba4dce0e104d0a0c2c6d6cae927fe49ffac2bdc0cf791972f02018d9e8229982599967f97ff9302014801130114005db92ed440101d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e280103bf58018e02e9b8a823853656e6445704366677850046f027850036f0278586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e280195019602ebbec8240657874656e6465644d647950046f027950036f0278586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e28019501960201200119011a020120011b011c0201200128012902012001370138020120011d011e02012001210122020148011f012002cfaeda410c3737b731b2bb2c37813780b6e4378110b7c401e465a7b890394080af381049a984dcc5742f83361110b7889137c452906100f1804080af11e798d089e7a080e78b90e000c9b610e4c70c00e0014b80b7896480e664f010b789e48137896480e66664f140019501960103a52b012e0069a7e443f20105e12d452da449e50b8cf7dd27861f146122afe1b546bb8b70fc8216f0c614139f8f7526b6dae12e03060fe81cdf43c502012001230124020120012601270058aae701d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e20104ab860125016ced44706f010281015e01d0018040d724d70b3f20c101f2d08521d02073d7487001d001d7482172d7487201d001d7480271d7481253230145006ca80d802002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e20086aa1201d02081015e8020d724d70b1f2181017e8307d724d70bff2281027e8020d724d70b1f0381029e8307d724d70bff413004c8cb3f13cb1fcbffcb1fcbff71f90403020120012a012b02012001350136020158012c012d020120012f01300119a0f9fdc151c00151c000836cf2012e0019a05406080633d3b50f6007c11a017082304570436f6e66696770500a6f027850096f027850086f027850076f027850066f027850056f027850046f027850036f0276586f026f09014202012001310132006ba587060e05a0034e254ca0b94c08e5ae49ae1602a4454c0cf5ae49ae16124380012e6245ae4803ae0736b3ae91a0a225ae4803ae07c50069a02de00b40069c4a9941729811cb5c935c2c05488a9819eb5c935c2c248700025cc48b5c90075c0e6d675d2341444b5c90075c0f8a02016e013301340387ae6232333262221c14c020b2131e949958dd94dd1cc057b615fdc67f93ff24ffd821fe6ffc331ff232f7e01fb3d046328005b2cfc5b2dfc532ffc532c1c4b304b3333260019b019b019b0103a860016b0108a8578ad80164000ea8f4ed4401f0460201200139013a02012001430144020120013b013c0104a8b40141020120013d013e020120013f01400069a34c060807fe5bb50f60040740069c4a9941729811cb5c935c2c05488a9841cb5c935c2c048700024cc75d225d675d2340075d238a0069a0c4060805e84bb50f60040740069c4a9941729811cb5c935c2c05488a9841cb5c935c2c048700024cc75d225d675d2340075d238a02d7a09a0861c1add12591e5400dbc09d961bc09bc09b721bc0885be200f232d3dc481ca040579c0824d4c26e62ba17c19b08885bc4489be22948308078c020405788f3cc6844f3d04073c5c8700064db08726386007000a5c05bc4b240733278085bc4f2409bc4b24073333278a01950196000fa157e403232fff2601648228706b7453656e747750096f027750086f027950076f027950066f027950056f027650046f027850036f0279586f026f08014202b06dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2019501960104ab09015e00caaab520c100f2d48121d02081015e8040d724d70b3f0170d748d05321b9925f038e423366a171c8534270d730cf16cb00840958a1a51370d73212cf16c9d0d7615121a0c85003cf1601cf40c982380504f4f4f615ee4ffcc8cb738100eacf4112cb3fccc9e203c68409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2300481015e01d0018040d724d70b3f5126ba04c00214b05252b9b0e30f019b0146014701ea541232717fc8ca00cb075220cb3fccc9db3c1301d001c8ccc9c80281035e73d73012cf16ccc9ed5481017e01d0018307d724d70bff82100c7b8418ed447001d001d7487001d001d74813824004d644f626a93ff24ffdc8cb738100eacf4112ccccc9128240616374696f6e43616c6c55206f046f8c018d024c6c2182e04368616e6e656c3a3a6576656e743a3a4e4f545f45584543555441424c4533db3c010148014901dc2070802002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22171830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22272014a03d48218706b7449647950036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e201950196015f01d6802002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e20373830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e259014b02e68210706174687550056f027850046f027550036f0278586f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2019501960105ae0b40014e020120015401550172ed44706f0122d02081015e71d72471d7020181015f8040d724d70b3f23d02072d7487301d001d7482173d7487001d001d7480271d748125313014f03d68409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2305126ba02c00112b0f2e08e05e30f0201d001c8ccc9c80281035e73d73012cf16ccc9ed54019b0150015103f23436515188702070c8ca00cb07cb3fccc9db3c515120c100f2d48121d02081015e8040d724d70b3f0170d748d05321b9925f038e423366a171c8534270d730cf16cb00840958a1a51370d73212cf16c9d0d7615121a0c85003cf1601cf40c982380504f4f4f615ee4ffcc8cb738100eacf4112cb3fccc9e214019b018d015202dc30315312727fc8ca00cb075220cb3fccc9db3c82f04368616e6e656c3a3a6576656e743a3a4c5a5f524543454956455f414c455254702772830602d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22873018d015301fc01d02072d748d0c8017073d730cf1612ccc9c82281035e72d730cf16cc017071d732cf16c982b84368616e6e656c3a3a6576656e743a3a44454c49564552454402d0c82181015e70d730cf162181027e810120d724cf160181015e810120d724cf16c9500482400706b74496493ff1857bc8cb738100eacf4112cccb3fc9015f02ce01d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2097401d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2f8416f19103610351024103a410772db3c015e015f006eaa027102d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c3000201480156015702012001580159020158016201630103b9f8015a0189bb2702120f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba93307f6d9c8307f4866fa59101e05b7f6de2309320c2ff8ae830318016101a4ed44706f0102f0ab2071804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e220c000f2d085027301d001d7487001d001d74822015b02e68409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2315124ba58b0f2e08582f04368616e6e656c3a3a6576656e743a3a4c5a5f524543454956455f414c4552542270019b015c01da7102d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c3002372830602d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e22473015d02da01d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2057401d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2f8416f112782011d4fed43d8104710681035413018db3c015e015f01f42480208e30eda2edfb01d0018e2220d74b20c0009c3031a93802c300f2d441db31e0c301018103f8bdb1f2d441d74cd0e430f2c441d82380208e30eda2edfb01d0018e2220d74b20c0009c3031a93802c300f2d441db31e0c301018103f8bdb1f2d441d74cd0e430f2c441d882384c7a5265637653747370500901600056f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c02fc6f027650086f027750076f027950066f027950056f027850046f027950036f0273586f026f086dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e201950196007e522021f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba935b7f6d9d018307f47c6fa59101e05b7f6de23001a40100b1b7009a040e5ae91a00b9197fe0b060ee1ae622b9e2d9304a06fffffffffffffffffffffff05a0d8f4a6cadcc8c2bdc0cf7053dc400727fe3c806f301c9ffb37fe4dff9197ff96ba0ae0e5ae602b9e2c27967f97ff97ff9993001e9b31da88e0de0205a0410202bd0081ae49ae167e0302033d060dae49ae16fe04e203a003ae910202fc03a003060fae49ae17ff04212fbe8098044115b1da88e403a003ae90e403a003ae910202bc03a0030081ae49ae167e0566b57d6242dd63e5a11aa0070460c8d2e6e0c2e8c6d0aa60de0adf190016402fceda2edfb20c101f2d085ed44207201d001d7487301d001d7482081015e01d0018040d724d70b3f027301d001d7487001d001d748238409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e25365ba019b016500c85147ba14b021c301b09b306c22327f01926d32df018e4c5255be2381015e01d0018040d724d70b3f8103fea05260bbb004c30114b08e260301d02081015e8040d724d70b3f0170d748d059a171d72471d702987f0292306ddfdb31e15b925f04e2706de203f88210deadbeef7020823052637645704366677850046f027850036f0276586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2027301950196016703c801d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e220707102d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2c300e30f1201680169016a006e302170830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2006a75830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e203ee8240657874656e6465644d647950046f027950036f0278586f026f036dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2db3c3001950196016b01e8ed44706f0102f0a720d02070d7480181015e8307d724d70bff217101d001d74880208e30eda2edfb01d0018e2220d74b20c0009c3031a93802c300f2d441db31e0c301018103f8bdb1f2d441d74cd0e430f2c441d823d02072d748d02070d7482172d7480273d7480373d7487001d001d7481323016c04d2d02081015e71d72471d7020172d748830801d0018307d724d70bff218e1530277101d001d74881015e01d0018307d724d70bffde26bd93303335e30d2381015e01d0018040d724d70b3f5475208ad892345be30d0281015e01d0018040d724d70b3f8103fea05210bb016d016e016f017003f0077101d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2278e362477830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2e30d08e30f5164bd06f823b916b193f2c084de01710172017302feeda2edfb20c101f2d0852281015e01d0018040d724d70b3f51218409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2135f035213be2381015e01d0018040d724d70b3f8103fea05220bbb002c301019b017402f26620c100f2d48121d02081015e8040d724d70b3f0170d748d05321b9925f038e423366a171c8534270d730cf16cb00840958a1a51370d73212cf16c9d0d7615121a0c85003cf1601cf40c982380504f4f4f615ee4ffcc8cb738100eacf4112cb3fccc9e2543214727fc8ca00cb075220cb3fccc9db3c544633018d0175014c8ea082105e178f33037201d001d7487301d001d74881015e01d0018040d724d70b3f925f03e20177006c2071830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2006e340372804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2006e300378804002d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2004e12b08e1f01d02081015e8040d724d70b3f0170d748d059a171d72471d702937fdb31e1915be27001fe02d02072d748d0c8217072d730cf1613cc027071d73212cf16c902c8ccc9c80281035e72d73012cf1612ccccc9ed541582f04368616e6e656c3a3a6576656e743a3a5041434b45545f434f4d4d49545445445003f0805982186576656e74038250195d995b9d2057b93ff24ffdc8cb858100d8cf4113cbffccccc96f026f8c017600020403e08240634e6f6e6365496e666f7650036f0276586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e212019501960197020120017a017b0201200180018103efae4fc11c3130b9b2a9ba37b932bc2c378138383781383837813cc43781378236e4378110b7c401e465a7b890394080af381049a984dcc5742f83361110b7889137c452906100f1804080af11e798d089e7a080e78b90e000c9b610e4c70c00e0014b80b7896480e664f010b789e48137896480e66664f140019b01950196020120017c017d020158017e017f0058a94301d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e20049a355c209a141858dad95d24ffc93ff5857b819ef232e5e04031b3d0453304b332cff2fff260007a11fb51202012001820183020120018401850036a811824804d644164647293ff2057bc8cb738100eacf41cbffccc9009ea896ed44530101d001a712a65074d724d70b0320c10991ae923070e21202d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e2020120018601870201e7019c019d020120018801890105a63511019b0103a00e018a006ba16e01000b40069c4a9941729811cb5c935c2c05488a9819eb5c935c2c248700025cc48b5c90075c0e6d675d2341444b5c90075c0f8a01b4ed44706f01217101d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e2237001d001d7487001d001d748521001f90001f900baf2e08f2381015e01d0018040d724d70b3f2375018b02f001d001a712a6505ca60472d724d70b015222a61072d724d70b0121c0009331d7489759d748d001d748e253018409a90801d021ab07d748d021a93807ab05d748d021a93805ab03d748d021a93803ab01d748d001a93801d748d0d200d307229920d70b3f01d74c40038e865b7f88542003e2306c12c30101019b018c04c08e3ceda2edfb206e9230708e3020f90082f096a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7ba943070db31e0d0d70bffe2d827f900bdb1f2d086750288702070c8ca00cb07cb3fccc9db3c1024db3ced540171019b018d018e018f01f6018409a90802d022ab0723a93807ab0524a93805ab0325a93803ab0106a938015343d748d05303d748d05303d748d05309d748d0c8217027d730cf161acc70735006a14a50d73213cf16c9c828702bd730cf16cc7073500aa14890d73217cf16c9c8277024d730cf16cc70735003a14770d73215cf16c9c8247027019002f402d001a712a6505ca60472d724d70b01532174d724d70b035da6067ad724d70b095244a61072d724d70b012120c10991ae923070e223c0009125955353d748d0e221c300927433dec821d74927b60822d74a5250b6082359d730cf1604c0098e163206b60b541026cf015035a022d74a1023d73113cf16e30d22019101920182830702d001a712a6505ca60472d724d70b015222a6067ad724d70b0921c000973122d72401d7039b59d748d05112d72401d703e28210a2b5fbae705414008100870193004ed730cf16cc70735006a15e31d73213cf16c9c8237024d730cf16cc70735003a14330d732cf16c9002831345055cc7023d74a5006a1a54350d73213cf160048c2008e1bc9c822d749546351d730cf16cc7022d74a5004a1a513d732cf16c9936c21c9e203f282404d7367526563656970747950056f027750046f027750036f0274586f026f046dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e201950196019403f4ed447001d001d7487001d001d74882184d644f626a7950036f0279586f026f026dc86f02216f8803c8cb4f71207281015e7020935309b98ae85f066c22216f11226f88a520c201e30081015e23cf31a113cf4101cf1721c001936c21c98e1801c00297016f12c901ccc9e0216f13c9026f12c901ccccc9e2413001950196019703fc53806f81206f102020c10991ae923070e220c2008e1c5350a08409bc8e133507a4702a6f885220be950ac86f8c0ade5085de8e1d24a427bc8e16343505a470742a6f885230be950ac86f8c0ade476604dee221c1098e1821c0099d026f1153a76f81cc541a076f859532f2c42309e2e30d5098cb0328c200e30f02a4106701980199019a033e21cf32c0008f0788885003cc12cc8e8d21cf32c0018e848858cc01de01e201019b019b019b00248240616374696f6e43616c6c55206f046f8c0022026f11b60b53a86f8123cf01541a086f85002a7327c00191709127e258cb015240cb09cb015038a0003438840925c00191709125e25009cb0118cb095210cb0101a447070000005db2dda880203a0034e254ca0b94c08e5ae49ae1602a4454c20e5ae49ae16024380012663ae912eb3ae91a003ae91c500081b651c79db45dbf640dd2460e11c6041f20105e12d452da449e50b8cf7dd27861f146122afe1b546bb8b70fc8216f0c614139f8f752860e1b663c1a1ae17ffc5b10",
  "code_hash": "460c1c62fd4d98ba683bd25552ab0d830eb761de06ef1858a3ec3948429220ec",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "src/protocol/msglibs/interface.fc",
        "content": ";; All msglibs must have the path in their storage as field 1\nconst int MsglibConnection::PathFieldIdx = 1;\n\n;; All msglibs are required to have a connection and a manager\nconst int MsglibManager::OP::GET_MSGLIB_INFO = \"MsglibManager::OP::GET_MSGLIB_INFO\"c;\n\nconst int MsglibManager::OP::DEPLOY_CONNECTION = \"MsglibManager::OP::DEPLOY_CONNECTION\"c;\n\nconst int MsglibManager::OP::SET_OAPP_MSGLIB_SEND_CONFIG = \"MsglibManager::OP::SET_OAPP_MSGLIB_SEND_CONFIG\"c;\n\n;; Set the connection MSGLIB config\n;; called by OApp, seeded by SENDER\nconst int MsglibManager::OP::SET_OAPP_MSGLIB_RECEIVE_CONFIG = \"MsglibManager::OP::SET_OAPP_MSGLIB_RECEIVE_CONFIG\"c;\n\nconst int Msglib::OP::RETURN_QUOTE = \"Msglib::OP::RETURN_QUOTE\"c;\n\nconst int MsglibConnection::OP::MSGLIB_CONNECTION_QUOTE = \"MsglibConnection::OP::MSGLIB_CONNECTION_QUOTE\"c;\nconst int MsglibConnection::OP::MSGLIB_CONNECTION_SEND = \"MsglibConnection::OP::MSGLIB_CONNECTION_SEND\"c;\nconst int MsglibConnection::OP::MSGLIB_CONNECTION_COMMIT_PACKET_CALLBACK = \"MsglibConnection::OP::MSGLIB_CONNECTION_COMMIT_PACKET_CALLBACK\"c;\nconst int MsglibConnection::OP::MSGLIB_CONNECTION_SYNC_CHANNEL_STATE = \"MsglibConnection::OP::MSGLIB_CONNECTION_SYNC_CHANNEL_STATE\"c;\n\nconst int Msglib::ERROR::onlyChannel = 288;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/endpoint/interface.fc",
        "content": ";; OPCODES\nconst int Endpoint::OP::ENDPOINT_SEND = \"Endpoint::OP::ENDPOINT_SEND\"c;\nconst int Endpoint::OP::ENDPOINT_COMMIT_PACKET = \"Endpoint::OP::ENDPOINT_COMMIT_PACKET\"c;\nconst int Endpoint::OP::SET_EP_CONFIG_DEFAULTS = \"Endpoint::OP::SET_EP_CONFIG_DEFAULTS\"c;\nconst int Endpoint::OP::SET_EP_CONFIG_OAPP = \"Endpoint::OP::SET_EP_CONFIG_OAPP\"c;\nconst int Endpoint::OP::ADD_MSGLIB = \"Endpoint::OP::ADD_MSGLIB\"c;\nconst int Endpoint::OP::GET_MSGLIB_INFO_CALLBACK = \"Endpoint::OP::GET_MSGLIB_INFO_CALLBACK\"c;\n\n;; EVENTS\nconst int Endpoint::event::EP_CONFIG_DEFAULTS_SET = \"EP_CONFIG_DEFAULTS_SET\"u;\n\n;; ERRORS\nconst int Endpoint::ERROR::notOApp = 300;\nconst int Endpoint::ERROR::wrongPath = 301;\nconst int Endpoint::ERROR::unauthorizedMsglib = 302;\nconst int Endpoint::ERROR::invalidExpiry = 303;\nconst int Endpoint::ERROR::unresolvedMsglib = 304;\nconst int Endpoint::ERROR::msglibInfoExists = 305;\nconst int Endpoint::ERROR::numMsglibsExceeded = 306;\nconst int Endpoint::ERROR::sameTimeoutAndReceive = 307;\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/controller/interface.fc",
        "content": "const int MAX_MSGLIBS = 255;\n\n;; OPCODES\nconst int Controller::OP::DEPLOY_ENDPOINT = \"Controller::OP::DEPLOY_ENDPOINT\"c;\nconst int Controller::OP::DEPLOY_CHANNEL = \"Controller::OP::DEPLOY_CHANNEL\"c;\nconst int Controller::OP::SET_EP_CONFIG_DEFAULTS = \"Controller::OP::SET_EP_CONFIG_DEFAULTS\"c;\nconst int Controller::OP::SET_EP_CONFIG_OAPP = \"Controller::OP::SET_EP_CONFIG_OAPP\"c;\nconst int Controller::OP::ADD_MSGLIB = \"Controller::OP::ADD_MSGLIB\"c;\nconst int Controller::OP::DEPOSIT_ZRO = \"Controller::OP::DEPOSIT_ZRO\"c;\nconst int Controller::OP::SET_ZRO_WALLET = \"Controller::OP::SET_ZRO_WALLET\"c;\nconst int Controller::OP::EXCESSES = 0xd53276db; ;; op::excesses: 0xd53276db\nconst int Controller::OP::TRANSFER_OWNERSHIP = \"Controller::OP::TRANSFER_OWNERSHIP\"c;\nconst int Controller::OP::CLAIM_OWNERSHIP = \"Controller::OP::CLAIM_OWNERSHIP\"c;\n\n;; EVENT\nconst int Controller::event::ZRO_WALLET_SET = \"Controller::event::ZRO_WALLT_SET\"u;\nconst int Controller::event::OWNER_SET = \"Controller::event::OWNER_SET\"u;\nconst int Controller::event::OWNER_SET_TENTATIVE = \"Controller::event::OWNERSET_TENT\"u;\n\n;; ERRORS\nconst int Controller::ERROR::onlyOApp = 65;\nconst int Controller::ERROR::invalidEid = 66;\nconst int Controller::ERROR::onlyZroWallet = 67;\nconst int Controller::ERROR::onlyTentativeOwner = 68;\nconst int Controller::ERROR::nullTentativeOwner = 69;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/channel/callbackOpcodes.fc",
        "content": ";; Send flow\nconst int Layerzero::OP::CHANNEL_SEND_CALLBACK = \"Layerzero::OP::CHANNEL_SEND_CALLBACK\"c;\n\n;; Receive flow\nconst int Layerzero::OP::LZ_RECEIVE_PREPARE = \"Layerzero::OP::LZ_RECEIVE_PREPARE\"c;\nconst int Layerzero::OP::LZ_RECEIVE_EXECUTE = \"Layerzero::OP::LZ_RECEIVE_EXECUTE\"c;\n\n;; Receive flow management\nconst int Layerzero::OP::BURN_CALLBACK = \"Layerzero::OP::BURN_CALLBACK\"c;\nconst int Layerzero::OP::NILIFY_CALLBACK = \"Layerzero::OP::NILIFY_CALLBACK\"c;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/lz/SendEpConfig.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int lz::SendEpConfig::NAME = \"SendEpCfg\"u;\n\n;; field names\nconst int lz::SendEpConfig::sendMsglibManager = 0;\nconst int lz::SendEpConfig::sendMsglib = 1;\nconst int lz::SendEpConfig::sendMsglibConnection = 2;\n\ncell lz::SendEpConfig::New(int sendMsglibManager, int sendMsglib, int sendMsglibConnection) impure inline method_id {\n    return cl::declare(\n        lz::SendEpConfig::NAME,\n        unsafeTuple([\n            [cl::t::address, sendMsglibManager],        ;; lz::SendEpConfig::sendMsglibManager\n            [cl::t::address, sendMsglib],               ;; lz::SendEpConfig::sendMsglib\n            [cl::t::address, sendMsglibConnection]      ;; lz::SendEpConfig::sendMsglibConnection\n        ])\n    );\n}\n\n;; ====================== Object Builders =====================\n\n;; everything fits in the root cell\nconst int lz::SendEpConfig::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 3);\nconst int lz::SendEpConfig::_headerFillerBits = _HEADER_WIDTH - lz::SendEpConfig::_headerInfoBits;\nconst int lz::SendEpConfig::_headerInfo = 27713146160555717952182050613837570051;\n\ncell lz::SendEpConfig::build(int sendMsglibManager, int sendMsglib, int sendMsglibConnection) impure inline {\n    return begin_cell()\n        .store_uint(lz::SendEpConfig::_headerInfo, lz::SendEpConfig::_headerInfoBits)\n        .store_ones(lz::SendEpConfig::_headerFillerBits)\n        .store_uint256(sendMsglibManager)\n        .store_uint256(sendMsglib)\n        .store_ref(empty_cell())\n        .store_ref(empty_cell())\n        .store_ref(\n            begin_cell()\n                .store_uint256(sendMsglibConnection)\n            .end_cell()\n        )\n        .end_cell();\n}\n\n;; root cell offsets\nconst int lz::SendEpConfig::_sendMsglibManagerOffset = _HEADER_WIDTH;\nconst int lz::SendEpConfig::_sendMsglibOffset = _HEADER_WIDTH + 256;\n\n;; ref[2] offsets\nconst int lz::SendEpConfig::_sendMsglibConnectionOffset = 0;\n\n;; ====================== Object Getters =====================\n\nint lz::SendEpConfig::getSendMsglib(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(lz::SendEpConfig::_sendMsglibOffset);\n}\n\n;; ====================== Object Multi-Getters =====================\n\n;; (sendMsglibManager, sendMsglib, sendMsglibConnection)\n(int, int, int) lz::SendEpConfig::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadAddressAt(lz::SendEpConfig::_sendMsglibManagerOffset),\n        selfSlice.preloadAddressAt(lz::SendEpConfig::_sendMsglibOffset),\n        selfSlice.preloadRefAt(2).cellPreloadAddressAt(lz::SendEpConfig::_sendMsglibConnectionOffset)\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/channel/interface.fc",
        "content": "#include \"callbackOpcodes.fc\";\n\n;; Opcodes\nconst int Channel::OP::SET_EP_CONFIG_OAPP = \"Channel::OP::SET_EP_CONFIG_OAPP\"c;\nconst int Channel::OP::MSGLIB_SEND_CALLBACK = \"Channel::OP::MSGLIB_SEND_CALLBACK\"c;\nconst int Channel::OP::CHANNEL_SEND = \"Channel::OP::CHANNEL_SEND\"c;\nconst int Channel::OP::CHANNEL_COMMIT_PACKET = \"Channel::OP::CHANNEL_COMMIT_PACKET\"c;\nconst int Channel::OP::LZ_RECEIVE_PREPARE = \"Channel::OP::LZ_RECEIVE_PREPARE\"c;\nconst int Channel::OP::DEPOSIT_ZRO = \"Channel::OP::DEPOSIT_ZRO\"c;\nconst int Channel::OP::NILIFY = \"Channel::OP::NILIFY\"c;\nconst int Channel::OP::BURN = \"Channel::OP::BURN\"c;\nconst int Channel::OP::FORCE_ABORT = \"Channel::OP::FORCE_ABORT\"c;\nconst int Channel::OP::LZ_RECEIVE_LOCK = \"Channel::OP::LZ_RECEIVE_LOCK\"c;\nconst int Channel::OP::SYNC_MSGLIB_CONNECTION = \"Channel::OP::SYNC_MSGLIB_CONNECTION\"c;\nconst int Channel::OP::LZ_RECEIVE_EXECUTE_CALLBACK = \"Channel::OP::LZ_RECEIVE_EXECUTE_CALLBACK\"c;\nconst int Channel::OP::NOTIFY_PACKET_EXECUTED = \"Channel::OP::NOTIFY_PACKET_EXECUTED\"c;\nconst int Channel::OP::EMIT_LZ_RECEIVE_ALERT = \"Channel::OP::EMIT_LZ_RECEIVE_ALERT\"c;\n\n;; EVENTS\nconst int Channel::event::EP_CFG_OAPP_SET = \"Channel::event::EP_CFG_OAPP_SET\"u;\nconst int Channel::event::PACKET_SENT = \"Channel::event::PACKET_SENT\"u;\nconst int Channel::event::PACKET_COMMITTED = \"Channel::event::PACKET_COMMITTED\"u;\nconst int Channel::event::PACKET_NILIFIED = \"Channel::event::PACKET_NILIFIED\"u;\nconst int Channel::event::PACKET_BURNED = \"Channel::event::PACKET_BURNED\"u;\nconst int Channel::event::DELIVERED = \"Channel::event::DELIVERED\"u;\nconst int Channel::event::LZ_RECEIVE_ALERT = \"Channel::event::LZ_RECEIVE_ALERT\"u;\nconst int Channel::event::NOT_EXECUTABLE = \"Channel::event::NOT_EXECUTABLE\"u;\nconst int Channel::event::ZRO_DEPOSITED = \"Channel::event::ZRO_DEPOSITED\"u;\n\n;; ERRORS\nconst int Channel::ERROR::onlyEndpoint = 129;\nconst int Channel::ERROR::onlyOApp = 130;\nconst int Channel::ERROR::onlyApprovedSendMsglib = 131;\nconst int Channel::ERROR::onlyApprovedReceiveMsglib = 132;\nconst int Channel::ERROR::invalidNonce = 133;\nconst int Channel::ERROR::cannotAbortSend = 134;\nconst int Channel::ERROR::sendAborted = 135;\nconst int Channel::ERROR::notEnoughNative = 136;\nconst int Channel::ERROR::notEnoughZroToken = 137;\nconst int Channel::ERROR::sendQueueCongested = 138;\nconst int Channel::ERROR::notEnoughZroTokenBalance = 139;\nconst int Channel::ERROR::notCommittable = 140;\nconst int Channel::ERROR::notExecutable = 141;\nconst int Channel::ERROR::notExecuting = 142;\nconst int Channel::ERROR::wrongPath = 143;\nconst int Channel::ERROR::MsglibBlocked = 144;\nconst int Channel::NO_ERROR = 0;\n\n;; States for view function and packet executability management\nconst int ExecutionStatus::uncommitted = 0;\nconst int ExecutionStatus::committedNotExecutable = 1;\nconst int ExecutionStatus::executable = 2;\nconst int ExecutionStatus::executed = 3;\nconst int ExecutionStatus::executing = 4; ;; new state\nconst int ExecutionStatus::committed = 8; ;; only used internally\n\nconst int ExecutionQueue::uncommitted = 0;\nconst int ExecutionQueue::executing = 1;\nconst int ExecutionQueue::committed = 2;\n\nconst int SendRequestQueue::sending = 1;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/interfaces.fc",
        "content": "#include \"channel/interface.fc\";\n#include \"controller/interface.fc\";\n#include \"endpoint/interface.fc\";\n#include \"msglibs/interface.fc\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/lz/EpConfig.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; ERRORS\nconst int lz::EpConfig::ERROR::sameMsglib = 1025;\nconst int lz::EpConfig::ERROR::invalidTimeoutExpiry = 1026;\nconst int lz::EpConfig::ERROR::invalidTimeoutReceiveMsglib = 1027;\nconst int lz::EpConfig::VALID = 42069 & ERRORCODE_MASK;\n\n;; required storage name\nconst int lz::EpConfig::NAME = \"EpConfig\"u;\n\n;; field names\nconst int lz::EpConfig::isNull = 0;\nconst int lz::EpConfig::sendMsglibManager = 1;\nconst int lz::EpConfig::sendMsglib = 2;\nconst int lz::EpConfig::sendMsglibConnection = 3;\nconst int lz::EpConfig::receiveMsglib = 4;\nconst int lz::EpConfig::receiveMsglibConnection = 5;\nconst int lz::EpConfig::timeoutReceiveMsglib = 6;\nconst int lz::EpConfig::timeoutReceiveMsglibConnection = 7;\nconst int lz::EpConfig::timeoutReceiveMsglibExpiry = 8;\n\ncell lz::EpConfig::NewWithConnection(\n    int isNull,\n    int sendMsglibManager,\n    int sendMsglib,\n    int sendMsglibConnection,\n    int receiveMsglib,\n    int receiveMsglibConnection,\n    int timeoutReceiveMsglib,\n    int timeoutReceiveMsglibConnection,\n    int timeoutReceiveMsglibExpiry\n) impure inline method_id {\n    return cl::declare(\n        lz::EpConfig::NAME,\n        unsafeTuple([\n            [cl::t::bool, isNull],                            ;; lz::EpConfig::isNull\n            [cl::t::address, sendMsglibManager],              ;; lz::EpConfig::sendMsglibManager\n            [cl::t::address, sendMsglib],                     ;; lz::EpConfig::sendMsglib\n            [cl::t::address, sendMsglibConnection],           ;; lz::EpConfig::sendMsglibConnection\n            [cl::t::address, receiveMsglib],                  ;; lz::EpConfig::receiveMsglib\n            [cl::t::address, receiveMsglibConnection],        ;; lz::EpConfig::receiveMsglibConnection\n            [cl::t::address, timeoutReceiveMsglib],           ;; lz::EpConfig::timeoutReceiveMsglib\n            [cl::t::address, timeoutReceiveMsglibConnection], ;; lz::EpConfig::timeoutReceiveMsglibConnection\n            [cl::t::uint64, timeoutReceiveMsglibExpiry]       ;; lz::EpConfig::timeoutReceiveMsglibExpiry\n        ])\n    );\n}\n\ncell lz::EpConfig::New(\n    int isNull,\n    int sendMsglibManager,\n    int sendMsglib,\n    int receiveMsglib,\n    int timeoutReceiveMsglib,\n    int timeoutReceiveMsglibExpiry\n) impure inline method_id {\n    return lz::EpConfig::NewWithConnection(\n        isNull,\n        sendMsglibManager,\n        sendMsglib,\n        NULLADDRESS,\n        receiveMsglib,\n        NULLADDRESS,\n        timeoutReceiveMsglib,\n        NULLADDRESS,\n        timeoutReceiveMsglibExpiry\n    );\n}\n\ncell lz::EpConfig::NewWithDefaults() impure inline method_id {\n    return lz::EpConfig::NewWithConnection(\n        true,\n        NULLADDRESS,\n        NULLADDRESS,\n        NULLADDRESS,\n        NULLADDRESS,\n        NULLADDRESS,\n        NULLADDRESS,\n        NULLADDRESS,\n        0\n    );\n}\n\n;; ====================== Object Multi-Getters =====================\n\n;; in root cell\nconst int lz::EpConfig::_isNullOffset = _HEADER_WIDTH;\nconst int lz::EpConfig::_sendMsglibManagerOffset = lz::EpConfig::_isNullOffset + 1;\nconst int lz::EpConfig::_sendMsglibOffset = lz::EpConfig::_sendMsglibManagerOffset + 256;\n\n;; in ref[2]\nconst int lz::EpConfig::_sendMsglibConnectionOffset = 0;\nconst int lz::EpConfig::_receiveMsglibOffset = lz::EpConfig::_sendMsglibConnectionOffset + 256;\nconst int lz::EpConfig::_receiveMsglibConnectionOffset = lz::EpConfig::_receiveMsglibOffset + 256;\n\n;; in ref[3]\nconst int lz::EpConfig::_timeoutReceiveMsglibOffset = 0;\nconst int lz::EpConfig::_timeoutReceiveMsglibConnectionOffset = lz::EpConfig::_timeoutReceiveMsglibOffset + 256;\nconst int lz::EpConfig::_timeoutReceiveMsglibExpiryOffset = lz::EpConfig::_timeoutReceiveMsglibConnectionOffset + 256;\n\n;; (isNull, sendMsglibManager, sendMsglib, sendMsglibConnection)\n(int, int, int, int) lz::EpConfig::deserializeSendConfig(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadBoolAt(lz::EpConfig::_isNullOffset),\n        selfSlice.preloadAddressAt(lz::EpConfig::_sendMsglibManagerOffset),\n        selfSlice.preloadAddressAt(lz::EpConfig::_sendMsglibOffset),\n        selfSlice.preloadRefAt(2).cellPreloadAddressAt(lz::EpConfig::_sendMsglibConnectionOffset)\n    );\n}\n\n;; (isNull, receiveMsglibConnection)\n(int, int) lz::EpConfig::deserializeReceiveConfig(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadBoolAt(lz::EpConfig::_isNullOffset),\n        selfSlice.preloadRefAt(2).cellPreloadAddressAt(lz::EpConfig::_receiveMsglibConnectionOffset)\n    );\n}\n\n;; ====================== Object Validators =====================\n\nint lz::EpConfig::isValid(cell $epConfig) impure inline {\n    int receiveMsglib = $epConfig.cl::get<address>(lz::EpConfig::receiveMsglib);\n    int timeoutReceiveMsglib = $epConfig.cl::get<address>(lz::EpConfig::timeoutReceiveMsglib);\n    int timeoutReceiveMsglibExpiry = $epConfig.cl::get<uint64>(lz::EpConfig::timeoutReceiveMsglibExpiry);\n\n    if ((timeoutReceiveMsglib == NULLADDRESS) & (timeoutReceiveMsglibExpiry != 0)) {\n        ;; If the timeout receive msglib is null, the expiry must be 0\n        return lz::EpConfig::ERROR::invalidTimeoutReceiveMsglib;\n    } elseif ((timeoutReceiveMsglib != NULLADDRESS) & (timeoutReceiveMsglibExpiry <= now())) {\n        ;; if the timeout receive msglib is not null, the expiry must be in the future\n        return lz::EpConfig::ERROR::invalidTimeoutExpiry;\n    } elseif ((receiveMsglib != NULLADDRESS) & (receiveMsglib == timeoutReceiveMsglib)) {\n        ;; the receive msglib and timeout receive msglib must be different\n        return lz::EpConfig::ERROR::sameMsglib;\n    }\n\n    return lz::EpConfig::VALID;\n}\n\ncell lz::EpConfig::sanitize(cell $epConfig) impure {\n    cell $sanitizedEpConfig = lz::EpConfig::NewWithConnection(\n        $epConfig.cl::get<bool>(lz::EpConfig::isNull),\n        $epConfig.cl::get<address>(lz::EpConfig::sendMsglibManager),\n        $epConfig.cl::get<address>(lz::EpConfig::sendMsglib),\n        $epConfig.cl::get<address>(lz::EpConfig::sendMsglibConnection),\n        $epConfig.cl::get<address>(lz::EpConfig::receiveMsglib),\n        $epConfig.cl::get<address>(lz::EpConfig::receiveMsglibConnection),\n        $epConfig.cl::get<address>(lz::EpConfig::timeoutReceiveMsglib),\n        $epConfig.cl::get<address>(lz::EpConfig::timeoutReceiveMsglibConnection),\n        $epConfig.cl::get<uint64>(lz::EpConfig::timeoutReceiveMsglibExpiry)\n    );\n    int validity = lz::EpConfig::isValid($sanitizedEpConfig);\n    throw_if(validity, validity != lz::EpConfig::VALID);\n    return $sanitizedEpConfig;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/dataStructures/PipelinedOutOfOrder.fc",
        "content": ";;; ==============================================================================\n;; Pipelined Out-of-Order data structure\n;; this data structure defines a bitmap that is used to track a stream of\n;; commands that are executed out-of-order in a bounded-depth pipeline\n#include \"../classlib.fc\";\n\nconst int POOO::NAME = \"POOO\"u;\n\nconst int POOO::nextEmpty = 0;\nconst int POOO::bitmap = 1;\n\nconst int POOO::ERROR::negativeIndex = 1153;\n\ncell POOO::New() impure inline method_id {\n    return cl::declare(\n        POOO::NAME,\n        unsafeTuple([\n            [cl::t::uint64, 1], ;; nextEmpty\n            [cl::t::cellRef, begin_cell().store_zeroes(MAX_CELL_BITS).end_cell()] ;; bitmap\n        ])\n    );\n}\n\nconst int POOO::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 2);\nconst int POOO::_headerFillerBits = _HEADER_WIDTH - POOO::_headerInfoBits;\nconst int POOO::_headerInfo = 92590899976783941628;\n\ncell POOO::buildFull(int nextEmpty, cell bitmap) impure inline {\n    return begin_cell()\n        .store_uint(POOO::_headerInfo, POOO::_headerInfoBits)       ;; header info\n        .store_ones(POOO::_headerFillerBits)                        ;; header filler\n        .store_uint64(nextEmpty)                                    ;; nextEmpty\n        .store_ref(bitmap)                                          ;; bitmap\n        .end_cell();\n}\n\n;; ========================== Object Getters ==========================\n\nconst int POOO::_nextEmptyOffset = _HEADER_WIDTH;\n\nint POOO::getNextEmpty(cell $self) impure inline {\n    return $self.cellPreloadUint64At(POOO::_nextEmptyOffset);\n}\n\nint POOO::maxSettableBit(cell $self) impure inline {\n    return $self.POOO::getNextEmpty() + MAX_CELL_BIT_INDEX;\n}\n\n;; ========================== Object Multi-Getters ==========================\n\n;; returns (nextEmpty, bitmap.slice)\n(int, slice) POOO::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadUint64At(POOO::_nextEmptyOffset),\n        selfSlice.preloadRefSliceAt(0)\n    );\n}\n\n;; ========================== Object Utils ==========================\n\nint POOO::isBitSet(cell $self, int absoluteIdx) impure inline {\n    (int nextEmpty, slice bitmap) = POOO::deserialize($self);\n    int relativeIdx = absoluteIdx - nextEmpty;\n    return bitmap.preloadBoolAt(relativeIdx);\n}\n\n;; ========================== Object Setters ==========================\n\n;; Algorithm:\n;; 1. Extract the first `index` bits from the original bitmap.\n;; 2. Append a '1' bit to the extracted bits.\n;; 3. Append the remaining bits from the original bitmap after the first `index` bits to form a new bitmap.\n\n;; Returns:\n;; 1. The number of leading ones (`leadingOnes`).\n;; 2. A new cell that contains:\n;;    - The remaining bits after the leading ones from the original bitmap.\n;;    - A number of trailing zero bits equal to `leadingOnes`.\n\n;; Parameters:\n;; - `bitmapCell`: The original bitmap in the form of a cell.\n;; - `index`: The position up to which the first part of the bitmap is extracted.\ncell POOO::set(cell $self, int absoluteIndex) impure inline method_id {\n    throw_if(POOO::ERROR::negativeIndex, absoluteIndex < 0);\n\n    (int nextEmpty, slice bitmapSlice) = POOO::deserialize($self);\n    if (absoluteIndex < nextEmpty) {\n        return $self;\n    }\n\n    int index = absoluteIndex - nextEmpty;\n\n    (int leadingOnes, slice remainingBitmap) = ldones(\n        begin_cell()\n            .store_slice(scutfirst(bitmapSlice, index, 0))\n            .store_uint(1, 1)\n            .store_slice(scutlast(bitmapSlice, MAX_CELL_BITS - index - 1, 0))\n            .as_slice()\n    );\n    \n    return POOO::buildFull(\n        nextEmpty + leadingOnes,\n        begin_cell()\n            .store_slice(remainingBitmap)\n            .store_zeroes(leadingOnes)\n        .end_cell()\n    );\n}\n\ncell POOO::unsafeSetBits(cell $self, int start, int end) impure inline method_id {\n    (int nextEmpty, slice bitmapSlice) = POOO::deserialize($self);\n\n    int startIndex = start - nextEmpty;\n    int endIndex = end - nextEmpty;\n\n    (int leadingOnes, slice remainingBitmap) = ldones(\n        begin_cell()\n            .store_slice(scutfirst(bitmapSlice, startIndex, 0))\n            .store_ones(endIndex - startIndex)\n            .store_slice(scutlast(bitmapSlice, MAX_CELL_BITS - endIndex, 0))\n            .as_slice()\n    );\n    \n    return POOO::buildFull(\n        nextEmpty + leadingOnes,\n        begin_cell()\n            .store_slice(remainingBitmap)\n            .store_zeroes(leadingOnes)\n        .end_cell()\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/channel/storage.fc",
        "content": "#include \"../../funC++/dataStructures/PipelinedOutOfOrder.fc\";\n\n#include \"../../classes/lz/EpConfig.fc\";\n\n#include \"../core/baseStorage.fc\";\n\n;; maximum concurrent sendable inflight send requests\n;; must be low to avoid permanent bricking\nconst int Channel::MAX_SEND_SLOTS = MAX_CELL_BITS;\n\n;; required object name\nconst int Channel::NAME = \"channel\"u;\n\n;; field names\n;; Init state (sharding key)\nconst int Channel::baseStorage = 0;\nconst int Channel::path = 1;\n\n;; Both send and receive channel state\nconst int Channel::endpointAddress = 2;\nconst int Channel::epConfigOApp = 3;\n\n;; Send channel state\nconst int Channel::outboundNonce = 4;\nconst int Channel::sendRequestQueue = 5;\nconst int Channel::lastSendRequestId = 6;\n\n;; Receive channel state\nconst int Channel::commitPOOO = 7;\n\n;; Used to track the commit verification queue / capacity\nconst int Channel::executePOOO = 8;\nconst int Channel::executionQueue = 9;\n\nconst int Channel::zroBalance = 10;\n\n;; @owner manager\ncell Channel::New(int owner, cell $path, int endpointAddress) impure inline method_id {\n    return cl::declare(\n        Channel::NAME,\n        unsafeTuple([\n            [cl::t::objRef, BaseStorage::New(owner)],           ;; Channel::baseStorage\n            [cl::t::objRef, $path],                             ;; Channel::path\n            [cl::t::address, endpointAddress],                  ;; Channel::endpointAddress\n            [cl::t::objRef, lz::EpConfig::NewWithDefaults()],   ;; Channel::epConfigOApp\n            [cl::t::uint64, 0],                                 ;; Channel::outboundNonce\n            [cl::t::objRef, cl::nullObject()],                 ;; Channel::sendRequestQueue (DICQ)\n            [cl::t::uint64, 0],                                 ;; Channel::sendRequestId\n            [cl::t::objRef, POOO::New()],                       ;; Channel::commitPOOO\n            [cl::t::objRef, POOO::New()],                       ;; Channel::executePOOO\n            [cl::t::cellRef, cl::nullObject()],                 ;; Channel::executionQueue (DICQ)\n            [cl::t::coins, 0]                                   ;; Channel::zroBalance\n        ])\n    );\n}\n\n;; ====================== Object Accessors =====================\n\nconst int Channel::_endpointAddressOffset = _HEADER_WIDTH;\nconst int Channel::_outboundNonceOffset = Channel::_endpointAddressOffset + 256;\nconst int Channel::_sendRequestIdOffset = Channel::_outboundNonceOffset + 64;\nconst int Channel::_zroBalanceOffset = Channel::_sendRequestIdOffset + 64;\nconst int Channel::_sliceBits = Channel::_zroBalanceOffset + 128;\n\ncell Channel::getBaseStorage(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0);\n}\n\ncell Channel::getPath(cell $self) impure inline {\n    return $self.cellPreloadRefAt(1);\n}\n\nint Channel::getEndpointAddress(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(Channel::_endpointAddressOffset);\n}\n\ncell Channel::getCommitPOOO(cell $self) impure inline {\n    return $self.cellPreloadRefAt(2).cellPreloadRefAt(2);\n}\n\ncell Channel::getExecutePOOO(cell $self) impure inline {\n    return $self.cellPreloadRefAt(2).cellPreloadRefAt(3);\n}\n\ncell Channel::getExecutionQueue(cell $self) impure inline {\n    return $self.cellPreloadRefAt(3).cellPreloadRefAt(0);\n}\n\nint Channel::getZroBalance(cell $self) impure inline {\n    return $self.cellPreloadCoinsAt(Channel::_zroBalanceOffset);\n}\n\n;; (epConfigOApp, commitPOOO, ExecutePOOO, executionQueue)\n(cell, cell, cell, cell) Channel::getCommitPacketInformation(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    slice ref2 = selfSlice.preloadRefSliceAt(2);\n    return (\n        ref2.preloadRefAt(0),\n        ref2.preloadRefAt(2),\n        ref2.preloadRefAt(3),\n        selfSlice.preloadRefAt(3).cellPreloadRefAt(0)\n    );\n}\n\n;; (executePOOO, executionQueue, path)\n(cell, cell, cell) Channel::getExecutePOOOAndExecutionQueueAndPath(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(2).cellPreloadRefAt(3),\n        selfSlice.preloadRefAt(3).cellPreloadRefAt(0),\n        selfSlice.preloadRefAt(1)\n    );\n}\n\n;; (epConfigOapp, path, sendRequestQueue, lastSendRequestId)\n(cell, cell, cell, int) Channel::getSendInformation(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    slice ref2 = selfSlice.preloadRefSliceAt(2);\n    return (\n        ref2.preloadRefAt(0),\n        selfSlice.preloadRefAt(1),\n        ref2.preloadRefAt(1),\n        selfSlice.preloadUint64At(Channel::_sendRequestIdOffset)\n    );\n}\n\n;; (sendRequestQueue, zroBalance, path, outBoundNonce)\n(cell, int, cell, int) Channel::getSendCallbackInformation(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(2).cellPreloadRefAt(1),                           ;; sendRequestQueue\n        selfSlice.preloadCoinsAt(Channel::_zroBalanceOffset),                    ;; zroBalance\n        selfSlice.preloadRefAt(1),                                               ;; path\n        selfSlice.preloadUint64At(Channel::_outboundNonceOffset)                 ;; outboundNonce\n    );\n}\n\n;; (executionQueue, commitPOOO, path)\n(cell, cell, cell) Channel::getLzReceiveLockInformation(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(3).cellPreloadRefAt(0),       ;; executionQueue\n        selfSlice.preloadRefAt(2).cellPreloadRefAt(2),       ;; commitPOOO\n        selfSlice.preloadRefAt(1)                            ;; path\n    );\n}\n\n;; ====================== Object Modifiers =====================\n\ncell Channel::setSendRequestQueue(cell $self, cell $sendRequestQueue) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    slice ref2Slice = selfSlice.preloadRefSliceAt(2);\n    cell newRef2 = begin_cell()\n        .store_slice(ref2Slice.scutfirst(0, 1))\n        .store_ref($sendRequestQueue)\n        .store_slice(ref2Slice.scutlast(0, 2))\n        .end_cell();\n\n    return begin_cell()\n        .store_slice(selfSlice.scutfirst(Channel::_sliceBits, 2)) ;; store all the bits and the first 2 refs [0, 1]\n        .store_ref(newRef2) ;; store the new ref[2] which includes the new sendRequestQueue\n        .store_slice(selfSlice.scutlast(0, 1)) ;; store the last ref, ref[3]\n        .end_cell();\n}\n\ncell Channel::setExecutePOOO(cell $self, cell $executePOOO) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    slice ref2Slice = selfSlice.preloadRefSliceAt(2);\n    cell newRef2 = begin_cell()\n        .store_slice(ref2Slice.scutfirst(0, 3))\n        .store_ref($executePOOO)\n        .end_cell();\n\n    return begin_cell()\n        .store_slice(selfSlice.scutfirst(Channel::_sliceBits, 2)) ;; store all the bits and the first 2 refs [0, 1]\n        .store_ref(newRef2) ;; store the new ref[2] which includes the new executePOOO\n        .store_slice(selfSlice.scutlast(0, 1)) ;; store the last ref, ref[3]\n        .end_cell();\n}\n\ncell Channel::setExecutionQueue(cell $self, cell $executionQueue) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    cell newRef3 = begin_cell()\n        .store_ref($executionQueue)\n        .end_cell();\n\n    return begin_cell()\n        .store_slice(selfSlice.scutfirst(Channel::_sliceBits, 3)) ;; store all the bits and the first 3 refs [0, 1, 2]\n        .store_ref(newRef3) ;; store the new ref[3] which includes the new executionQueue\n        .end_cell();\n}\n\n;; ====================== Object Composite Modifiers =====================\n\ncell Channel::setSendRequestQueueAndLastSendRequestId(cell $self, int lastSendRequestId, cell $sendRequestQueue) impure inline {\n    slice selfSlice = $self.begin_parse();\n    slice ref2Slice = selfSlice.preloadRefSliceAt(2);\n\n    cell newRef2 = begin_cell()\n        .store_slice(ref2Slice.scutfirst(0, 1))\n        .store_ref($sendRequestQueue)\n        .store_slice(ref2Slice.scutlast(0, 2))\n        .end_cell();\n\n    return begin_cell()\n        .store_slice(selfSlice.scutfirst(Channel::_sendRequestIdOffset, 2)) ;; store all the bits before the lastSendRequestId and the first 2 refs [0, 1]\n        .store_uint64(lastSendRequestId) ;; store the new lastSendRequestId = ref[2]\n        .store_ref(newRef2) ;; store the new ref[2] which includes the new sendRequestQueue\n        .store_slice(selfSlice.sskipfirst(Channel::_sendRequestIdOffset + 64, 3)) ;; store the whatever was after the lastSendRequestId and the last ref, only giving back ref[3]\n        .end_cell();\n}\n\ncell Channel::setOutboundNonceAndZroBalance(cell $self, int outboundNonce, int zroBalance) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    return begin_cell()\n        .store_slice(\n            selfSlice.scutfirst(Channel::_outboundNonceOffset, 4)\n        ) ;; store whatever's behind the outbound nonce and all the refs\n        .store_uint64(outboundNonce)\n        .store_slice(\n            selfSlice.subslice(\n                Channel::_sendRequestIdOffset, ;; start bits\n                0, ;; start refs\n                64, ;; bits\n                0 ;; refs\n            )\n        ) ;; store the next 64 bits = sendRequestId\n        .store_uint128(zroBalance)\n        .end_cell();\n}\n\ncell Channel::setCommitPOOOAndExecutionQueue(cell $self, cell $commitPOOO, cell $executionQueue) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    slice ref2Slice = selfSlice.preloadRefSliceAt(2);\n    cell newRef2 = begin_cell()\n        .store_slice(ref2Slice.scutfirst(0, 2)) ;; store the first 2 refs [0, 1]\n        .store_ref($commitPOOO)                   ;; store the new commitPOOO = ref[2]\n        .store_slice(ref2Slice.scutlast(0, 1)) ;; store the last ref, ref[3]\n        .end_cell();\n\n    cell newRef3 = begin_cell()\n        .store_ref($executionQueue) ;; store the new executionQueue = ref[0]\n        .end_cell();\n\n    return begin_cell()\n        .store_slice(selfSlice.scutfirst(Channel::_sliceBits, 2)) ;; store all the bits and the first 3 refs [0, 1]  \n        .store_ref(newRef2) ;; store the new ref[2] which includes the new commitPOOO\n        .store_ref(newRef3) ;; store the new ref[3] which includes the new executionQueue\n        .end_cell();  \n}\n\ncell Channel::setPath(cell $self, cell $path) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return begin_cell()\n        .store_ref(selfSlice.preloadRefAt(0))\n        .store_ref($path) ;; change ref 1\n        .store_slice(sskipfirst(selfSlice, 0, 2)) ;; rest of it stays the same\n        .end_cell();\n}\n\ncell Channel::sanitize(cell $self) impure inline {\n    cell $baseStorage = $self.cl::get<cellRef>(Channel::baseStorage);\n    return Channel::New(\n        $baseStorage.cl::get<address>(BaseStorage::owner),\n        $self.cl::get<cellRef>(Channel::path),\n        $self.cl::get<address>(Channel::endpointAddress)\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/MdObj.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::MdObj::NAME = \"MdObj\"u;\n\n;; field names\nconst int md::MdObj::md = 0;\nconst int md::MdObj::obj = 1;\n\ncell md::MdObj::New(cell $md, cell $obj) impure inline method_id {\n    return cl::declare(\n        md::MdObj::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $md],   ;; md::MdObj::md\n            [cl::t::objRef, $obj]   ;; md::MdObj::obj\n        ])\n    );\n}\n\n\n;; ========================== Object Builders ==========================\nconst int md::MdObj::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 2);\nconst int md::MdObj::_headerFillerBits = _HEADER_WIDTH - md::MdObj::_headerInfoBits;\nconst int md::MdObj::_headerInfo = 22842038364999638994941;\n\ncell md::MdObj::build(cell $md, cell $obj) impure inline {\n    return begin_cell()\n        .store_uint(md::MdObj::_headerInfo, md::MdObj::_headerInfoBits) ;; header info\n        .store_ones(md::MdObj::_headerFillerBits)                       ;; header filler\n        .store_ref($md)                                                  ;; ref[0]\n        .store_ref($obj)                                                 ;; ref[1]\n        .end_cell();\n} \n\n;; ========================== Object Multi-Getters ==========================\n\ncell md::MdObj::getMd(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0);\n}\n\ncell md::MdObj::getObj(cell $self) impure inline {\n    return $self.cellPreloadRefAt(1);\n}\n\n(cell, cell) md::MdObj::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(0),\n        selfSlice.preloadRefAt(1)\n    );\n}\n\ncell md::MdObj::sanitize(cell $mdObj) impure {\n    cell $md = $mdObj.cl::get<objRef>(md::MdObj::md);\n    cell $obj = $mdObj.cl::get<objRef>(md::MdObj::obj);\n\n    return md::MdObj::New($md, $obj);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/CoinsAmount.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::CoinsAmount::NAME = \"coinsAmt\"u;\n\n;; field names\nconst int md::CoinsAmount::amount = 0;\n\ncell md::CoinsAmount::New(int amount) impure inline method_id {\n    return cl::declare(\n        md::CoinsAmount::NAME,\n        unsafeTuple([\n            [cl::t::coins, amount] ;; md::CoinsAmount::amount\n        ])\n    );\n}\n\n;; ========================== Sanitize ==========================\n\ncell md::CoinsAmount::sanitize(cell $self) impure {\n    int amount = $self.cl::get<coins>(md::CoinsAmount::amount);\n\n    return md::CoinsAmount::New(amount);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/ExtendedMd.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::ExtendedMd::NAME = \"extendedMd\"u;\n\n;; field names\nconst int md::ExtendedMd::md = 0;\nconst int md::ExtendedMd::obj = 1;\nconst int md::ExtendedMd::forwardingAddress = 2;\n\ncell md::ExtendedMd::New(cell $md, cell $obj, int forwardingAddress) impure inline method_id {\n    return cl::declare(\n        md::ExtendedMd::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $md],                ;; md::ExtendedMd::md\n            [cl::t::objRef, $obj],               ;; md::ExtendedMd::obj\n            [cl::t::address, forwardingAddress]  ;; md::ExtendedMd::forwardingAddress\n        ])\n    );\n}\n\nconst int md::ExtendedMd::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 3);\nconst int md::ExtendedMd::_headerFillerBits = _HEADER_WIDTH - md::ExtendedMd::_headerInfoBits;\nconst int md::ExtendedMd::_headerInfo = 8632157695553525919024050567799415113083;\n\ncell md::ExtendedMd::build(cell $md, cell $obj, int forwardingAddress) impure inline {\n    return begin_cell()\n        .store_uint(md::ExtendedMd::_headerInfo, md::ExtendedMd::_headerInfoBits)     ;; header info\n        .store_ones(md::ExtendedMd::_headerFillerBits)                                ;; header filler\n        .store_ref($md)                                                                ;; md::ExtendedMd::md\n        .store_ref($obj)                                                               ;; md::ExtendedMd::obj\n        .store_uint256(forwardingAddress)                                              ;; md::ExtendedMd::forwardingAddress\n        .end_cell();\n}   \n\n;; ====================== Object Getters =====================\n\nconst int md::ExtendedMd::_forwardingAddressOffset = _HEADER_WIDTH;\n\ncell md::ExtendedMd::getObj(cell $self) impure inline {\n    return $self.cellPreloadRefAt(1);\n}\n\n;; ====================== Object Multi-Getters =====================\n\n(cell, int) md::ExtendedMd::getMdAndForwardingAddress(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(0),\n        selfSlice.preloadAddressAt(md::ExtendedMd::_forwardingAddressOffset)\n    );\n}\n\n(cell, cell, int) md::ExtendedMd::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(0),\n        selfSlice.preloadRefAt(1),\n        selfSlice.preloadAddressAt(md::ExtendedMd::_forwardingAddressOffset)\n    );\n}\n\n;; ====================== Sanitize =====================\n\ncell md::ExtendedMd::sanitize(cell $extendedMd) impure {\n    cell $md = $extendedMd.cl::get<objRef>(md::ExtendedMd::md);\n    cell $obj = $extendedMd.cl::get<objRef>(md::ExtendedMd::obj);\n    int forwardingAddress = $extendedMd.cl::get<address>(md::ExtendedMd::forwardingAddress);\n\n    return md::ExtendedMd::New($md, $obj, forwardingAddress);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/lz/Path.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int lz::Path::NAME = \"path\"u;\n\n;; field names\nconst int lz::Path::srcEid = 0;\nconst int lz::Path::srcOApp = 1;\nconst int lz::Path::dstEid = 2;\nconst int lz::Path::dstOApp = 3;\n\n;; In all blockchains with atomic cross-contract call, we can use src/dst/srcOApp/dstOApp\n;; because the send channel doesn't exist (it's just a nonce).\n;; In TON, we need both send/receive channels, so we use srcOApp/dstOApp to provide\n;; a context-free way to refer to the two ends of the channel.\n;; The direction is inferred by the context of the contract (send vs receive).\n;; The srcOApp is the 256-bit hashpart of a standard address.\ncell lz::Path::New(int srcEid, int srcOApp, int dstEid, int dstOApp) impure inline method_id {\n    return cl::declare(\n        lz::Path::NAME,\n        unsafeTuple([\n            [cl::t::uint32, srcEid],    ;; lz::Path::srcEid\n            [cl::t::address, srcOApp],  ;; lz::Path::srcOApp\n            [cl::t::uint32, dstEid],    ;; lz::Path::dstEid\n            [cl::t::address, dstOApp]   ;; lz::Path::dstOApp\n        ])\n    );\n}\n\nconst int lz::Path::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 4);\nconst int lz::Path::_headerFillerBits = _HEADER_WIDTH - lz::Path::_headerInfoBits;\nconst int lz::Path::_headerInfo = 8903714975572488637007080065659;\n\n;; this function is unused by the protocol but will be used by OApps\ncell lz::Path::build(int srcEid, int srcOApp, int dstEid, int dstOApp) impure inline {\n    return begin_cell()\n        .store_uint(lz::Path::_headerInfo, lz::Path::_headerInfoBits)    ;; header info\n        .store_ones(lz::Path::_headerFillerBits)                         ;; header filler\n        .store_uint32(srcEid)\n        .store_uint256(srcOApp)\n        .store_uint32(dstEid)\n        .store_uint256(dstOApp)\n        .end_cell();\n}\n\ncell lz::Path::endpointPath(int srcEid, int dstEid) impure inline {\n    return lz::Path::New(srcEid, NULLADDRESS, dstEid, NULLADDRESS);\n}\n\ncell lz::Path::reverse(cell $path) inline {\n    int srcEid = $path.cl::get<uint32>(lz::Path::srcEid);\n    int srcOapp = $path.cl::get<address>(lz::Path::srcOApp);\n    int dstEid = $path.cl::get<uint32>(lz::Path::dstEid);\n    int dstOapp = $path.cl::get<address>(lz::Path::dstOApp);\n    return lz::Path::New(dstEid, dstOapp, srcEid, srcOapp);\n}\n\n;; ====================== Object Getters =====================\n\nconst int lz::Path::_srcEidOffset = _HEADER_WIDTH;\nconst int lz::Path::_srcOAppOffset = lz::Path::_srcEidOffset + 32;\nconst int lz::Path::_dstEidOffset = lz::Path::_srcOAppOffset + 256;\nconst int lz::Path::_dstOAppOffset = lz::Path::_dstEidOffset + 32;\n\nint lz::Path::getSrcOApp(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(lz::Path::_srcOAppOffset);\n}\n\n;; ====================== Storage Composite Accessors =====================\n\nint lz::Path::getDstEid(cell $self) impure inline {\n    return $self.cellPreloadUint32At(lz::Path::_dstEidOffset);\n}\n\n;; (srcEid, dstEid)\n(int, int) lz::Path::getEidAndDstEid(cell $self) impure inline {\n    slice $selfSlice = $self.begin_parse();\n    return (\n        $selfSlice.preloadUint32At(lz::Path::_srcEidOffset),\n        $selfSlice.preloadUint32At(lz::Path::_dstEidOffset)\n    );\n}\n\n;; (srcEid, srcOApp, dstEid, dstOApp)\n(int, int, int, int) lz::Path::deserialize(cell $self) impure inline {\n    slice $selfSlice = $self.begin_parse();\n    return (\n        $selfSlice.preloadUint32At(lz::Path::_srcEidOffset),\n        $selfSlice.preloadAddressAt(lz::Path::_srcOAppOffset),\n        $selfSlice.preloadUint32At(lz::Path::_dstEidOffset),\n        $selfSlice.preloadAddressAt(lz::Path::_dstOAppOffset)\n    );\n}\n\n;; ====================== Object Mutators =====================\n\n;; low-level optimized version\n;; original: 12k gas\n;; optimized: 1k gas\ncell lz::Path::optimizedReverse(cell $path) impure inline {\n    slice pathSlice = $path.begin_parse();\n    return begin_cell()\n        .store_slice(pathSlice.scutfirst(_HEADER_WIDTH, 0))\n        .store_slice(pathSlice.preload_bits_offset(lz::Path::_dstEidOffset, 288)) ;; 32 + 256\n        .store_slice(pathSlice.preload_bits_offset(lz::Path::_srcEidOffset, 288)) ;; eid + address\n        .end_cell();\n}\n\ncell lz::Path::sanitize(cell $path) impure {\n    return lz::Path::New(\n        $path.cl::get<uint32>(lz::Path::srcEid),\n        $path.cl::get<address>(lz::Path::srcOApp),\n        $path.cl::get<uint32>(lz::Path::dstEid),\n        $path.cl::get<address>(lz::Path::dstOApp)\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/core/baseStorage.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n#include \"../../funC++/baseInterface.fc\";\n\n;; !!! If you put this storage anywhere other than index 0 of your custom contract storage,\n;; you are gunna have a bad time\nconst int BASE_STORAGE_INDEX = 0;\n\n;; required object name\nconst int BaseStorage::NAME = \"baseStore\"u;\n\n;; field names\nconst int BaseStorage::owner = 0;\nconst int BaseStorage::authenticated = 1;\nconst int BaseStorage::initialized = 2;\nconst int BaseStorage::initialStorage = 3;\n\n;; In all blockchains with atomic cross-contract call, we can use src/dst/sender/receiver\n;; because the send channel doesn't exist (it's just a nonce).\n;; In TON, we need both send/receive channels, so we use local/remote to provide\n;; a context-free way to refer to the two ends of the channel.\n;; The direction is inferred by the context of the contract (send vs receive).\n;; The srcOApp is the 256-bit hashpart of a standard address.\ncell BaseStorage::New(int owner) impure inline method_id {\n    return cl::declare(\n        BaseStorage::NAME,\n        unsafeTuple([\n            [cl::t::address, owner], ;; BaseStorage::owner\n            [cl::t::bool, false], ;; BaseStorage::authenticated\n            [cl::t::bool, false], ;; BaseStorage::initialized\n            [cl::t::objRef, cl::nullObject()] ;; BaseStorage::initialStorage\n        ])\n    );\n}\n\nconst int BaseStorage::_ownerOffset = _HEADER_WIDTH;\nconst int BaseStorage::_authenticatedOffset = BaseStorage::_ownerOffset + 256;\nconst int BaseStorage::_initializedOffset = BaseStorage::_authenticatedOffset + 1;\n\nint BaseStorage::getOwner(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(BaseStorage::_ownerOffset);\n}\n\nint BaseStorage::getAuthenticated(cell $self) impure inline {\n    return $self.cellPreloadBoolAt(BaseStorage::_authenticatedOffset);\n}\n\nint BaseStorage::getInitialized(cell $self) impure inline {\n    return $self.cellPreloadBoolAt(BaseStorage::_initializedOffset);\n}\n\ncell BaseStorage::getInitialStorage(cell $self) impure inline {\n     return $self.cellPreloadRefAt(0);\n}\n\ncell getBaseStorage() impure inline method_id {\n    return getContractStorage().cellPreloadRefAt(BASE_STORAGE_INDEX);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/core/abstract/protocolHandler.fc",
        "content": "#include \"../../../funC++/handlerCore.fc\";\n#include \"../../../funC++/actions/call.fc\";\n#include \"../../../funC++/actions/deploy.fc\";\n#include \"../../../funC++/actions/event.fc\";\n#include \"../../../funC++/actions/payment.fc\";\n\n#include \"../baseStorage.fc\";\n\nint getOwner() impure inline {\n    return getBaseStorage().BaseStorage::getOwner();\n}\n\ncell getInitialStorage() impure inline {\n    return getBaseStorage().BaseStorage::getInitialStorage();\n}\n\n;;; ==========================================\n;; Modifiers\n() assertAuthenticated() impure inline {\n    throw_unless(\n        BaseInterface::ERROR::notAuthenticated,\n        getBaseStorage().BaseStorage::getAuthenticated()\n    );\n}\n\n() assertInitialized() impure inline {\n    throw_unless(\n        BaseInterface::ERROR::notInitialized,\n        getBaseStorage().BaseStorage::getInitialized()\n    );\n}\n\n;; assert the ctx sender is the owner of this contract\n;; expects the ctx to be populated. Does not require storage to be loaded\n() assertOwner() impure inline {\n    throw_unless(\n        BaseInterface::ERROR::onlyOwner,\n        getCaller() == getOwner()\n    );\n}\n\n;; Step 1: authenticate\n() authenticate() impure {\n    assertOwner();\n    throw_if(\n        BaseInterface::ERROR::alreadyInitialized,\n        getBaseStorage().BaseStorage::getInitialized()\n    );\n    cell $storage = getContractStorage();\n\n    setContractStorage(\n        $storage\n            .cl::set(\n                BASE_STORAGE_INDEX,\n                $storage\n                    .cl::get<objRef>(BASE_STORAGE_INDEX)\n                    .cl::set(\n                        BaseStorage::initialStorage,\n                        getContractStorage()\n                    )\n                    .cl::set(BaseStorage::authenticated, true)\n            )\n    );\n}\n\n() authenticateIfNecessary() impure inline {\n    if (getBaseStorage().BaseStorage::getAuthenticated() == false) {\n        authenticate();\n    }\n}\n\n(cell, tuple) _initialize(cell $md) impure inline;\n\n;; Step 2: initialize\ntuple initialize(cell $md) impure inline {\n    assertAuthenticated();\n    if (getBaseStorage().BaseStorage::getInitialized()) {\n        return emptyActions();\n    }\n\n    (cell $storage, tuple actions) = _initialize($md);\n\n    setContractStorage(\n        $storage\n            .cl::set(\n                BASE_STORAGE_INDEX,\n                $storage\n                    .cl::get<objRef>(BASE_STORAGE_INDEX)\n                    .cl::set(BaseStorage::initialized, true)\n            )\n    );\n\n    return actions;\n}\n\n;; declared inside of the actions/event.fc\n;; We declare it here because it saves the need for declaring initialStorage everytime we call event\ntuple _newAction<event>(int topic, cell $body) impure inline {\n    return action::event::create(topic, $body, getInitialStorage());\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/abstract/contractMainAbstract.fc",
        "content": ";; _executeOpcode is executed at the start of contractMain, after checking permissions.\n;; Each contract implements a list of opcodes, which calls a handler as the entry point\n;; of that opcode. The contract must be initialized in order to start executing opcodes.\n;; @in the opcode to execute\n;; @in the message data extracted from txnContext\n;; @out tuple of resultant actions\ntuple _executeOpcode(int op, cell $md) impure inline;\n\n;; Actions are executed after the opcode is executed. Each opcode must emit a tuple\n;; of actions, where each action is executed after the opcode is executed in order.\n;; @in the action to execute\n;; @in the value of the action\n;; @out a bool that determines if excess balance is to be sent back to the origin.\nint _executeAction(int actionType, tuple action) impure inline;\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/abstract/handlerAbstract.fc",
        "content": ";; Assert that the owner has sent an INITIALIZE opcode to this contract\n() assertInitialized() impure inline;\n\n;; Assert the identity of the caller for a given opcode\n() checkPermissions(int op, cell $md) impure inline;\n\n;; Initialize this contract\ntuple initialize(cell $md) impure inline;\n\n;; Authentication = the owner has deployed and sent at least one transaction to this contract\n;; unauthenticated contracts cannot perform any actions.\n;; Authentication enables sharded contracts to trust the identity and intention of other shards\n() authenticateIfNecessary() impure inline;\n\n;; Assert the caller is the owner of this contract\n() assertOwner() impure inline;\n\n;; Asserts permissions of caller for permissioned opcodes before executing opcode\n;; @see contractMainAbstract.fc\n() _checkPermissions(int op, cell $md) impure inline;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/handlerCore.fc",
        "content": ";;; ==========================================\n;; This file contains the utility functions for all handler functions that follow\n;; LayerZero Labs handler convention.\n;;; ==========================================\n#include \"abstract/handlerAbstract.fc\";\n\n#include \"actions/utils.fc\";\n\n#include \"baseInterface.fc\";\n\n;;; ===================REQUIRED VIRTUAL FUNCTIONS=======================\n\n(cell, tuple) preamble() impure inline {\n    return (getContractStorage(), emptyActions());\n}\n\n() checkPermissions(int op, cell $md) impure inline {\n    if (op == BaseInterface::OP::EVENT) {\n        return ();\n    } elseif (op == BaseInterface::OP::INITIALIZE) {\n        assertOwner();\n    } elseif (op == BaseInterface::OP::EMPTY) {\n        return ();\n    } else {\n        _checkPermissions(op, $md);\n    }\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/lz/ReceiveEpConfig.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int lz::ReceiveEpConfig::NAME = \"RcvEpCfg\"u;\n\n;; field names\nconst int lz::ReceiveEpConfig::receiveMsglibConnection = 0;\nconst int lz::ReceiveEpConfig::timeoutReceiveMsglibConnection = 1;\nconst int lz::ReceiveEpConfig::expiry = 2;\n\ncell lz::ReceiveEpConfig::New(\n    int receiveMsglibConnectionAddress,\n    int timeoutReceiveMsglibConnectionAddress,\n    int expiry\n) impure inline method_id {\n    return cl::declare(\n        lz::ReceiveEpConfig::NAME,\n        unsafeTuple([\n            [cl::t::address, receiveMsglibConnectionAddress],        ;; lz::ReceiveEpConfig::receiveMsglibConnection\n            [cl::t::address, timeoutReceiveMsglibConnectionAddress], ;; lz::ReceiveEpConfig::timeoutReceiveMsglibConnection\n            [cl::t::uint64, expiry]                                  ;; lz::ReceiveEpConfig::expiry\n        ])\n    );\n}\n\n;; ====================== Object Builders =====================\n\n\nconst int lz::ReceiveEpConfig::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 3);\nconst int lz::ReceiveEpConfig::_headerFillerBits = _HEADER_WIDTH - lz::ReceiveEpConfig::_headerInfoBits;\nconst int lz::ReceiveEpConfig::_headerInfo = 106946417840994430288387571463327099;\n\ncell lz::ReceiveEpConfig::build(\n    int receiveMsglibConnectionAddress,\n    int timeoutReceiveMsglibConnectionAddress,\n    int expiry\n) impure inline {\n    return begin_cell()\n        .store_uint(lz::ReceiveEpConfig::_headerInfo, lz::ReceiveEpConfig::_headerInfoBits) ;; header info\n        .store_ones(lz::ReceiveEpConfig::_headerFillerBits)                                 ;; header filler\n        .store_uint256(receiveMsglibConnectionAddress)                                       ;; cl::t::uint256\n        .store_uint256(timeoutReceiveMsglibConnectionAddress)                                ;; cl::t::uint256\n        .store_uint64(expiry)                                                                ;; cl::t::uint64\n        .end_cell();\n}\n\n;; ====================== Object Getters =====================\n\nconst int lz::ReceiveEpConfig::_receiveMsglibConnectionOffset = _HEADER_WIDTH;\nconst int lz::ReceiveEpConfig::_timeoutReceiveMsglibConnectionOffset = lz::ReceiveEpConfig::_receiveMsglibConnectionOffset + 256;\nconst int lz::ReceiveEpConfig::_expiryOffset = lz::ReceiveEpConfig::_timeoutReceiveMsglibConnectionOffset + 256;\n\nint lz::ReceiveEpConfig::getReceiveMsglibConnection(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(lz::ReceiveEpConfig::_receiveMsglibConnectionOffset);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/lz/Packet.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n#include \"../../funC++/constants.fc\";\n\n#include \"Path.fc\";\n\n;; required storage name\nconst int lz::Packet::NAME = \"Packet\"u;\n\n;; field names\nconst int lz::Packet::path = 0;\nconst int lz::Packet::message = 1;\nconst int lz::Packet::nonce = 2;\nconst int lz::Packet::guid = 3;\n\nconst int lz::Packet::ERROR::INVALID_MESSAGE = 1089;\nconst int lz::Packet::ERROR::INVALID_NONCE = 1090;\nconst int lz::Packet::ERROR::INVALID_PACKET_FIELD = 1091;\n\nconst int lz::Packet::MAX_RECEIVE_MESSAGE_CELLS = 32;\nconst int lz::Packet::MAX_SEND_MESSAGE_CELLS = 255;\n\ncell lz::Packet::New(cell $path, cell message, int nonce) impure inline method_id {\n    return cl::declare(\n        lz::Packet::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $path],             ;; lz::Packet::path\n            [cl::t::cellRef, message],          ;; lz::Packet::message\n            [cl::t::uint64, nonce],             ;; lz::Packet::nonce\n            [cl::t::uint256, 0]                 ;; lz::Packet::guid\n        ])\n    );\n}\n\nconst int lz::Packet::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 4);\nconst int lz::Packet::_headerFillerBits = _HEADER_WIDTH - lz::Packet::_headerInfoBits;\nconst int lz::Packet::_headerInfo = 417359019239977417716476838698419835;\n\n;; this function is unused by the protocol but will be used by OApps\ncell lz::Packet::build(cell $path, cell message, int nonce) impure inline method_id {\n    return begin_cell()\n        .store_uint(lz::Packet::_headerInfo, lz::Packet::_headerInfoBits) ;; header info\n        .store_ones(lz::Packet::_headerFillerBits)                        ;; header filler\n        .store_ref($path)                                                  ;; path\n        .store_ref(message)                                                ;; message\n        .store_uint64(nonce)                                               ;; nonce\n        .store_uint256(0)                                                  ;; guid (default = 0)\n        .end_cell();\n}\n\n;; this function is unused by the protocol but will be used by OApps\ncell lz::Packet::nonceless(cell $path, cell message) impure inline method_id {\n    return lz::Packet::build($path, message, 0);\n}\n\n;; ====================== Object Accessors =====================\n\nconst int lz::Packet::_nonceOffset = _HEADER_WIDTH;\nconst int lz::Packet::_guidOffset = lz::Packet::_nonceOffset + 64;\n\ncell lz::Packet::getPath(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0);\n}\n\n;; this function is unused by the protocol but will be used by OApps\ncell lz::Packet::getMessage(cell $self) impure inline {\n    return $self.cellPreloadRefAt(1);\n}\n\nint lz::Packet::getNonce(cell $self) impure inline {\n    return $self.cellPreloadUint64At(lz::Packet::_nonceOffset);\n}\n\nint lz::Packet::getGuid(cell $self) impure inline {\n    return $self.cellPreloadUint256At(lz::Packet::_guidOffset);\n}\n\n;; returns (path, message, nonce, guid)\n(cell, cell, int, int) lz::Packet::deserialize(cell $self) impure inline {\n    slice $selfSlice = $self.begin_parse();\n    return (\n        $selfSlice.preloadRefAt(0),\n        $selfSlice.preloadRefAt(1),\n        $selfSlice.preloadUint64At(lz::Packet::_nonceOffset),\n        $selfSlice.preloadUint256At(lz::Packet::_guidOffset)\n    );\n}\n\n;; ====================== Object Composite Modifiers =====================\n\n;; NOTE: this assumes that the placement of the first field is before the second field\ncell lz::Packet::replaceTwoFieldsAtOffsets(\n    cell encodedPacket,\n    int replacementValue1,\n    int replacementOffsetBytes1,\n    int field1Bytes,\n    int replacementValue2,\n    int replacementOffsetBytes2,\n    int field2Bytes\n) impure inline method_id {\n    int field1PosBits = (replacementOffsetBytes1 % MAX_CELL_BYTES) * 8;\n    int cell1Idx = replacementOffsetBytes1 / MAX_CELL_BYTES;\n    int field2PosBits = (replacementOffsetBytes2 % MAX_CELL_BYTES) * 8;\n    int cell2Idx = replacementOffsetBytes2 / MAX_CELL_BYTES;\n    slice itr = encodedPacket.begin_parse();\n    int field1Bits = field1Bytes * 8;\n    int field2Bits = field2Bytes * 8;\n    int field1EndPosBits = field1PosBits + field1Bits;\n    int field2EndPosBits = field2PosBits + field2Bits;\n\n    throw_if(\n        lz::Packet::ERROR::INVALID_PACKET_FIELD,\n        (max(field1Bytes, field2Bytes) > MAX_CELL_BYTES)\n        | (max(field1EndPosBits, field2EndPosBits) > MAX_CELL_WHOLE_BYTE_BITS)\n    );\n\n    ;; short-circuit the common case to save gas\n    if (cell2Idx == 0) {\n        return begin_cell()\n            .store_slice(scutfirst(itr, field1PosBits, 0))\n            .store_uint(replacementValue1, field1Bits)\n            .store_slice(subslice(\n                itr,\n                field1EndPosBits,\n                0,\n                field2PosBits - field1EndPosBits,\n                0\n            ))\n            .store_uint(replacementValue2, field2Bits)\n            .store_slice(scutlast(\n                itr,\n                itr.slice_bits() - field2EndPosBits,\n                itr.slice_refs()\n            ))\n            .end_cell();\n    }\n\n    tuple encodedPacketBuilders = empty_tuple();\n\n    int idx = 0;\n\n    do {\n        if ((idx == cell1Idx) & (cell1Idx == cell2Idx)) {\n            slice beforeFirstField = scutfirst(itr, field1PosBits, 0);\n\n            slice betweenFields = subslice(\n                itr,\n                (field1PosBits + field1Bits),\n                0,\n                (field2PosBits - field1PosBits - field1Bits),\n                0\n            );\n\n            slice afterSecondField = scutlast(\n                itr,\n                itr.slice_bits() - (field2Bits + field2PosBits),\n                itr.slice_refs()\n            );\n\n            encodedPacketBuilders~tpush(\n                begin_cell()\n                    .store_slice(beforeFirstField)\n                    .store_uint(replacementValue1, field1Bits)\n                    .store_slice(betweenFields)\n                    .store_uint(replacementValue2, field2Bits)\n                    .store_slice(afterSecondField)\n            );\n        } elseif (idx == cell1Idx) {\n            encodedPacketBuilders~tpush(\n                begin_cell()\n                .store_slice(scutfirst(itr, field1PosBits, 0))\n                .store_uint(replacementValue1, field1Bits)\n                .store_slice(\n                    scutlast(\n                        itr,\n                        itr.slice_bits() - (field1Bits + field1PosBits),\n                        itr.slice_refs()\n                    )\n                )\n            );\n        } elseif (idx == cell2Idx) {\n            encodedPacketBuilders~tpush(\n                begin_cell()\n                .store_slice(scutfirst(itr, field2PosBits, 0))\n                .store_uint(replacementValue2, field2Bits)\n                .store_slice(\n                    scutlast(\n                        itr,\n                        itr.slice_bits() - (field2Bits + field2PosBits),\n                        itr.slice_refs()\n                    )\n                )\n            );\n        } else {\n            encodedPacketBuilders~tpush(begin_cell().store_slice(itr));\n        }\n\n        if (itr.slice_refs() > 0) {\n            itr = itr.preload_first_ref().begin_parse();\n        }\n        idx += 1;\n    } until (idx >= cell2Idx);\n\n    cell curCell = encodedPacketBuilders.at(cell2Idx).end_cell();\n\n    while (cell2Idx > 0) {\n        cell2Idx -= 1;\n        curCell = encodedPacketBuilders.at(cell2Idx).store_ref(curCell).end_cell();\n    }\n\n    return curCell;\n}\n\ncell lz::Packet::setNonceAndGuid(cell $self, int nonce, int guid) impure inline {\n    return begin_cell()\n            .store_slice($self.begin_parse().scutfirst(lz::Packet::_nonceOffset, 2))  ;; keep the header and the first two refs\n            .store_uint64(nonce)\n            .store_uint256(guid)\n            .end_cell();\n}\n\n;; ====================== Object Utilities =====================\n\nint lz::Packet::calculateGuid(cell $path, int nonce) inline method_id {\n    (int srcEid, int srcOApp, int dstEid, int dstOApp) = $path.lz::Path::deserialize();\n    return keccak256Builder(\n        begin_cell()\n            .store_uint64(nonce)\n            .store_uint32(srcEid)\n            .store_uint256(srcOApp)\n            .store_uint32(dstEid)\n            .store_uint256(dstOApp)\n    );\n}\n\n;; ====================== Object Validators =====================\n\n;; assumes that the message is a valid single-linked list\nint lz::Packet::_messageBytes(cell $self) impure inline {\n    slice messageSlice = $self.lz::Packet::getMessage().begin_parse();\n    (int sliceBits, int sliceRefs) = messageSlice.slice_bits_refs();\n    int messageBytes = sliceBits / 8;\n    while (sliceRefs > 0) {\n        messageSlice = messageSlice.preload_first_ref().begin_parse();\n        (sliceBits, sliceRefs) = messageSlice.slice_bits_refs();\n        messageBytes += (sliceBits / 8);\n    }\n    return messageBytes;\n}\n\n() lz::Packet::_assertValidLinkedList(cell head, int maxLen) impure inline {\n    slice messageSlice = head.begin_parse();\n    repeat (maxLen) {\n        (int sliceBits, int sliceRefs) = messageSlice.slice_bits_refs();\n        if (sliceRefs == 0) {\n            throw_if(lz::Packet::ERROR::INVALID_MESSAGE, sliceBits % 8 != 0);\n            return ();\n        } else {\n            throw_if(\n                lz::Packet::ERROR::INVALID_MESSAGE,\n                (sliceRefs != 1) | (sliceBits != MAX_CELL_WHOLE_BYTE_BITS)\n            );\n        }\n        messageSlice = messageSlice.preload_first_ref().begin_parse();\n    }\n    throw(lz::Packet::ERROR::INVALID_MESSAGE);\n}\n\n() lz::Packet::assertValidSendMessage(cell $self) impure inline {\n    lz::Packet::_assertValidLinkedList(\n        $self.lz::Packet::getMessage(),\n        lz::Packet::MAX_SEND_MESSAGE_CELLS\n    );\n}\n\n() lz::Packet::assertValidReceiveMessage(cell $self) impure inline {\n    lz::Packet::_assertValidLinkedList(\n        $self.lz::Packet::getMessage(),\n        lz::Packet::MAX_RECEIVE_MESSAGE_CELLS\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/contractMain.fc",
        "content": ";;; ================================================================\n;; The base main function for LayerZero Endpoint, UltraLightNode, and OApp\n;;; ================================================================\n\n#include \"handlerCore.fc\";\n#include \"abstract/contractMainAbstract.fc\";\n\n;;; ===============================\n;; Base main - low-level builtin context\n\n() main(int myBalance, int msgValue, cell inMsgFull, slice inMsgBody) impure inline {\n    initTxnContext(myBalance, msgValue, inMsgFull, inMsgBody);\n\n    if (txnIsBounced()) {\n        return ();\n    }\n\n    authenticateIfNecessary();\n\n    ;; ignore empty messages\n    if (inMsgBody.slice_empty?()) {\n        return ();\n    }\n\n    int op = getOpcode();\n    cell $md = getMsgData();\n\n    checkPermissions(op, $md);\n    \n    if (op == BaseInterface::OP::EVENT) {\n        throw(BaseInterface::ERROR::eventEmitted);\n    }\n\n    tuple actions = null();\n    if (op == BaseInterface::OP::INITIALIZE) {\n        actions = initialize($md);\n    } elseif (op == BaseInterface::OP::EMPTY) {\n        actions = emptyActions();\n    } else {\n        assertInitialized();\n        actions = _executeOpcode(op, $md);\n    }\n\n    int outflowNanos = actions.at(ACTIONS_OUTFLOW);\n    ;; Storage fees are deducted from the contract balance\n    ;; Any amount that is explicitly deposited into this contract (getRentNanos())\n    ;; is reserved to prevent it from being sent downstream\n    int baseline = (getContractBalance() - storage_fees()) - (getMsgValue() - getDonationNanos());\n    ;; The below assertion matches the insufficient ton behavior on action phase\n    ;; And it's probably unnecessary but it doesn’t cost much gas so no harm in keeping it.\n    throw_unless(37, baseline >= outflowNanos);\n    raw_reserve(baseline - outflowNanos, RESERVE_EXACTLY);\n\n    ;; Whether there is any value left to refund to the origin\n    int msgValueRemaining = true;\n    ;; the index of the action to be processed\n    int actionIndex = 1;\n    int numActions = actions.tlen();\n    while (actionIndex < numActions) {\n        ;; ========================================\n        ;; Loop management\n        tuple action = actions.tuple_at(actionIndex);\n        int actionType = action.int_at(0); ;; name is always the first index\n        actionIndex += 1;\n\n        ;; Applies a moving flag where if a single action returns false, then the false flag persists\n        msgValueRemaining = msgValueRemaining & _executeAction(actionType, action);\n    }\n\n    ;; If any value remains, we should refund it to the origin\n    if (msgValueRemaining) {\n        cell msg = begin_cell()\n            .store_uint(SEND_MSG_NON_BOUNCEABLE, 6)\n            .store_slice(getOriginStd())\n            .store_coins(0)\n            .store_uint(1, 107)\n            .store_ref(empty_cell())\n            .end_cell();\n        send_raw_message(msg, CARRY_ALL_BALANCE);\n    }\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/payment.fc",
        "content": "#include \"utils.fc\";\n\nconst int action::payment::NAME = \"payment\"u;\n\n;; @info the address to pay\nconst int action::payment::toAddress = 1;\n;; @info the amount to pay, in nanotons\nconst int action::payment::amount = 2;\n;; @info the amount of value to provision from this contract's balance\nconst int action::payment::outflowNanos = 3;\n\n;; @non-terminal\ntuple action::payment::create(int toAddress, int amount, int outflowNanos) impure inline {\n    return unsafeTuple([action::payment::NAME, toAddress, amount, outflowNanos]);\n}\n\n;; returns true if equals\nint action::payment::equals(tuple self, tuple other) impure {\n    return (\n        (self.int_at(0) == other.int_at(0)) ;; NAME\n        & (self.int_at(action::payment::toAddress) == other.int_at(action::payment::toAddress))\n        & (self.int_at(action::payment::amount) == other.int_at(action::payment::amount))\n        & (self.int_at(action::payment::outflowNanos) == other.int_at(action::payment::outflowNanos))\n    );\n}\n\ntuple _newAction<payment>(int toAddress, int amount, int outflowNanos) impure inline {\n    return action::payment::create(toAddress, amount, outflowNanos);\n}\n\n(tuple, ()) ~pushAction<payment>(tuple actions, int toAddress, int amount, int outflowNanos) impure inline {\n    if (outflowNanos > 0) {\n        actions = actions\n            .tset(ACTIONS_OUTFLOW, actions.int_at(ACTIONS_OUTFLOW) + outflowNanos);\n    }\n    return (actions.tpush(_newAction<payment>(toAddress, amount, outflowNanos)), ());\n}\n\nint executePayment(tuple action) impure inline {\n    sendNonTerminalAction(\n        SEND_MSG_NON_BOUNCEABLE,\n        get_forward_fee(BASECHAIN, 0, 1) +\n        action.int_at(action::payment::amount),\n        action.int_at(action::payment::toAddress),\n        empty_cell(),\n        NORMAL\n    );\n\n    ;; this being true means we're assuming there's going to\n    ;; be some value left over after the payment is made\n    return true;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/channel/handler.fc",
        "content": "#include \"callbackOpcodes.fc\";\n\n#include \"../core/abstract/protocolHandler.fc\";\n\n#include \"../../funC++/actions/dispatch.fc\";\n#include \"../../funC++/actions/event.fc\";\n\n#include \"../../classes/lz/EpConfig.fc\";\n#include \"../../classes/lz/Packet.fc\";\n#include \"../../classes/lz/Path.fc\";\n#include \"../../classes/lz/ReceiveEpConfig.fc\";\n#include \"../../classes/lz/SendEpConfig.fc\";\n\n#include \"../../classes/msgdata/ChannelNonceInfo.fc\";\n#include \"../../classes/msgdata/CoinsAmount.fc\";\n#include \"../../classes/msgdata/ExtendedMd.fc\";\n#include \"../../classes/msgdata/LzReceivePrepare.fc\";\n#include \"../../classes/msgdata/LzReceiveStatus.fc\";\n#include \"../../classes/msgdata/LzReceivePrepare.fc\";\n#include \"../../classes/msgdata/LzSend.fc\";\n#include \"../../classes/msgdata/MdAddress.fc\";\n#include \"../../classes/msgdata/MdObj.fc\";\n#include \"../../classes/msgdata/MessagingReceipt.fc\";\n#include \"../../classes/msgdata/MsglibSendCallback.fc\";\n#include \"../../classes/msgdata/Nonce.fc\";\n#include \"../../classes/msgdata/PacketId.fc\";\n#include \"../../classes/msgdata/PacketSent.fc\";\n\n\n#include \"../../funC++/dataStructures/DeterministicInsertionCircularQueue.fc\";\n#include \"../../funC++/dataStructures/PipelinedOutOfOrder.fc\";\n\n#include \"../interfaces.fc\";\n#include \"../msglibs/interface.fc\";\n#include \"interface.fc\";\n#include \"storage.fc\";\n\n;;; ================INTERFACE FUNCTIONS=====================\n\nint _getEventSink() inline {\n    return getOwner();\n}\n\n;;; ==========================HELPER FUNCTIONS=====================================\n\n() _assertEqualPaths(cell $path1, cell $path2) impure inline {\n    throw_unless(Channel::ERROR::wrongPath, $path1.cl::hash() == $path2.cl::hash());\n}\n\n;; @info The send request queue (Channel::sendRequestQueue) is a DeterministicInsertionCircularQueue\n;; that stores a mapping from requestId => hash of LzSend object.\n;; {_build, _read}SendRequestQueueEntry functions are helper functions that\n;; serialize and deserialize the 256-bit hash that is stored in the DICQueue\ncell _buildSendRequestQueueEntry(cell $lzSend) impure inline method_id {\n    return begin_cell().store_uint256($lzSend.cl::hash()).end_cell();\n}\n\nint _readSendRequestQueueEntry(cell contents) impure inline method_id {\n    if (contents.is_null()) {\n        return 0;\n    } elseif (contents.cell_is_empty()) {\n        return 0;\n    }\n    return contents.begin_parse().preload_uint(256);\n}\n\n;; returns boolean committable, (packet or null)\n(int, cell) _nonceCommittable(int incomingNonce) impure inline method_id {\n    throw_if(Channel::ERROR::invalidNonce, incomingNonce <= 0);\n\n    cell $storage = getContractStorage();\n\n    cell $executePOOO = $storage.Channel::getExecutePOOO();\n    int firstUnexecutedNonce = $executePOOO.POOO::getNextEmpty();\n\n    (int actualKey, cell $packet, int status, int exists) = DeterministicInsertionCircularQueue::get(\n        $storage.Channel::getExecutionQueue(),\n        incomingNonce\n    );\n\n    if (\n        (incomingNonce == firstUnexecutedNonce)\n        & (actualKey == incomingNonce)\n        & (status != ExecutionQueue::executing)\n    ) {\n        ;; short-circuit for efficiency in the common case\n        return (true, exists ? $packet : null());\n    }\n\n    ;; condition 1 & 2: must be within the window\n    ;; condition 3: must not be executing\n    if (\n        (incomingNonce >= firstUnexecutedNonce)\n        & (incomingNonce <= POOO::maxSettableBit($executePOOO))\n        & (status != ExecutionQueue::executing)\n    ) {\n        ;; this is nested because funC doesn't support short-circuiting boolean/bitwise ops\n        ;; condition 4: must not be executed\n        ifnot (POOO::isBitSet($executePOOO, incomingNonce)) {\n            return (true, exists ? $packet : null());\n        }\n    }\n\n    return (false, null());\n}\n\n;; returns boolean committable\nint _optimizedNonceCommittable(cell $executePOOO, cell executionQueue, int incomingNonce) impure inline {\n    throw_if(Channel::ERROR::invalidNonce, incomingNonce <= 0);\n\n    int firstUnexecutedNonce = $executePOOO.POOO::getNextEmpty();\n\n    (int actualKey, _, int status, int exists) = DeterministicInsertionCircularQueue::get(\n        executionQueue,\n        incomingNonce\n    );\n\n    ;; condition 1 & 2: must be within the window\n    ;; condition 3: must not be executing\n    if (\n        (incomingNonce >= firstUnexecutedNonce)\n        & (incomingNonce <= POOO::maxSettableBit($executePOOO))\n        & (status != ExecutionQueue::executing)\n    ) {\n        ;; this is nested because funC doesn't support short-circuiting boolean/bitwise ops\n        ;; condition 4: must not be executed\n        ifnot (POOO::isBitSet($executePOOO, incomingNonce)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\ncell _getExecutablePacket(int incomingNonce) impure inline method_id {\n    (int isCommittable, cell $packet) = _nonceCommittable(incomingNonce);\n    int firstUncommittedNonce = getContractStorage()\n        .Channel::getCommitPOOO()\n        .POOO::getNextEmpty();\n\n    throw_if(\n        Channel::ERROR::notExecutable,\n        ((~ isCommittable) | (incomingNonce >= firstUncommittedNonce) | $packet.is_null())\n    );\n\n    return $packet;\n}\n\n;;; ==========================VIEW FUNCTIONS=====================================\n\nint _viewInboundNonce() impure method_id {\n    return getContractStorage()\n        .Channel::getCommitPOOO()\n        .POOO::getNextEmpty() - 1;\n}\n\nint _viewExecutionStatus(int incomingNonce) impure method_id {\n    cell $storage = getContractStorage();\n\n    cell $executePOOO = $storage.cl::get<objRef>(Channel::executePOOO);\n    int firstUnexecutedNonce = $executePOOO.cl::get<uint64>(POOO::nextEmpty);\n    cell $commitPOOO = $storage.cl::get<objRef>(Channel::commitPOOO);\n    int firstUncommittedNonce = $commitPOOO.cl::get<uint64>(POOO::nextEmpty);\n    int inboundNonce = firstUncommittedNonce - 1;\n\n    int executed = incomingNonce < firstUnexecutedNonce;\n    if ((~ executed) & (incomingNonce < (firstUnexecutedNonce + MAX_CELL_BITS))) {\n        executed = $executePOOO.POOO::isBitSet(incomingNonce);\n    }\n\n    int committed = incomingNonce < firstUncommittedNonce;\n    if ((~ committed) & (incomingNonce < (firstUncommittedNonce + MAX_CELL_BITS))) {\n        committed = $commitPOOO.POOO::isBitSet(incomingNonce);\n    }\n\n    ifnot (committed) {\n        return ExecutionStatus::uncommitted;\n    } elseif (executed) {\n        return ExecutionStatus::executed;\n    }\n\n    (_, _, int status, _) = DeterministicInsertionCircularQueue::get(\n        $storage.cl::get<cellRef>(Channel::executionQueue),\n        incomingNonce\n    );\n    if (status == ExecutionQueue::executing) {\n        return ExecutionStatus::executing;\n    } elseif (incomingNonce <= inboundNonce) {\n        return ExecutionStatus::executable;\n    }\n    return ExecutionStatus::committedNotExecutable;\n}\n\n;;; ================INTERFACE FUNCTIONS=====================\n\n(cell, tuple) _initialize(cell $md) impure inline {\n    (cell $storage, tuple actions) = preamble();\n    cell $path = $storage.cl::get<objRef>(Channel::path);\n\n    throw_if(\n        Channel::ERROR::wrongPath,\n        ($path.cl::get<uint32>(lz::Path::srcEid) == 0)\n        | ($path.cl::get<address>(lz::Path::srcOApp) == NULLADDRESS)\n        | ($path.cl::get<uint32>(lz::Path::dstEid) == 0)\n        | ($path.cl::get<address>(lz::Path::dstOApp) == NULLADDRESS)\n    );\n\n    return (\n        $storage\n            .cl::set(Channel::executionQueue, DeterministicInsertionCircularQueue::create())\n            .cl::set(Channel::sendRequestQueue, DeterministicInsertionCircularQueue::create()),\n        actions\n    );\n}\n\n;;; ================PERMISSION FUNCTIONS=====================\n\n() _assertEndpoint() impure inline {\n    throw_unless(\n        Channel::ERROR::onlyEndpoint,\n        getCaller() == getContractStorage().Channel::getEndpointAddress()\n    );\n}\n\n;; this function is purposely designed to be maximally efficient when using a\n;; custom configuration and less efficient when using a default configuration\n() _assertSendMsglib(cell $mdMsglibSendCallback) impure inline {\n    ;; Resolve the actual sendMsglib address at the time of request.\n    ;; This function assumes the messagelib is not malicious or man-in-the-middle attacking,\n    ;; as those cases are asserted in the handler itself.\n    int sendMsglibAddress = $mdMsglibSendCallback\n        .md::MsglibSendCallback::getLzSend()\n        .md::LzSend::getSendMsglib();\n\n    throw_unless(Channel::ERROR::onlyApprovedSendMsglib, getCaller() == sendMsglibAddress);\n}\n\n() _assertOApp() impure inline {\n    throw_unless(\n        Channel::ERROR::onlyOApp,\n        getCaller() == getContractStorage()\n            .Channel::getPath()\n            .lz::Path::getSrcOApp()\n    );\n}\n\n() _checkPermissions(int op, cell $md) impure inline {\n    if (op == Channel::OP::LZ_RECEIVE_PREPARE) {\n        ;; open and public calls\n        return ();\n    } elseif (\n        (op == Channel::OP::CHANNEL_SEND)\n        | (op == Channel::OP::CHANNEL_COMMIT_PACKET)\n    ) {\n        return _assertEndpoint();\n    } elseif (op == Channel::OP::MSGLIB_SEND_CALLBACK) {\n        return _assertSendMsglib($md);\n    } elseif (\n        (op == Channel::OP::LZ_RECEIVE_LOCK)\n        | (op == Channel::OP::LZ_RECEIVE_EXECUTE_CALLBACK)\n    ) {\n        return _assertOApp();\n    } elseif (op == Channel::OP::DEPOSIT_ZRO) {\n        return assertOwner();\n    } elseif (\n        (op == Channel::OP::NOTIFY_PACKET_EXECUTED)\n        | (op == Channel::OP::SYNC_MSGLIB_CONNECTION)\n    ) {\n        return ();\n    } elseif (op == Channel::OP::SET_EP_CONFIG_OAPP) {\n        return _assertEndpoint();\n    } elseif (\n        ;; Management functions are all gated by OApp\n        (op == Channel::OP::NILIFY)\n        | (op == Channel::OP::BURN)\n        | (op == Channel::OP::FORCE_ABORT)\n    ) {\n       return _assertOApp();\n    } elseif (op == Channel::OP::EMIT_LZ_RECEIVE_ALERT) {\n        return ();\n    } else {\n        ;; we must put a check for all opcodes to make sure we don't\n        ;; mistakenly miss an opp code's permissions\n        throw(BaseInterface::ERROR::invalidOpcode);\n    }\n}\n\n;;; ==========================HANDLERS=====================================\n\n;; @in endpoint/handler.fc/setEpConfig\n;; @out controller/handler.fc/emit_event\n;; @md EpConfig\ntuple setEpConfigOApp(cell $epConfigOApp) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    setContractStorage(\n        $storage.cl::set(Channel::epConfigOApp, $epConfigOApp.lz::EpConfig::sanitize())\n    );\n\n    actions~pushAction<event>(Channel::event::EP_CFG_OAPP_SET, $epConfigOApp);\n    return actions;\n}\n\n;;; ==========================================\n;; Send flow\n;; @in: endpoint/handler.fc/quote\n;; @in_md: MdObj(lzSend, defaultEpConfig)\n;; @out: msglib/handler.fc/quote\n;; @out_md: $lzSend\ntuple channelSend(cell $mdObj) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    (\n        cell $lzSend, \n        cell $defaultSendEpConfig\n    ) = $mdObj.md::MdObj::deserialize();\n\n    ;; assert the size and structure of the incoming lzSend message\n    lz::Packet::assertValidSendMessage(\n        $lzSend.md::LzSend::getPacket()\n    );\n\n    (\n        cell $epConfigOApp, \n        cell $sendPath, \n        cell sendRequestQueue, \n        int lastSendRequestId\n    ) = $storage.Channel::getSendInformation();\n\n    ;; Resolve the desired send msglib and send msglib connection\n    (\n        int isEpConfigNull,\n        int sendMsglibManager,\n        int sendMsglib, \n        int sendMsglibConnection\n    ) = $epConfigOApp.lz::EpConfig::deserializeSendConfig();\n\n    if (isEpConfigNull) {\n        (sendMsglibManager, sendMsglib, sendMsglibConnection) = $defaultSendEpConfig.lz::SendEpConfig::deserialize();\n    }\n\n    if ((sendMsglibManager == NULLADDRESS) | (sendMsglib == NULLADDRESS) | (sendMsglibConnection == NULLADDRESS)) {\n        actions~pushAction<call>(\n            $sendPath.lz::Path::getSrcOApp(), ;; the OApp on this chain\n            Layerzero::OP::CHANNEL_SEND_CALLBACK,\n            md::MdObj::New(\n                md::MessagingReceipt::New(\n                    $lzSend,\n                    0,\n                    0,\n                    Channel::ERROR::MsglibBlocked\n                ),\n                getInitialStorage()\n            )\n        );\n        return actions;\n    }\n\n    ;; Each send request is assigned a unique request ID, which is also used as the key into\n    ;; the sendRequestQueue\n    int curRequestId = lastSendRequestId + 1;\n\n    $lzSend = md::LzSend::fillRequestInfo(\n        $lzSend, \n        curRequestId, \n        sendMsglibManager, \n        sendMsglib, \n        sendMsglibConnection\n    );\n\n    (_, _, _, int exists) = DeterministicInsertionCircularQueue::get(sendRequestQueue, curRequestId);\n    ifnot (exists) {\n        ;; submit to the msglib\n        setContractStorage(\n            $storage.Channel::setSendRequestQueueAndLastSendRequestId(\n                curRequestId,\n                DeterministicInsertionCircularQueue::set(\n                    sendRequestQueue,\n                    curRequestId,\n                    _buildSendRequestQueueEntry($lzSend),\n                    SendRequestQueue::sending\n                )\n            )\n        );\n\n        actions~pushAction<call>(\n            sendMsglibConnection,\n            MsglibConnection::OP::MSGLIB_CONNECTION_SEND,\n            $lzSend\n        );\n    } else {\n        ;; callback to the oApp with a failure and emit an event\n        actions~pushAction<event>(Channel::ERROR::sendQueueCongested, $lzSend);\n        actions~pushAction<call>(\n            $sendPath.lz::Path::getSrcOApp(), ;; the OApp on this chain\n            Layerzero::OP::CHANNEL_SEND_CALLBACK,\n            md::MdObj::New(\n                md::MessagingReceipt::New($lzSend, 0, 0, Channel::ERROR::sendQueueCongested),\n                getInitialStorage()\n            )\n        );\n    }\n\n    return actions;\n}\n\n;; in: msglib/handler.fc/msglibSend\n;; in_md: MsglibSendCallback\n;; out: OApp/handler.fc/sendCallback\ntuple msglibSendCallback(cell $mdMsglibSendCallback) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    (\n        int errorCode,\n        int nativeQuote,\n        int zroQuote,\n        cell $lzSend,\n        cell serializedPayees,\n        cell encodedPacket,\n        int nonceByteOffset,\n        int nonceBytes,\n        int guidByteOffset,\n        int guidBytes,\n        cell $sendEvents\n    ) = $mdMsglibSendCallback.md::MsglibSendCallback::deserialize();\n\n    (\n        int requestId,\n        int lzSendNativeFee,\n        int lzSendZroFee,\n        cell $extraOptions,\n        cell $enforceOptions,\n        int sendMsglibManager\n    ) = $lzSend.md::LzSend::deserializeSendCallback();\n\n    (\n        cell sendRequestQueue,\n        int zroBalance,\n        cell $sendPath,\n        int outboundNonce\n    ) = $storage.Channel::getSendCallbackInformation();\n\n    ;; Read the requestId from the sendRequestQueue to ensure this send request is genuine\n    ;; and is not being double-executed\n    (_, cell contents, _, int exists) = DeterministicInsertionCircularQueue::get(\n        sendRequestQueue,\n        requestId\n    );\n\n    if (exists) {\n        if (_readSendRequestQueueEntry(contents) == $lzSend.cl::hash()) {\n            $storage = $storage.Channel::setSendRequestQueue(\n                DeterministicInsertionCircularQueue::delete(sendRequestQueue, requestId)\n            );\n        } else {\n            ;; See below comment, this else case is logically the same as the below else block,\n            ;; but needs to be split due to lack of short-circuiting boolean expressions in funC\n            return actions;\n        }\n    } else {\n        ;; if the send request doesn't exist, there are two cases\n        ;; 1. a legitimate request was frontrun by a force-abort\n        ;;  in this case, we can safely refund all the funds to the origin\n        ;; 2. a malicious MITM attack by ULN\n        ;;  in this case, we can't refund the funds, but we can still emit an event\n\n        ;; This technically silently reverts, by not processing any output actions,\n        ;; thus providing a refund, instead of hard reverting\n        return actions;\n    }\n\n    ;; verify that cumulative fees quoted by the msglib <= the fee cap specified by the user/app\n    if (lzSendNativeFee < nativeQuote) {\n        errorCode = Channel::ERROR::notEnoughNative;\n    }\n    if (lzSendZroFee < zroQuote) {\n        errorCode = Channel::ERROR::notEnoughZroToken;\n    }\n\n    ;; Verify that the ZRO token credits in the Channel is sufficient to cover the\n    ;; quoted ZRO cost of the message.\n    if (zroBalance < zroQuote) {\n        errorCode = Channel::ERROR::notEnoughZroTokenBalance;\n    }\n\n    int packetGuid = 0;\n    int packetNonce = 0;\n\n    if (errorCode == Channel::NO_ERROR) {\n        ;; Assign a nonce to the packet and calculate the resulting GUID\n        packetNonce = outboundNonce + 1;\n        packetGuid = lz::Packet::calculateGuid($sendPath, packetNonce);\n\n        ;; native payments\n        tuple payees = deserializePayees(serializedPayees);\n\n        ;; If the TON message does not contain sufficient value to perform the payments,\n        ;; the transaction will revert and the send channel will eventually get blocked.\n        ;; It is the responsibility of the OApp to assert sufficient gas + value to cover the\n        ;; entire transaction and avoid this failure.\n        repeat (payees.tlen()) {\n            [int payeeAddress, int nativeAmount] = payees~tpopPayee();\n            actions~pushAction<payment>(payeeAddress, nativeAmount, 0);\n        }\n\n        ;; Due to asynchrony between the Msglib and the Channel, the nonce and guid\n        ;; cannot be ... ?\n\n        cell completedEncodedPacket = null();\n\n        if (guidByteOffset > nonceByteOffset) {\n            completedEncodedPacket = encodedPacket\n                .lz::Packet::replaceTwoFieldsAtOffsets(\n                    packetNonce,\n                    nonceByteOffset,\n                    nonceBytes,\n                    packetGuid,\n                    guidByteOffset,\n                    guidBytes\n                );\n        } else {\n            completedEncodedPacket = encodedPacket\n                .lz::Packet::replaceTwoFieldsAtOffsets(\n                    packetGuid,\n                    guidByteOffset,\n                    guidBytes,\n                    packetNonce,\n                    nonceByteOffset,\n                    nonceBytes\n                );\n        }\n\n        actions~pushAction<event>(\n            Channel::event::PACKET_SENT,\n            md::PacketSent::build(\n                nativeQuote,\n                zroQuote,\n                $extraOptions,\n                $enforceOptions,\n                completedEncodedPacket,\n                packetNonce,\n                sendMsglibManager,\n                $sendEvents\n            )\n        );\n\n        $storage = $storage.Channel::setOutboundNonceAndZroBalance(\n            packetNonce,\n            zroBalance - zroQuote\n        );\n    }\n\n    ;; If the quote was unsuccessful, delete the hash from storage to prevent hol blocking\n    ;; If the quote was successful, additionally update the ZRO balance and outbound nonce\n    setContractStorage($storage);\n\n    actions~pushAction<call>(\n        $sendPath.lz::Path::getSrcOApp(), ;; the OApp on this chain\n        Layerzero::OP::CHANNEL_SEND_CALLBACK,\n        md::MdObj::build(\n            md::MessagingReceipt::build(\n                $lzSend.md::LzSend::setPacketNonceAndGuid(packetNonce, packetGuid),\n                nativeQuote,\n                zroQuote,\n                errorCode\n            ),\n            getInitialStorage()\n        )\n    );\n\n    return actions;\n}\n\n;;; ==========================================\n;; Receive flow\n;; @in     endpoint/handler.fc/verify\n;; @in_md  ExtendedMd(msglibConnectionAddress, defaultEpConfig, verify)\n;; @out    packet_receive/handler.fc/verify\n;; @out_md ExtendedMd(msglib_addr, _, verify)\n;; @out    controller/handler.fc/emit_event\ntuple channelCommitPacket(cell $mdExtended) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $sanitizeMdExtended = $mdExtended.md::ExtendedMd::sanitize();\n\n    (\n        cell $packet,\n        int callerMsglibConnectionAddress\n    ) = $sanitizeMdExtended.md::ExtendedMd::getMdAndForwardingAddress();\n    ;; assert the size of the incoming packet\n    lz::Packet::assertValidReceiveMessage($packet);\n\n    (\n        cell $epConfigOApp,\n        cell $commitPOOO,\n        cell $executePOOO,\n        cell executionQueue\n    ) = $storage.Channel::getCommitPacketInformation();\n\n    (\n        int useDefaults,\n        int receiveMsglibConnection\n    ) = $epConfigOApp.lz::EpConfig::deserializeReceiveConfig();\n\n    if (useDefaults) {\n        cell $defaultConfig = $sanitizeMdExtended.md::ExtendedMd::getObj();\n        receiveMsglibConnection = $defaultConfig.lz::ReceiveEpConfig::getReceiveMsglibConnection();\n    }\n\n    if (receiveMsglibConnection != callerMsglibConnectionAddress) {\n        ;; grossly inefficient, but this will (almost) never happen\n        ;; so we can optimize the happy path by isolating this logic into this block\n        cell $defaultConfig = $sanitizeMdExtended.cl::get<objRef>(md::MdObj::obj);\n        int timeoutReceiveMsglibConnection = useDefaults\n            ? $defaultConfig.cl::get<address>(lz::ReceiveEpConfig::timeoutReceiveMsglibConnection)\n            : $epConfigOApp.cl::get<address>(lz::EpConfig::timeoutReceiveMsglibConnection);\n\n        int expiry = useDefaults\n            ? $defaultConfig.cl::get<uint64>(lz::ReceiveEpConfig::expiry)\n            : $epConfigOApp.cl::get<uint64>(lz::EpConfig::timeoutReceiveMsglibExpiry);\n\n        if ((timeoutReceiveMsglibConnection != callerMsglibConnectionAddress) | (expiry < now())) {\n            throw(Channel::ERROR::onlyApprovedReceiveMsglib);\n        }\n    }\n\n    int incomingNonce = $packet.lz::Packet::getNonce();\n\n    int isCommittable = _optimizedNonceCommittable(\n        $executePOOO,\n        executionQueue,\n        incomingNonce\n    );\n\n    if (isCommittable) {\n        setContractStorage(\n            $storage\n                .Channel::setCommitPOOOAndExecutionQueue(\n                    POOO::set($commitPOOO, incomingNonce),\n                    DeterministicInsertionCircularQueue::set(\n                        executionQueue,\n                        incomingNonce,\n                        $packet,\n                        ExecutionQueue::committed\n                    )\n                )\n        );\n        actions~pushAction<event>(Channel::event::PACKET_COMMITTED, $packet);\n    }\n\n    if (incomingNonce <= POOO::maxSettableBit($executePOOO)) {\n        ;; Cannot respond back to msglib if the packet is not currently committable but\n        ;; will be committable in the future\n        ;; Caveat: if the packet is currently executing, we treat it as uncommittable.\n        ;; There exists a race condition where a uncommitted re-committable packet\n        ;; can be marked as committed. If the packet needs to be re-committed for a good reason\n        ;; (e.g., malicious DVN), the OApp owner must first nilify the packet\n\n        actions~pushAction<call>(\n            callerMsglibConnectionAddress,\n            MsglibConnection::OP::MSGLIB_CONNECTION_COMMIT_PACKET_CALLBACK,\n            md::ChannelNonceInfo::New(\n                incomingNonce,\n                $storage.Channel::getExecutePOOO().POOO::getNextEmpty()\n            )\n        );\n    }\n\n    return actions;\n}\n\n;;; ==========================================\n;; Execution step 1\n;; @in_opcode Channel::OP::LZ_RECEIVE_PREPARE\n;; @in_from (external in) permissionless\n;; @in_md nonce\n;; @out_opcode Layerzero::OP::LZ_RECEIVE_PREPARE\n;; @out_to srcOApp\n;; @out_md ExtendedMd(md=packetId, obj=channel_init_state, forwarding_addr=NULLADDRESS)\n;; @permissions: permissonless\ntuple lzReceivePrepare(cell $lzReceivePrepareMd) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    (int nonce, int nanotons) = $lzReceivePrepareMd.md::LzReceivePrepare::deserialize();\n\n    ;; extract oApp from path\n    actions~pushAction<dispatch>(\n        $storage.Channel::getPath().lz::Path::getSrcOApp(), ;; the OApp on this chain\n        Layerzero::OP::LZ_RECEIVE_PREPARE,\n        ;; Throws if the Packet is not executable\n        _getExecutablePacket(nonce),\n        nanotons\n    );\n\n    return actions;\n}\n\n;; @in_opcode Channel::OP::LZ_RECEIVE_LOCK\n;; @in_from oApp\n;; @in_md nonce\n;; @out_opcode Layerzero::OP::LZ_RECEIVE_EXECUTE\n;; @out_to oApp\n;; @out_md ExtendedMd(md=Packet, obj=channel_init_state, forwarding_addr=NULLADDRESS)\n;; @permissions: only oApp\ntuple lzReceiveLock(cell $nonceMd) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    int incomingNonce = $nonceMd.md::Nonce::getNonce();\n    throw_if(Channel::ERROR::invalidNonce, incomingNonce <= 0);\n\n    (\n        cell executionQueue,\n        cell $commitPOOO,\n        cell $sendPath\n    ) = $storage.Channel::getLzReceiveLockInformation();\n\n    (int actualKey, cell $packet, int status, _) = DeterministicInsertionCircularQueue::get(\n        executionQueue,\n        incomingNonce\n    );\n\n    int firstUncommittedNonce = $commitPOOO.POOO::getNextEmpty();\n\n    ;; executable if present and all preceding nonces are committed, executing, or executed\n    if (\n        (actualKey == incomingNonce)\n        & (status == ExecutionQueue::committed)\n        & (incomingNonce < firstUncommittedNonce)\n    ) {\n        ;; set state to executing\n        setContractStorage(\n            $storage.Channel::setExecutionQueue(\n                DeterministicInsertionCircularQueue::set(\n                    executionQueue,\n                    incomingNonce,\n                    $packet,\n                    ExecutionQueue::executing\n                )\n            )\n        );\n\n        actions~pushAction<call>(\n            $sendPath.lz::Path::getSrcOApp(), ;; the OApp on this chain\n            Layerzero::OP::LZ_RECEIVE_EXECUTE,\n            md::MdObj::build($packet, getInitialStorage())\n        );\n    } else {\n        actions~pushAction<event>(\n            Channel::event::NOT_EXECUTABLE,\n            md::PacketId::New(\n                $sendPath.lz::Path::reverse(), ;; emit the receive path \n                incomingNonce\n            )\n        );\n    }\n\n    return actions;\n}\n\n;; @in_opcode Channel::OP::LZ_RECEIVE_EXECUTE_CALLBACK\n;; @in_from oApp\n;; @in_md LzReceiveStatus\n;; @out_opcode OP::PACKET_RECEIVE_DESTROYED_CALLBACK\n;; @out_to oApp\n;; @out_md ExtendedMd(md=packetId, obj=pr_init_state, forwarding_addr=address_std_hashpart_null())\n;; @failure => unlock the Packet\n;; @success => destroy the Packet and refund rent\n;; @permissions: only oApp\ntuple lzReceiveExecuteCallback(cell $lzReceiveStatus) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    (\n        int lzReceiveSuccess, \n        int packetNonce\n    ) = $lzReceiveStatus.md::LzReceiveStatus::getSuccessAndNonce();\n\n    (\n        cell $executePOOO, \n        cell executionQueue, \n        cell $sendPath\n    ) = $storage.Channel::getExecutePOOOAndExecutionQueueAndPath();\n\n    (int actualKey, cell $packet, int status, _) = DeterministicInsertionCircularQueue::get(\n        executionQueue,\n        packetNonce\n    );\n\n    throw_unless(\n        Channel::ERROR::notExecuting,\n        (actualKey == packetNonce) & (status == ExecutionQueue::executing)\n    );\n\n    ;; check for success/failure\n    if (lzReceiveSuccess) {\n        executionQueue = DeterministicInsertionCircularQueue::delete(executionQueue, packetNonce);\n\n        $storage = $storage.Channel::setExecutePOOO(\n            POOO::set($executePOOO, packetNonce)\n        );\n\n        ;; emit Packet in the manager\n        actions~pushAction<event>(\n            Channel::event::DELIVERED,\n            md::PacketId::build(\n                $sendPath.lz::Path::optimizedReverse(), ;; emit the receive path\n                packetNonce\n            )\n        );\n    } else {\n        executionQueue = DeterministicInsertionCircularQueue::set(\n            executionQueue,\n            packetNonce,\n            $packet, ;; same packet object that we extracted from the queue\n            ExecutionQueue::committed\n        );\n\n        ;; emit Packet so we know its unlocked\n        actions~pushAction<event>(\n            Channel::event::LZ_RECEIVE_ALERT,\n            md::LzReceiveStatus::NewFull(\n                false,\n                packetNonce, ;; unforgeable\n                $lzReceiveStatus.cl::get<coins>(md::LzReceiveStatus::value), ;; can be arbitrary/unsafe\n                $lzReceiveStatus.cl::get<cellRef>(md::LzReceiveStatus::extraData), ;; can be arbitrary/unsafe\n                $lzReceiveStatus.cl::get<cellRef>(md::LzReceiveStatus::reason), ;; can be arbitrary/unsafe\n                getOrigin(), ;; unforgeable\n                $packet, ;; unforgeable\n                ExecutionStatus::executable\n            )\n        );\n    }\n\n    setContractStorage($storage.Channel::setExecutionQueue(executionQueue));\n\n    return actions;\n}\n\n;;; ====================== Management Helper ===================================\n() _commitFakePacket(cell $storage, int nonce, cell $receivePath) impure inline method_id {\n    cell $mockPacket = lz::Packet::New($receivePath, empty_cell(), nonce);\n\n    ;; Because this is not originating from the endpoint, we dont have the defaults\n    ;; Actual defaults and the msglib address arent required because the call is direct from the OApp\n    cell $mockEpConfigDefaults = lz::ReceiveEpConfig::New(\n        0xdeadbeef, ;; any non-null dummy value for the receive msglib connection address\n        NULLADDRESS, ;; timeout never has to be used for burn\n        0 ;; as above, timeout never has to be used for burn\n    );\n    cell $epConfigOApp = $storage.cl::get<objRef>(Channel::epConfigOApp);\n\n    ;; Step 1: Commit the 'mockPacket'\n    ;; This is safe because we are going to do the following steps (2 and 3) atomically.\n    ;; channelCommitPacket will not revert if the packet is not committed, but lzReceiveLock will.\n    ;; Basically lying to channelCommitPacket to say the \"correct\" msglib is committing\n    channelCommitPacket(\n        md::ExtendedMd::New(\n            $mockPacket,\n            $mockEpConfigDefaults, ;; this is completely ignored if useDefaults is false\n            $epConfigOApp.cl::get<bool>(lz::EpConfig::isNull)\n                ? $mockEpConfigDefaults.cl::get<address>(lz::ReceiveEpConfig::receiveMsglibConnection)\n                : $epConfigOApp.cl::get<address>(lz::EpConfig::receiveMsglibConnection)\n        )\n    );\n}\n\n;; @permissions only-oApp\ntuple nilify(cell $packetId) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n    $packetId = $packetId.md::PacketId::sanitize();\n\n    ;; reverse the path because this is from a receive perspective\n    cell $receivePath = $storage.Channel::getPath().lz::Path::reverse();\n    _assertEqualPaths($receivePath, $packetId.cl::get<objRef>(md::PacketId::path));\n\n    int incomingNonce = $packetId.cl::get<uint64>(md::PacketId::nonce);\n\n    (int isCommittable, cell $previousPacket) = _nonceCommittable(incomingNonce);\n    throw_unless(Channel::ERROR::notCommittable, isCommittable);\n\n    _commitFakePacket($storage, incomingNonce, $receivePath);\n    \n    setContractStorage(\n        getContractStorage().cl::set(\n            Channel::executionQueue,\n            DeterministicInsertionCircularQueue::delete(\n                $storage.Channel::getExecutionQueue(),\n                incomingNonce\n            )\n        )\n    );\n\n    if ($previousPacket.is_null()) {\n        $previousPacket = lz::Packet::New($receivePath, empty_cell(), incomingNonce);\n    }\n    actions~pushAction<event>(Channel::event::PACKET_NILIFIED, $previousPacket);\n\n    actions~pushAction<call>(\n        $receivePath.cl::get<address>(lz::Path::dstOApp), ;; the OApp on this chain\n        Layerzero::OP::NILIFY_CALLBACK,\n        md::MdObj::build($packetId, getInitialStorage())\n    );\n\n    return actions;\n}\n\ntuple burn(cell $packetId) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n    cell $packetId = $packetId.md::PacketId::sanitize();\n\n    ;; reverse the path because this is from a receive perspective\n    cell $receivePath = $storage.Channel::getPath().lz::Path::reverse();\n    _assertEqualPaths($receivePath, $packetId.cl::get<objRef>(md::PacketId::path));\n\n    int nonce = $packetId.cl::get<uint64>(md::PacketId::nonce);\n\n    cell $nonceMd = md::Nonce::New(nonce);\n\n    (_, cell $previousPacket) = _nonceCommittable(nonce);\n\n    ;; Step 1: Commit a 'mockPacket' to be used when we 'burn' this nonce\n    _commitFakePacket($storage, nonce, $receivePath);\n    \n    ;; Step 2: Put the packet into 'executing'\n    lzReceiveLock($nonceMd);\n    ;; Step 3: Mock the lzReceiveExecuteCallback, which marks/flags that given nonce as used and 'executed'\n    lzReceiveExecuteCallback(md::LzReceiveStatus::New(true, nonce));\n\n\n    if ($previousPacket.is_null()) {\n        $previousPacket = lz::Packet::New($receivePath, empty_cell(), nonce);\n    }\n\n    ;; Emit an event so we are able to observe offchain that this nonce has been 'burned'\n    actions~pushAction<event>(\n        Channel::event::PACKET_BURNED,\n        $previousPacket\n    );\n\n    actions~pushAction<call>(\n        $receivePath.cl::get<address>(lz::Path::dstOApp), ;; the OApp on this chain\n        Layerzero::OP::BURN_CALLBACK,\n        md::MdObj::build(\n            md::PacketId::New($receivePath, nonce),\n            getInitialStorage()\n        )\n    );\n\n    return actions;\n}\n\n;;; ==========================================\n;; ZRO management\n;; only controller\ntuple depositZro(cell $coinsAmount) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $sanitizedCoinsAmount = $coinsAmount.md::CoinsAmount::sanitize();\n\n    setContractStorage(\n        $storage.cl::set(\n            Channel::zroBalance,\n            $storage.Channel::getZroBalance()\n            + $sanitizedCoinsAmount.cl::get<coins>(md::CoinsAmount::amount)\n        )\n    );\n\n   actions~pushAction<event>(Channel::event::ZRO_DEPOSITED, $sanitizedCoinsAmount);\n    \n    return actions;\n}\n\n;; Attempt to abort a send request. Check if hash still present, if present delete and send\n;; @in: oApp\n;; @in_opcode Channel::OP::FORCE_ABORT\n;; @in_md lzSend\n;; @out_opcode\n;; @out_to oApp\n;; @out_md lzSend\n;; @permissions: only oApp\ntuple forceAbort(cell $lzSend) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $sendPath = $storage.cl::get<objRef>(Channel::path);\n    ;; $lzSend does not need to be sanitized, as it must be correct to match\n    ;; the stored hash\n    _assertEqualPaths(\n        $sendPath,\n        $lzSend.md::LzSend::getPath()\n    );\n\n    int requestId = $lzSend.md::LzSend::getSendRequestId();\n\n    cell sendRequestQueue = $storage.cl::get<cellRef>(Channel::sendRequestQueue);\n\n    (_, cell request, int status, _) = DeterministicInsertionCircularQueue::get(sendRequestQueue, requestId);\n\n    throw_if(\n        Channel::ERROR::cannotAbortSend,\n        (status != SendRequestQueue::sending) | (_readSendRequestQueueEntry(request) != $lzSend.cl::hash())\n    );\n\n    ;; delete the reservation and update the storage\n    setContractStorage(\n        $storage.cl::set(\n            Channel::sendRequestQueue,\n            DeterministicInsertionCircularQueue::delete(sendRequestQueue, requestId)\n        )\n    );\n\n    actions~pushAction<call>(\n        $sendPath.cl::get<address>(lz::Path::srcOApp), ;; the OApp on this chain\n        Layerzero::OP::CHANNEL_SEND_CALLBACK,\n        md::MdObj::New(\n            md::MessagingReceipt::New($lzSend, 0, 0, Channel::ERROR::sendAborted),\n            getInitialStorage()\n        )\n    );\n\n    return actions;\n}\n\n;; Send the current state of the channel to the MsglibConnection\n;; @in: permissionless\n;; @in_opcode Channel::OP::MSGLIB_CONNECTION_SYNC_CHANNEL_STATE\n;; @in_md mdAddress ( MsglibConnectionAddress, Path )\ntuple syncMsglibConnection(cell $mdAddress) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $sanitizedMdAddress = $mdAddress.md::MdAddress::sanitize();\n\n    actions~pushAction<call>(\n        $sanitizedMdAddress.cl::get<address>(md::MdAddress::address), ;; msglibConnectionAddress\n        MsglibConnection::OP::MSGLIB_CONNECTION_SYNC_CHANNEL_STATE,\n        md::MdObj::New(\n            md::ChannelNonceInfo::New(\n                $storage\n                    .cl::get<objRef>(Channel::commitPOOO)\n                    .cl::get<uint64>(POOO::nextEmpty),\n                $storage\n                    .cl::get<objRef>(Channel::executePOOO)\n                    .cl::get<uint64>(POOO::nextEmpty)\n            ),\n            getInitialStorage()\n        )\n    );\n\n    return actions;\n}\n\ntuple notifyPacketExecuted(cell $mdAddress) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $sanitizedMdAddress = $mdAddress.md::MdAddress::sanitize();\n    cell $sanitizedNonceMd = $sanitizedMdAddress\n        .cl::get<objRef>(md::MdAddress::md)\n        .md::Nonce::sanitize();\n\n    int executionStatus = _viewExecutionStatus($sanitizedNonceMd.cl::get<uint64>(md::Nonce::nonce));\n\n    if (executionStatus != ExecutionStatus::executed) {\n        return actions;\n    }\n\n    actions~pushAction<call>(\n        $sanitizedMdAddress.cl::get<address>(md::MdAddress::address),\n        MsglibConnection::OP::MSGLIB_CONNECTION_COMMIT_PACKET_CALLBACK,\n        md::ChannelNonceInfo::New(\n            $sanitizedNonceMd.cl::get<uint64>(md::Nonce::nonce),\n            $storage.cl::get<objRef>(Channel::executePOOO).cl::get<uint64>(POOO::nextEmpty)\n        )\n    );\n\n    return actions;\n}\n\ntuple emitLzReceiveAlert(cell $lzReceiveStatus) impure inline method_id {\n    (cell $storage, tuple actions) = preamble();\n\n    cell $saniztizedLzReceiveStatus = $lzReceiveStatus.md::LzReceiveStatus::NewFull::sanitize();\n\n    int nonce = $saniztizedLzReceiveStatus.cl::get<uint64>(md::LzReceiveStatus::nonce);\n    throw_if(Channel::ERROR::invalidNonce, nonce == 0);\n    \n    (int actualNonce, cell $packet, _, int exists) = DeterministicInsertionCircularQueue::get(\n        $storage.Channel::getExecutionQueue(),\n        nonce\n    );\n\n    throw_unless(\n        Channel::ERROR::invalidNonce,\n        (actualNonce == nonce) & (exists)\n    );\n\n    actions~pushAction<event>(\n        Channel::event::LZ_RECEIVE_ALERT,\n        md::LzReceiveStatus::NewFull(\n            $saniztizedLzReceiveStatus.cl::get<bool>(md::LzReceiveStatus::success),\n            nonce,\n            $saniztizedLzReceiveStatus.cl::get<coins>(md::LzReceiveStatus::value),\n            $saniztizedLzReceiveStatus.cl::get<cellRef>(md::LzReceiveStatus::extraData),\n            $saniztizedLzReceiveStatus.cl::get<cellRef>(md::LzReceiveStatus::reason),\n            getCaller(),\n            $packet,\n            _viewExecutionStatus(nonce)\n        )\n    );\n    return actions;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/baseInterface.fc",
        "content": "const int BaseInterface::event::AUTHENTICATED = \"AUTHENTICATED\"u;\nconst int BaseInterface::event::INITIALIZED = \"INITIALIZED\"u;\n\nconst int BaseInterface::ERROR::notAuthenticated = 257;\nconst int BaseInterface::ERROR::onlyOwner = 258;\nconst int BaseInterface::ERROR::notInitialized = 259;\nconst int BaseInterface::ERROR::alreadyInitialized = 260;\nconst int BaseInterface::ERROR::invalidOpcode = 261;\nconst int BaseInterface::ERROR::eventEmitted = 262;\nconst int BaseInterface::ERROR::invalidActionType = 263;\nconst int BaseInterface::ERROR::invalidEventSource = 264;\n\nconst int BaseInterface::OP::INITIALIZE = \"BaseInterface::OP::INITIALIZE\"c;\nconst int BaseInterface::OP::EMPTY = 0;\nconst int BaseInterface::OP::EVENT = \"BaseInterface::OP::EVENT\"c;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/event.fc",
        "content": "#include \"../baseInterface.fc\";\n#include \"../classlib.fc\";\n#include \"utils.fc\";\n\nconst int action::event::NAME = \"event\"u;\n\nconst int action::event::bodyIndex = 1;\n\nconst int action::event::topic = 0;\nconst int action::event::body = 1;\nconst int action::event::initialStorage = 2;\n\n;; Interface function you must implement to get the event sink\nint _getEventSink() impure inline;\n\n;; @info Events in LZ contracts are internal messages to an event sink\n;; where the resulting transaction always reverts\n;; @non-terminal\ncell action::event::New(int topic, cell $body, cell $initialStorage) impure inline method_id {\n    return cl::declare(\n        action::event::NAME,\n        unsafeTuple([\n            [cl::t::uint256, topic],\n            [cl::t::objRef, $body],\n            [cl::t::objRef, $initialStorage]\n        ])\n    );\n}\n\nconst int action::event::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 3);\nconst int action::event::_headerFillerBits = _HEADER_WIDTH - action::event::_headerInfoBits;\nconst int action::event::_headerInfo = 7850279558805522911016931325;\n\ncell action::event::build(int topic, cell $body, cell $initialStorage) impure inline method_id {\n    return begin_cell()\n        .store_uint(action::event::_headerInfo, action::event::_headerInfoBits)     ;; header info\n        .store_ones(action::event::_headerFillerBits)                               ;; header filler\n        .store_uint256(topic)\n        .store_ref($body)\n        .store_ref($initialStorage)\n        .end_cell();\n}\n\ntuple action::event::create(int topic, cell $body, cell $initialStorage) impure inline {\n    return unsafeTuple([\n        action::event::NAME, \n        action::event::build(topic, $body, $initialStorage)\n    ]);\n}\n\n;; returns true if equals\nint action::event::equals(tuple self, tuple other) impure {\n    int equalEventObj = compareObjectFields(\n        self.cell_at(action::event::bodyIndex),\n        other.cell_at(action::event::bodyIndex)\n    );\n\n    return (\n        (self.int_at(0) == other.int_at(0)) ;; NAME\n        & (equalEventObj == -1)\n    );\n}\n\n;; interface this function because it requires passing the 'getInitialStorage' from the baseHandler\n;; tuple _newAction<event>(int topic, cell $body) impure inline {\n;;     return action::event::create(topic, $body, getInitialStorage());\n;; }\n\ntuple _newAction<event>(int topic, cell $body) impure inline;\n\n(tuple, ()) ~pushAction<event>(tuple actions, int topic, cell $body) impure inline {\n    return (actions.tpush(_newAction<event>(topic, $body)), ());\n}\n\nint executeEvent(tuple action) impure inline {\n    ;; send event to event sink\n    sendNonTerminalAction(\n        SEND_MSG_NON_BOUNCEABLE,\n        0,\n        _getEventSink(),\n        buildLayerzeroMessageBody(\n            0,\n            BaseInterface::OP::EVENT,\n            action.cell_at(action::event::bodyIndex)\n        ),\n        PAID_EXTERNALLY\n    );\n    return true;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/dispatch.fc",
        "content": "#include \"utils.fc\";\n\n#include \"call.fc\";\n\nconst int action::dispatch::NAME = \"dispatch\"u;\n\nconst int action::dispatch::to = 1;\nconst int action::dispatch::opcode = 2;\nconst int action::dispatch::md = 3;\nconst int action::dispatch::gasNanos = 4;\n\n;; Call a method on the contract at address `to` with the given message data `md`\n;; optionally provide value provisioned from this contract's balance\n;; @terminal\ntuple action::dispatch::create(int to, int opcode, cell $md, int gasNanos) inline {\n    return unsafeTuple([action::dispatch::NAME, to, opcode, $md, gasNanos]);\n}\n\n;; returns true if equals\nint action::dispatch::equals(tuple self, tuple other) {\n    int equalMdField = compareObjectFields(\n        self.cell_at(action::dispatch::md),\n        other.cell_at(action::dispatch::md)\n    );\n    return (\n        (self.int_at(0) == other.int_at(0 )) ;; NAME\n        & (self.int_at(action::dispatch::to) == other.int_at(action::dispatch::to))\n        & (self.int_at(action::dispatch::opcode) == other.int_at(action::dispatch::opcode))\n        & (equalMdField == -1)\n        & (self.int_at(action::dispatch::gasNanos) == other.int_at(action::dispatch::gasNanos))\n    );\n}\n\ntuple _newAction<dispatch>(int to, int opcode, cell $body, int gasNanos) inline {\n    return action::dispatch::create(to, opcode, $body, gasNanos);\n}\n\n;; overloaded when you want to pass 0 outflowNanos\n(tuple, ()) ~pushAction<dispatch>(tuple actions, int to, int opcode, cell $body, int gasNanos) inline {\n    return (actions.tpush(_newAction<dispatch>(to, opcode, $body, gasNanos)), ());\n}\n\nint executeDispatch(tuple dispatchAction) {\n    cell body = buildLayerzeroMessageBody(\n        0,\n        dispatchAction.int_at(action::call::opcode),\n        dispatchAction.cell_at(action::call::md)\n    );\n\n    (int cellsCount, int bitsCount, _) = body.compute_data_size(MAX_U16);\n\n    sendNonTerminalAction(\n        SEND_MSG_BOUNCEABLE,\n        dispatchAction.int_at(action::dispatch::gasNanos) + get_forward_fee(cellsCount, bitsCount, false),\n        dispatchAction.int_at(action::call::to),\n        body,\n        NORMAL\n    );\n    return true;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/deploy.fc",
        "content": "#include \"utils.fc\";\n\n;;; =======================================================\n;; Deploys a contract defined by the given code and storage object,\n;; and calls the contract with the given message data.\n;; Typical usage will be to deploy and initialize\n;;; =======================================================\nconst int action::deploy::NAME = \"deploy\"u;\n\nconst int action::deploy::code = 1;\nconst int action::deploy::storage = 2;\nconst int action::deploy::donationNanos = 3;\nconst int action::deploy::opcode = 4;\nconst int action::deploy::md = 5;\n;; @info reserve donationNanos nanoton as the deployed contract's rent + value\n;; @info in addition to the message value, use from_balance nanoton\n;; from the contract's balance to pay for the deploy\n;; @info e.g., if from_balance == outflowNanos, the entire rent is paid from the deployer\n;; contract's balance\nconst int action::deploy::outflowNanos = 6;\n\n;; @terminal\ntuple action::deploy::create(\n    cell code,\n    cell $storage,\n    int donationNanos,\n    int opcode,\n    cell $md,\n    int outflowNanos\n) impure inline {\n    return unsafeTuple(\n        [action::deploy::NAME, code, $storage, donationNanos, opcode, $md, outflowNanos]\n    );\n}\n\nint action::deploy::equals(tuple self, tuple other) impure {\n    int equalDataField = compareObjectFields(\n        self.cell_at(action::deploy::storage),\n        other.cell_at(action::deploy::storage)\n    );\n    int equalMdField = compareObjectFields(\n        self.cell_at(action::deploy::md),\n        other.cell_at(action::deploy::md)\n    );\n    return (\n        (self.int_at(0) == other.int_at(0)) ;; NAME\n        & (self.cell_at( action::deploy::code ).cell_hash() == other.cell_at( action::deploy::code ).cell_hash())\n        & (equalDataField == -1)\n        & (self.int_at(action::deploy::donationNanos) == other.int_at(action::deploy::donationNanos))\n        & (self.int_at(action::deploy::opcode) == other.int_at(action::deploy::opcode))\n        & (equalMdField == -1)\n        & (self.int_at(action::deploy::outflowNanos) == other.int_at(action::deploy::outflowNanos))\n    );\n}\n\ntuple _newAction<deployAndCall>(\n    cell code,\n    cell $storage,\n    int donationNanos,\n    int opcode,\n    cell $md,\n    int outflowNanos\n) impure inline {\n    return action::deploy::create(\n        code,\n        $storage,\n        donationNanos,\n        opcode,\n        $md,\n        outflowNanos\n    );\n}\n\n(tuple, ()) ~pushAction<deployAndCall>(\n    tuple actions,\n    cell code,\n    cell $storage,\n    int donationNanos,\n    int opcode,\n    cell $md,\n    int outflowNanos\n) impure inline {\n    return (\n        actions\n            .tpush(_newAction<deployAndCall>(\n                code,\n                $storage,\n                donationNanos,\n                opcode,\n                $md,\n                outflowNanos\n            )),\n        ()\n    );\n}\n\nint executeDeploy(tuple action) impure inline {\n    cell $storageObj = action.cell_at(action::deploy::storage);\n    cell codeCell = action.cell_at(action::deploy::code);\n\n    sendTerminalAction(\n        computeContractAddress($storageObj, codeCell),\n        buildLayerzeroMessageBody(\n            action.int_at(action::deploy::donationNanos),\n            action.int_at(action::deploy::opcode),\n            action.cell_at(action::deploy::md)\n        ),\n        begin_cell()\n            .store_uint(6, 5)\n            .store_ref(codeCell)\n            .store_ref($storageObj)\n            .end_cell(),\n        NORMAL\n    );\n\n    return false;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/stringlib.fc",
        "content": "#include \"utils.fc\";\n\n;;; ===============================STRING MANIPULATION FUNCTIONS===========================\n;; note that these functions are NOT optimized and should NOT be used in production code\n\nconst int ASCII_ZERO = 48;\nconst int ASCII_MASK = 0x1313131313131313131313131313131313131313131313131313131313131313;\nconst int ASCII_A = 65;\n\nslice str::asciiUint256ToStr(int asciiUint256) impure {\n    int leading_zeroes = _SDCNTLEAD0(begin_cell().store_uint256(asciiUint256).end_cell().begin_parse());\n    int trailing_bits = 256 - leading_zeroes;\n    int mask = POW2(trailing_bits) - 1;\n    return begin_cell().store_uint256(asciiUint256 | (ASCII_MASK & (~ mask))).end_cell().begin_parse();\n}\n\n(slice, ()) ~str::concat(slice self, slice other) impure {\n    if(self.slice_bits() + other.slice_bits() > 127 * MAX_U8) {\n        throwError(\"Cannot concatenate: string too long\");\n    }\n    return (begin_cell().store_slice(self).store_slice(other).end_cell().begin_parse(), ());\n}\n\nslice str::concat(slice self, slice other) impure {\n    self~str::concat(other);\n    return self;\n}\n\n(slice, ()) ~str::concatInt(slice self, int val) impure {\n    slice intSlice = empty_slice();\n    if (val < 0) {\n        self~str::concat(\"-\");\n        val = -1 * val;\n    }\n    if (val == 0) {\n        intSlice~str::concat(begin_cell().store_uint8(ASCII_ZERO).end_cell().begin_parse());\n    }\n    while (val > 0) {\n        intSlice = begin_cell().store_uint8(ASCII_ZERO + val % 10).end_cell().begin_parse().str::concat(intSlice);\n        val /= 10;\n    }\n    return (self.str::concat(intSlice), ());\n}\n\nslice str::concatInt(slice self, int val) impure {\n    self~str::concatInt(val);\n    return self;\n}\n\n(slice, ()) ~str::concatHex(slice self, int val) impure {\n    slice hexSlice = empty_slice();\n    if (val == 0) {\n        hexSlice~str::concat(begin_cell().store_uint8(ASCII_ZERO).end_cell().begin_parse());\n    }\n    while (val > 0) {\n        if (val % 16 <= 9) {\n            hexSlice = begin_cell().store_uint8(ASCII_ZERO + val % 16).end_cell().begin_parse().str::concat(hexSlice);\n        } else {\n            hexSlice = begin_cell().store_uint8(ASCII_A + val % 16 - 10).end_cell().begin_parse().str::concat(hexSlice);\n        }\n        val = (val >> 4); ;; val /= 16\n    }\n    return (self.str::concat(hexSlice), ());\n}\n\nslice str::concatHex(slice self, int val) impure {\n    self~str::concatHex(val);\n    return self;\n}\n\n() str::console::log<int>(slice string, int val) impure {\n    ~strdump(string.str::concat(\": \").str::concatInt(val));\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/classlib.fc",
        "content": "#include \"utils.fc\";\n#include \"stringlib.fc\";\n\n;; Types for storage abstraction\nconst int cl::t::bool = 0;\nconst int cl::t::uint8 = 3;\nconst int cl::t::uint16 = 4;\nconst int cl::t::uint32 = 5;\nconst int cl::t::uint64 = 6;\nconst int cl::t::coins = 7; ;; fixed-width uint128, because we are civilized people\nconst int cl::t::uint256 = 8;\nconst int cl::t::address = cl::t::uint256;\nconst int cl::t::cellRef = 9;\nconst int cl::t::dict256 = cl::t::cellRef;\nconst int cl::t::objRef = cl::t::cellRef;\nconst int cl::t::addressList = cl::t::cellRef;\n\nconst int DICT256_KEYLEN = 256;\n\nconst int cl::NULL_CLASS_NAME = \"NULL\"u;\n\nconst int cl::ERROR::INVALID_CLASS = 1057;\nconst int cl::ERROR::MALFORMED_OBJECT = 1058;\n\n\nconst int MAX_NAME_LEN = 10; ;; each name can be up to 10 characters long\nconst int _NAME_WIDTH = 8 * MAX_NAME_LEN; ;; convert to bits\nconst int _BASIC_HEADER_WIDTH = _NAME_WIDTH;\nconst int MAX_NAME_INTLEN = (1 << (8 * MAX_NAME_LEN)) - 1;\n\nconst int _FIELD_TYPE_WIDTH+_CELL_ID_WIDTH = 6; ;; support up to 16 types\n\nconst int _FIELD_TYPE_WIDTH = 4; ;; support up to 16 types\nconst int _CELL_ID_WIDTH = 2; ;; the classlib backend supports up to 4 inner cells including root\nconst int _DATA_OFFSET_WIDTH = 10; ;; 1023 bits per cell = 2**10 - 1\nconst int _REF_OFFSET_WIDTH = 2; ;; each cell can have up to 4 refs\nconst int _FIELD_INFO_WIDTH = _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH + _DATA_OFFSET_WIDTH + _REF_OFFSET_WIDTH;\nconst int _MAX_CLASS_FIELDS = 15; ;; reserve 0xff for the \"invalid\" object field name\nconst int INVALID_CLASS_MEMBER = 15;\nconst int _HEADER_WIDTH = _BASIC_HEADER_WIDTH + _MAX_CLASS_FIELDS * _FIELD_INFO_WIDTH;\n\n;; declarations require a tuple of the form [[ type, val ], ...]\nconst int FIELD_TYPE_IDX = 0;\nconst int FIELD_VAL_IDX = 1;\n\n;;; ====================== Class functions ======================\n;; returns type width in bits\nint _getTypeWidth(int clType) impure inline {\n    if (clType <= cl::t::uint256) {\n        return 1 << clType; ;; type names are set up so this is true\n    }\n    ;; all other types are ref types with 0 data bits\n    return 0;\n}\n\nint cl::hash(cell $obj) impure inline {\n    return $obj.cell_hash();\n}\n\nint cl::isNullObject(cell $obj) impure inline {\n    return $obj.cell_is_empty();\n}\n\n;; checks if a class lib object is flat, and contains no 'refs'\n;; null is considered 'flat'\nint cl::noRefFields(cell $obj) impure {\n    slice headerSlice = $obj.begin_parse();\n    int numRefs = headerSlice.slice_refs();\n\n    if (numRefs == 0) {\n        return true;\n    } elseif (numRefs <= 2) {\n        ;; if there are refs, the struct is not flat\n        return false;\n    }\n\n    if (numRefs >= 3) {\n        if (\n            (headerSlice.preload_ref_at(0).cell_is_empty() == false)\n            | (headerSlice.preload_ref_at(1).cell_is_empty() == false)\n            | (headerSlice.preload_ref_at(2).begin_parse().slice_refs() != 0)\n        ) {\n            ;; if there is 1 structural node, that structural node must have 0 refs\n            return false;\n        }\n    }\n\n    if (numRefs >= 4) {\n        if (headerSlice.preload_ref_at(3).begin_parse().slice_refs() != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint cl::equalObjTypeShallow(cell $a, cell $b) impure {\n    slice aSlice = $a.begin_parse();\n    slice bSlice = $b.begin_parse();\n    int aRefs = aSlice.slice_refs();\n\n    if (\n        (aRefs != bSlice.slice_refs())\n        | (aSlice.slice_bits() != bSlice.slice_bits())\n    ) {\n        return false;\n    }\n\n    int refIndex = 2;\n    while (refIndex < aRefs) {\n        if (\n            (aSlice.preload_ref_at(refIndex).begin_parse().slice_refs() != bSlice.preload_ref_at(refIndex).begin_parse().slice_refs())\n            | (aSlice.preload_ref_at(refIndex).begin_parse().slice_bits() != bSlice.preload_ref_at(refIndex).begin_parse().slice_bits())\n        ) {\n            return false;\n        }\n        refIndex += 1;\n    }\n\n    return true;\n}\n\nint cl::typeof(cell $obj) impure inline method_id {\n    if (cl::isNullObject($obj)) {\n        return cl::NULL_CLASS_NAME;\n    }\n    return $obj.begin_parse().preload_uint(_NAME_WIDTH);\n}\n\ncell cl::declare(int name, tuple fields) impure inline {\n    ;; Initialize a tuple with [null, empty_builder] to store cell builders\n    tuple classBuilder = unsafeTuple([null(), begin_cell()]);\n\n    ;; Get number of fields of the object we want to create\n    int num_fields = fields.tlen();\n    ;; Start building header with class name\n    builder headerBuilder = begin_cell().store_uint(name, _NAME_WIDTH);\n\n    ;; Initialize tracking variables\n    int curDataCell = 1;                ;; Current cell for storing data fields\n    int curRefCell = 1;                 ;; Current cell for storing reference fields\n    ;; root node is special as it only allows two ref fields\n    int curCellMaxRefs = 2;             ;; Max references allowed in current cell \n    int curDataOffset = _HEADER_WIDTH;  ;; Current bit offset in data cell\n    int curRefOffset = 0;               ;; Current reference offset in ref cell\n\n    ;; Iterate through all fields\n    int curField = 0;\n    while (curField < num_fields) {\n        ;; Get current field and its type from tuple\n        tuple field = fields.tuple_at(curField);\n        int fieldType = field.int_at(FIELD_TYPE_IDX);\n        \n        ;; Get number of bits needed for this field type\n        ;; (2^{bitLength} for uints, 0 for Refs)\n        int fieldBits = _getTypeWidth(fieldType);\n\n        if (fieldBits > 0) {\n            ;; If adding this integer field would exceed cell bit limit\n            if ((curDataOffset + fieldBits) > MAX_CELL_BITS) {\n                curDataCell += 1;  ;; Move to next cell\n                curDataOffset = 0; ;; Reset bit offset\n                ;; Add new cell builder if needed\n                if (curDataCell >= classBuilder.tlen()) {\n                    classBuilder = classBuilder.tpush(begin_cell());\n                }\n            }\n        } else {\n            ;; For reference types (fieldBits == 0)\n            ;; If adding this ref would exceed cell ref limit\n            if ((curRefOffset + 1) > curCellMaxRefs) {\n                curRefCell += 1;  ;; Move to next cell\n                curRefOffset = 0; ;; Reset ref offset\n                curCellMaxRefs = MAX_CELL_REFS;  ;; Use max refs for non-root cells\n                ;; Add new cell builder if needed\n                if (curRefCell >= classBuilder.tlen()) {\n                    classBuilder = classBuilder.tpush(begin_cell());\n                }\n            }\n        }\n\n        ;; Store field value based on type\n        if (fieldType <= cl::t::address) {\n            ;; For numeric types, store as uint\n            classBuilder = classBuilder.tset(\n                curDataCell,\n                cast_to_builder(classBuilder.at(curDataCell))\n                    .store_uint(abs(field.int_at(FIELD_VAL_IDX)), fieldBits)\n            );\n        } elseif (fieldType == cl::t::objRef) {\n            ;; For object references, store as ref\n            classBuilder = classBuilder.tset(\n                curRefCell,\n                cast_to_builder(classBuilder.at(curRefCell))\n                    .store_ref(field.cell_at(FIELD_VAL_IDX))\n            );\n        } else {\n            throw(CLASSLIB::ERROR::INVALID_FIELD_TYPE);\n        }\n\n        ;; Build field metadata in header\n        headerBuilder = headerBuilder\n            .store_uint(fieldType, _FIELD_TYPE_WIDTH);\n        if (fieldBits > 0) {\n            ;; For data fields, store cell index, bit offset, and ref offset\n            headerBuilder = headerBuilder\n                .store_uint(curDataCell == 1 ? 0 : curDataCell, _CELL_ID_WIDTH)\n                .store_uint(curDataOffset, _DATA_OFFSET_WIDTH)\n                .store_uint(3, _REF_OFFSET_WIDTH);\n            curDataOffset += fieldBits;\n        } else {\n            ;; For ref fields, store cell index and ref offset\n            headerBuilder = headerBuilder\n                .store_uint(curRefCell == 1 ? 0 : curRefCell, _CELL_ID_WIDTH)\n                .store_uint(MAX_CELL_BITS, _DATA_OFFSET_WIDTH)\n                .store_uint(curRefOffset, _REF_OFFSET_WIDTH);\n            curRefOffset += 1;\n        }\n        curField += 1;\n    }\n\n    ;; Get root cell builder and count total cells\n    builder rootBuilder = classBuilder.at(1);\n    int numCells = classBuilder.tlen() - 1;\n\n    ;; For multi-cell objects, ensure root has exactly 2 refs\n    if (numCells > 1) {\n        if (rootBuilder.builder_refs() == 0) {\n            rootBuilder = rootBuilder\n                .store_ref(empty_cell())\n                .store_ref(empty_cell());\n        } elseif (rootBuilder.builder_refs() == 1) {\n            rootBuilder = rootBuilder\n                .store_ref(empty_cell());\n        }\n    }\n\n    ;; Finalize header and combine with root cell\n    headerBuilder = headerBuilder\n        .store_ones(_HEADER_WIDTH - headerBuilder.builder_bits())\n        .store_builder(rootBuilder);\n\n    ;; Return final cell based on number of cells used\n    if (numCells == 1) {\n        return headerBuilder.end_cell();\n    }\n    if (numCells == 2) {\n        return headerBuilder\n            .store_ref(classBuilder.at(2).end_cell())\n            .end_cell();\n    }\n    return headerBuilder\n        .store_ref(classBuilder.at(2).end_cell())\n        .store_ref(classBuilder.at(3).end_cell())\n        .end_cell();\n}\n\ncell cl::nullObject() impure inline method_id {\n    return empty_cell();\n}\n\n;;; ====================== Class Setter ======================\nint cl::getFieldType::asm(slice self, int fieldInfoOffset) asm \"\"\"\n// STACK: left -> right: bottom -> top //\n// Setup       // STACK [ headerSlice, fieldInfoOffset ]\n4 PUSHINT      // STACK [ headerSlice, fieldInfoOffset, _FIELD_TYPE_WIDTH ]\nSDSUBSTR       // STACK [ substring ]\n4 PLDU         // STACK [ 2BitUnsignInt ]\n\"\"\";\n\nint cl::getFieldCellIndex::asm(slice self, int fieldInfoOffset) asm \"\"\"\n// STACK: left -> right: bottom -> top //\n// Setup       // STACK [ headerSlice, fieldInfoOffset ]\n4 ADDCONST     // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH ]\n2 PUSHINT      // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH, _CELL_ID_WIDTH ]\nSDSUBSTR       // STACK [ substring ]\n2 PLDU         // STACK [ 2BitUnsignInt ]\n\"\"\";\n\nint cl::getFieldOffset::asm(slice self, int fieldInfoOffset) asm \"\"\"\n// STACK: left -> right: bottom -> top //\n// Setup       // STACK [ headerSlice, fieldInfoOffset ]\n6 ADDCONST     // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH ]\n10 PUSHINT     // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH, _DATA_OFFSET_WIDTH ]\nSDSUBSTR       // STACK [ substring ]\n10 PLDU        // STACK [ 10BitUnsignInt ]\n\"\"\";\n\nint cl::getFieldCellOffset::asm(slice self, int fieldInfoOffset) asm \"\"\"\n// STACK: left -> right: bottom -> top //\n// Setup        // STACK [ headerSlice, fieldInfoOffset ]\n16 ADDCONST     // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH + _DATA_OFFSET_WIDTH ]\n2 PUSHINT       // STACK [ headerSlice, fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH + _DATA_OFFSET_WIDTH, _REF_OFFSET_WIDTH ]\nSDSUBSTR        // STACK [ substring ]\n2 PLDU          // STACK [ 10BitUnsignInt ]\n\"\"\";\n\nint cl::preload_bits_offset_3::asm(int width1, slice self, int fieldOffset, int width2) asm \"\"\"\n// STACK: left -> right: bottom -> top //\n// Setup        // STACK [ width1, headerSlice, fieldOffset, width2 ]\nSDSUBSTR        // STACK [ width1, substring ]\ns1 XCHG0        // STACK [ substring, width1 ]\nPLDUX           // STACK [ 10BitUnsignInt ] ( CC + 1 )\n\"\"\";\n\nforall X -> cell cl::set(cell $self, int fieldName, X val) impure inline method_id {\n    slice headerSlice = $self.begin_parse();\n    int fieldInfoOffset = _BASIC_HEADER_WIDTH + (fieldName * _FIELD_INFO_WIDTH);\n    int fieldCellIndex = headerSlice.cl::getFieldCellIndex::asm(fieldInfoOffset);\n    int fieldType = headerSlice.cl::getFieldType::asm(fieldInfoOffset);\n    int fieldOffset = headerSlice.cl::getFieldOffset::asm(fieldInfoOffset);\n    int fieldRefsOffset = headerSlice.cl::getFieldCellOffset::asm(fieldInfoOffset);\n\n    int fieldWidth = _getTypeWidth(fieldType);\n\n    slice victim = fieldCellIndex == 0\n        ? headerSlice\n        : headerSlice.preload_ref_at(fieldCellIndex).begin_parse();\n    if (fieldWidth != 0) {\n        fieldRefsOffset = MAX_CELL_REFS;\n    }\n\n    builder replacement = begin_cell()\n        .store_slice(\n            victim.scutfirst(\n                min(victim.slice_bits(), fieldOffset),\n                min(fieldRefsOffset, victim.slice_refs())\n            )\n        );\n\n    if (fieldType == cl::t::cellRef) {\n        replacement = replacement\n            .store_ref(val.cast_to_cell())\n            .store_slice(victim.scutlast(0, victim.slice_refs() - fieldRefsOffset - 1));\n    } else {\n        ;; numeric type\n        replacement = replacement\n            .store_uint(abs(val.cast_to_int()), fieldWidth)\n            .store_slice(victim.sskipfirst(fieldOffset + fieldWidth, victim.slice_refs()));\n    }\n\n    if (fieldCellIndex > 0) {\n        ;; link the replacement into the root cell\n        return begin_cell()\n            .store_slice(headerSlice.scutfirst(headerSlice.slice_bits(), fieldCellIndex))\n            .store_ref(replacement.end_cell())\n            .store_slice(headerSlice.scutlast(0, headerSlice.slice_refs() - fieldCellIndex - 1))\n            .end_cell();\n    }\n    return replacement.end_cell();\n}\n;;; ====================== Class Getters ======================\n\nconst int _NAME_WIDTH = 8 * MAX_NAME_LEN; ;; convert to bits\nconst int _BASIC_HEADER_WIDTH = _NAME_WIDTH;\nconst int MAX_NAME_INTLEN = (1 << (8 * MAX_NAME_LEN)) - 1;\n\nconst int _FIELD_TYPE_WIDTH = 4; ;; support up to 16 types\nconst int _CELL_ID_WIDTH = 2; ;; the classlib backend supports up to 4 inner cells including root\nconst int _DATA_OFFSET_WIDTH = 10; ;; 1023 bits per cell = 2**10 - 1\n\n\nint cl::get<uint>(cell $self, int fieldName, int width) impure inline method_id {\n    slice headerSlice = $self.begin_parse();\n\n    int fieldInfoOffset = _BASIC_HEADER_WIDTH + (fieldName * _FIELD_INFO_WIDTH);\n    int fieldCellIndex = headerSlice.cl::getFieldCellIndex::asm(fieldInfoOffset);\n    int fieldOffset = headerSlice.cl::getFieldOffset::asm(fieldInfoOffset);\n\n    if (fieldCellIndex == 0) {\n        return cl::preload_bits_offset_3::asm(width, headerSlice, fieldOffset, width);\n    } else {\n        return cl::preload_bits_offset_3::asm(width, headerSlice.preload_ref_at(fieldCellIndex).begin_parse(), fieldOffset,  width);\n    }\n}\n\ncell cl::get<cellRef>(cell $self, int fieldName) impure inline method_id {\n    slice headerSlice = $self.begin_parse();\n    int fieldInfoOffset = _BASIC_HEADER_WIDTH + (fieldName * _FIELD_INFO_WIDTH);\n    int fieldCellIndex = headerSlice.cl::getFieldCellIndex::asm(fieldInfoOffset);\n    int fieldRefIdx = headerSlice.cl::getFieldCellOffset::asm(fieldInfoOffset);\n\n    if (fieldCellIndex == 0) {\n        return headerSlice.preload_ref_at(fieldRefIdx);\n    }\n\n    return headerSlice\n        .preload_ref_at(fieldCellIndex)\n        .begin_parse()\n        .preload_ref_at(fieldRefIdx)\n    ;\n}\n\ncell cl::get<objRef>(cell $self, int fieldName) impure inline method_id {\n    return cl::get<cellRef>($self, fieldName);\n}\n\nint cl::get<uint8>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 8);\n}\n\nint cl::get<uint16>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 16);\n}\n\nint cl::get<uint32>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 32);\n}\n\nint cl::get<uint64>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 64);\n}\n\nint cl::get<coins>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 128);\n}\n\nint cl::get<uint256>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 256);\n}\n\nslice cl::get<std_address>(cell $self, int fieldName) impure inline method_id {\n    return hashpartToBasechainAddressStd(\n        $self.cl::get<uint>(fieldName, 256)\n    );\n}\n\nint cl::get<bool>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 1) != 0;\n}\n\ncell cl::get<dict256>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<cellRef>(fieldName);\n}\n\nint cl::get<address>(cell $self, int fieldName) impure inline method_id {\n    return $self.cl::get<uint>(fieldName, 256);\n}\n\n;;; =============== DEBUG / CONVENIENCE FUNCTIONS =================\nint typeofField(cell $self, int fieldName) impure inline {\n    slice headerSlice = $self.begin_parse();\n    int fieldInfoOffset = _BASIC_HEADER_WIDTH + (fieldName * _FIELD_INFO_WIDTH);\n    return headerSlice\n        .preload_bits_offset(\n            fieldInfoOffset,\n            _FIELD_TYPE_WIDTH\n        )\n        .preload_uint(_FIELD_TYPE_WIDTH);\n}\n\n;; returns -1 (true) if equal, otherwise the index of the first field that differs\n;; returns 16 if the types of the objects are not equal\nint compareObjectFields(cell $lhs, cell $rhs) impure inline {\n    int malformed = cl::typeof($lhs) != cl::typeof($rhs);\n    if (malformed) {\n        return INVALID_CLASS_MEMBER;\n    }\n    if (cl::typeof($lhs) == cl::NULL_CLASS_NAME) {\n        return -1;\n    }\n    int fieldIndex = 0;\n    while (fieldIndex < INVALID_CLASS_MEMBER) {\n        int curFieldType = $lhs.typeofField(fieldIndex);\n        if (curFieldType == cl::t::cellRef) {\n            malformed = $lhs.cl::get<objRef>(fieldIndex).cl::hash() != $rhs.cl::get<objRef>(fieldIndex).cl::hash();\n            if (malformed) {\n                ~dump($lhs.cl::get<objRef>(fieldIndex).cell_hash());\n                ~dump($rhs.cl::get<objRef>(fieldIndex).cell_hash());\n            }\n        } elseif (curFieldType <= cl::t::uint256) {\n            int cur_field_width = _getTypeWidth(curFieldType);\n            malformed = $lhs.cl::get<uint>(fieldIndex, cur_field_width) != $rhs.cl::get<uint>(fieldIndex, cur_field_width);\n            if (malformed) {\n                str::console::log<int>(\"lhs: \", $lhs.cl::get<uint>(fieldIndex, cur_field_width));\n                str::console::log<int>(\"rhs: \", $rhs.cl::get<uint>(fieldIndex, cur_field_width));\n            }\n        } else {\n            ;; Finished iteration\n            return -1;\n        }\n        if (malformed) {\n            ~strdump(\"Malformed field\");\n            ~dump(fieldIndex);\n            return fieldIndex;\n        }\n        fieldIndex += 1;\n    }\n    return -1;\n}\n\nint objectsAreEqual(cell $lhs, cell $rhs) impure inline {\n    return compareObjectFields($lhs, $rhs) == -1;\n}\n\nslice _typeToStr(int fieldType) impure {\n    if     (fieldType == cl::t::uint8)   { return \"uint8\";   }\n    elseif (fieldType == cl::t::uint16)  { return \"uint16\";  }\n    elseif (fieldType == cl::t::uint32)  { return \"uint32\";  }\n    elseif (fieldType == cl::t::uint64)  { return \"uint64\";  }\n    elseif (fieldType == cl::t::uint256) { return \"uint256\"; }\n    elseif (fieldType == cl::t::coins)   { return \"coins\";   }\n    elseif (fieldType == cl::t::address) { return \"address\"; }\n    elseif (fieldType == cl::t::dict256) { return \"dict256\"; }\n    elseif (fieldType == cl::t::objRef)  { return \"objRef\";  }\n    elseif (fieldType == cl::t::cellRef) { return \"cellRef\"; }\n    elseif (fieldType == cl::t::bool)    { return \"bool\";    }\n    else                                 { return \"unknown\"; }\n}\n\n() printField(cell $obj, int fieldName) impure inline {\n    slice headerSlice = $obj.begin_parse();\n    int fieldType = typeofField($obj, fieldName);\n    int fieldInfoOffset = _BASIC_HEADER_WIDTH + (fieldName * _FIELD_INFO_WIDTH);\n    int fieldCellIndex = headerSlice\n        .preload_bits_offset(\n            fieldInfoOffset + _FIELD_TYPE_WIDTH,\n            _CELL_ID_WIDTH\n        )\n        .preload_uint(_CELL_ID_WIDTH);\n    int fieldRefIdx = headerSlice\n        .preload_bits_offset(\n            fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH + _DATA_OFFSET_WIDTH,\n            _REF_OFFSET_WIDTH\n        )\n        .preload_uint(_REF_OFFSET_WIDTH);\n\n    int fieldBits = _getTypeWidth(fieldType);\n    int fieldOffset = headerSlice\n        .preload_bits_offset(\n            fieldInfoOffset + _FIELD_TYPE_WIDTH + _CELL_ID_WIDTH,\n            _DATA_OFFSET_WIDTH\n        )\n        .preload_uint(_DATA_OFFSET_WIDTH);\n\n    slice toPrint = _typeToStr(fieldType)\n        .str::concat(\" \")\n        .str::concatInt(fieldName)\n        .str::concat(\" at c\")\n        .str::concatInt(fieldCellIndex);\n    if (fieldBits > 0) {\n        toPrint = toPrint.str::concat(\".b\").str::concatInt(fieldOffset);\n    } else {\n        toPrint = toPrint.str::concat(\".r\").str::concatInt(fieldRefIdx);\n    }\n    if (fieldType <= cl::t::uint256) {\n        ~strdump(\n            toPrint\n                .str::concat(\" = \")\n                .str::concatInt($obj.cl::get<uint>(fieldName, fieldBits))\n        );\n    } elseif (fieldType == cl::t::objRef) {\n        ~strdump(toPrint\n            .str::concat(\" hash = \")\n            .str::concatInt($obj.cl::get<objRef>(fieldName).cl::hash())\n        );\n    } else {\n        ~strdump(toPrint\n            .str::concat(\" hash = \")\n            .str::concatInt($obj.cl::get<cellRef>(fieldName).cell_hash())\n        );\n    }\n}\n\n;; doesn't actually return a tuple, just pushes something to the stack casted to a tuple\ntuple getObjectField(cell $storage, int field) impure {\n    int fieldType = typeofField($storage, field);\n    int fieldBits = _getTypeWidth(fieldType);\n    if (fieldType == cl::t::bool) {\n        return unsafeTuple($storage.cl::get<bool>(field));\n    } elseif (fieldType <= cl::t::uint256) {\n        return unsafeTuple($storage.cl::get<uint>(field, fieldBits));\n    }\n    return unsafeTuple($storage.cl::get<cellRef>(field));\n}\n\n;; doesn't actually return a tuple, just pushes something to the stack casted to a tuple\ntuple getContractStorageField(int field) impure method_id {\n    return getObjectField(getContractStorage(), field);\n}\n\n;; doesn't actually return a tuple, just pushes something to the stack casted to a tuple\ntuple getContractStorageNestedField(int field, int nestedField) impure method_id {\n    return getObjectField(cast_to_cell(getContractStorageField(field)), nestedField);\n}\n\n;;; ====================== Dictionary functions ======================\n\nslice uint256ToSlice(int val) impure inline {\n    return begin_cell().store_uint256(val).as_slice();\n}\n\nint sliceToUint256(slice s) impure inline {\n    return s.preload_uint(256);\n}\n\n;; override the insane behavior of TON to optimize out empty dictionaries\n;; into a single bit\ncell cl::dict256::New() impure inline {\n    return empty_cell();\n}\n\n(slice, int) cl::dict256::get(cell dict, int key) impure inline method_id {\n    if (dict.cell_is_empty()) {\n        return (null(), false);\n    }\n    return dict.udict_get?(DICT256_KEYLEN, key);\n}\n\n(int, int) cl::dict256::get<uint256>(cell dict, int key) impure inline method_id {\n    (slice val, int exists) = cl::dict256::get(dict, key);\n    if (exists) {\n        return (sliceToUint256(val), true);\n    }\n    return (0, false);\n}\n\n(cell, int) cl::dict256::get<cellRef>(cell dict, int key) impure inline method_id {\n    if (dict.cell_is_empty()) {\n        return (null(), false);\n    }\n    (cell ret, int exists) = dict.udict_get_ref?(DICT256_KEYLEN, key);\n    ifnot (exists) {\n        return (null(), false);\n    }\n    return (ret, true);\n}\n\ncell cl::dict256::setRef(cell dict, int key, cell val) impure inline method_id {\n    if (dict.cell_is_empty()) {\n        return new_dict().udict_set_ref(\n            DICT256_KEYLEN,\n            key,\n            val.cast_to_cell()\n        );\n    }\n    return dict.udict_set_ref(DICT256_KEYLEN, key, val.cast_to_cell());\n}\n\nforall X -> cell cl::dict256::set(cell dict, int key, X val) impure inline {\n    slice _val = val.is_slice() ? val.cast_to_slice() : uint256ToSlice(val.cast_to_int());\n    if (dict.cell_is_empty()) {\n        return new_dict().udict_set(DICT256_KEYLEN, key, _val);\n    }\n    return dict.udict_set(DICT256_KEYLEN, key, _val);\n}\n\ncell cl::dict256::delete(cell dict, int key) impure {\n    if (dict.cell_is_empty()) {\n        return dict;\n    }\n    (cell modified_dict, _) = dict.udict_delete?(DICT256_KEYLEN, key);\n    return modified_dict.is_cell() ? modified_dict : cl::dict256::New();\n}\n\n;;; ====================== Dictionary Iterators ======================\n;; returns key, val, and key == -1 if there is no next (or min) element\n;; if the val exists, it is returned\n;; if a val does not exist, null() is returned\n\n(int, slice) cl::dict256::getMin<slice>(cell dict256) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, slice val, int exists) = dict256.udict_get_min?(DICT256_KEYLEN);\n    if (exists) {\n        return (key, val);\n    }\n    return (-1, null());\n}\n\n(int, int) cl::dict256::getMin<uint256>(cell dict256) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, slice val, int exists) = dict256.udict_get_min?(DICT256_KEYLEN);\n    if (exists) {\n        return (key, val.preload_uint(256));\n    }\n    return (-1, null());\n}\n\n(int, cell) cl::dict256::getMin<cellRef>(cell dict256) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, cell val, int exists) = dict256.udict_get_min_ref?(DICT256_KEYLEN);\n    if (exists) {\n        return (key, val);\n    }\n    return (-1, null());\n}\n\n(int, slice) cl::dict256::getNext<slice>(cell dict256, int pivot) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, slice val, int exists) = dict256.udict_get_next?(DICT256_KEYLEN, pivot);\n    if (exists) {\n        return (key, val);\n    }\n    return (-1, null());\n}\n\n(int, int) cl::dict256::getNext<uint256>(cell dict256, int pivot) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, slice val, int exists) = dict256.udict_get_next?(DICT256_KEYLEN, pivot);\n    if (exists) {\n        return (key, val.preload_uint(256));\n    }\n    return (-1, null());\n}\n\n(int, cell) cl::dict256::getNext<cellRef>(cell dict256, int pivot) impure inline {\n    if (dict256.cell_is_empty()) {\n        return (-1, null());\n    }\n    (int key, slice val, int exists) = dict256.udict_get_next?(DICT256_KEYLEN, pivot);\n    if (exists) {\n        return (key, val.preload_first_ref());\n    }\n    return (-1, null());\n}\n\nint cl::dict256::size(cell dict) impure inline method_id {\n    int count = 0;\n    (int pivot, _) = dict.cl::dict256::getMin<slice>();\n    while (pivot >= 0) {\n        (pivot, _) = dict.cl::dict256::getNext<slice>(pivot);\n        count = count + 1;\n    }\n    return count;\n}\n\n;;; ====================== Nested Dict Helpers ======================\n\nforall X -> cell cl::nestedDict256::set(cell $self, int fieldName, int key, X val) impure inline {\n    return $self.cl::set(\n        fieldName,\n        $self\n            .cl::get<dict256>(fieldName)\n            .cl::dict256::set(key, val)\n    );\n}\n\ncell cl::nestedDict256::setRef(cell $self, int fieldName, int key, cell val) impure inline {\n    return $self.cl::set(\n        fieldName,\n        $self.cl::get<dict256>(fieldName).cl::dict256::setRef(key, val)\n    );\n}\n\ncell cl::nestedDict256::delete(cell $self, int fieldName, int key) impure inline {\n    return $self.cl::set(\n        fieldName,\n        $self.cl::get<dict256>(fieldName).cl::dict256::delete(key)\n    );\n}\n\n(int, int) cl::nestedDict256::get<uint256>(cell $self, int fieldName, int key) impure inline {\n    return $self.cl::get<dict256>(fieldName).cl::dict256::get<uint256>(key);\n}\n\n(slice, int) cl::nestedDict256::get<slice>(cell $self, int fieldName, int key) impure inline {\n    return $self.cl::get<dict256>(fieldName).cl::dict256::get(key);\n}\n\n(cell, int) cl::nestedDict256::get<cellRef>(cell $self, int fieldName, int key) impure inline {\n    (slice s, int exists) = $self.cl::get<dict256>(fieldName).cl::dict256::get(key);\n    if (exists) {\n        return (s.preload_first_ref(), true);\n    }\n    return (null(), false);\n}\n\n;; ========================= Storage View Functions =========================\n\n;; -- Level 0: returns storage.fieldName\nint getStorageFieldL0<uint>(int fieldName) impure method_id {\n    cell $storage = getContractStorage();\n    int fieldType = typeofField($storage, fieldName);\n    int typeWidth = _getTypeWidth(fieldType);\n    return cl::get<uint>($storage, fieldName, typeWidth);\n}\n\ncell getStorageFieldL0<cellRef>(int fieldName) impure method_id {\n    return cl::get<cellRef>(\n        getContractStorage(),\n        fieldName\n    );\n}\n\ncell getStorageFieldL0<objRef>(int fieldName) impure method_id {\n    return cl::get<objRef>(\n        getContractStorage(),\n        fieldName\n    );\n}\n\n;; -- Level 1: returns storage.fieldName.nestedFieldName\nint getStorageFieldL1<uint>(int fieldName, int nestedFieldName) impure method_id {\n    cell field = getStorageFieldL0<cellRef>(fieldName);\n    int nestedFieldType = typeofField(field, nestedFieldName);\n    int nestedFieldWidth = _getTypeWidth(nestedFieldType);\n    return cl::get<uint>(field, nestedFieldName, nestedFieldWidth);\n}\n\ncell getStorageFieldL1<cellRef>(int fieldName, int nestedFieldName) impure method_id {\n    return cl::get<cellRef>(\n        getStorageFieldL0<cellRef>(fieldName),\n        nestedFieldName\n    );\n}\n\ncell getStorageFieldL1<objRef>(int fieldName, int nestedFieldName) impure method_id {\n    return cl::get<objRef>(\n        getStorageFieldL0<objRef>(fieldName),\n        nestedFieldName\n    );\n}\n\n;; returns storage.fieldName[key]\ncell getStorageFieldL1<dict256::cellRef>(int fieldName, int key) impure method_id {\n    (cell field, int exists) = cl::dict256::get<cellRef>(\n        getStorageFieldL0<cellRef>(fieldName),\n        key\n    );\n    if (exists) {\n        return field;\n    }\n    return cl::nullObject();\n}\n\nint getStorageFieldL1<dict256::uint256>(int fieldName, int key) impure method_id {\n    (int field, int exists) = cl::dict256::get<uint256>(\n        getStorageFieldL0<cellRef>(fieldName),\n        key\n    );\n    if (exists) {\n        return field;\n    }\n    return -1;\n}\n\n;; Level 2: returns storage.fieldName[outerKey][innerKey]\ncell getStorageFieldL2<dict256::cellRef>(int fieldName, int outerKey, int innerKey) impure method_id {\n    (cell field, int exists) = cl::dict256::get<cellRef>(\n        getStorageFieldL1<dict256::cellRef>(fieldName, outerKey),\n        innerKey\n    );\n    if (exists) {\n        return field;\n    }\n    return cl::nullObject();\n}\n\nint getStorageFieldL2<dict256::uint256>(int fieldName, int outerKey, int innerKey) impure method_id {\n    (int field, int exists) = cl::dict256::get<uint256>(\n        getStorageFieldL1<dict256::cellRef>(fieldName, outerKey),\n        innerKey\n    );\n    if (exists) {\n        return field;\n    }\n    return -1;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\n{-\n    This file is part of TON FunC Standard Library.\n\n    FunC Standard Library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    FunC Standard Library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n-}\n\n{-\n  # Tuple manipulation primitives\n  The names and the types are mostly self-explaining.\n  See [polymorhism with forall](https://ton.org/docs/#/func/functions?id=polymorphism-with-forall)\n  for more info on the polymorphic functions.\n\n  Note that currently values of atomic type `tuple` can't be cast to composite tuple type (e.g. `[int, cell]`)\n  and vise versa.\n-}\n\n{-\n  # Lisp-style lists\n\n  Lists can be represented as nested 2-elements tuples.\n  Empty list is conventionally represented as TVM `null` value (it can be obtained by calling [null()]).\n  For example, tuple `(1, (2, (3, null)))` represents list `[1, 2, 3]`. Elements of a list can be of different types.\n-}\n\n;;; Adds an element to the beginning of lisp-style list.\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\n\n;;; Extracts the head and the tail of lisp-style list.\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\n\n;;; Extracts the tail and the head of lisp-style list.\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\n\n;;; Returns the head of lisp-style list.\nforall X -> X car(tuple list) asm \"CAR\";\n\n;;; Returns the tail of lisp-style list.\ntuple cdr(tuple list) asm \"CDR\";\n\n;;; Creates tuple with zero elements.\ntuple empty_tuple() asm \"NIL\";\n\n;;; Appends a value `x` to a `Tuple t = (x1, ..., xn)`, but only if the resulting `Tuple t' = (x1, ..., xn, x)`\n;;; is of length at most 255. Otherwise throws a type check exception.\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\n\n;;; Creates a tuple of length one with given argument as element.\nforall X -> [X] single(X x) asm \"SINGLE\";\n\n;;; Unpacks a tuple of length one\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\n\n;;; Creates a tuple of length two with given arguments as elements.\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\n\n;;; Unpacks a tuple of length two\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\n\n;;; Creates a tuple of length three with given arguments as elements.\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\n\n;;; Unpacks a tuple of length three\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\n\n;;; Creates a tuple of length four with given arguments as elements.\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\n\n;;; Unpacks a tuple of length four\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\n\n;;; Returns the first element of a tuple (with unknown element types).\nforall X -> X first(tuple t) asm \"FIRST\";\n\n;;; Returns the second element of a tuple (with unknown element types).\nforall X -> X second(tuple t) asm \"SECOND\";\n\n;;; Returns the third element of a tuple (with unknown element types).\nforall X -> X third(tuple t) asm \"THIRD\";\n\n;;; Returns the fourth element of a tuple (with unknown element types).\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\n\n;;; Returns the first element of a pair tuple.\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\n\n;;; Returns the second element of a pair tuple.\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\n\n;;; Returns the first element of a triple tuple.\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\n\n;;; Returns the second element of a triple tuple.\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\n\n;;; Returns the third element of a triple tuple.\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\n\n\n;;; Push null element (casted to given type)\n;;; By the TVM type `Null` FunC represents absence of a value of some atomic type.\n;;; So `null` can actually have any atomic type.\nforall X -> X null() asm \"PUSHNULL\";\n\n;;; Moves a variable [x] to the top of the stack\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\n\n\n;;; Returns the current Unix time as an Integer\nint now() asm \"NOW\";\n\n;;; Returns the internal address of the current smart contract as a Slice with a `MsgAddressInt`.\n;;; If necessary, it can be parsed further using primitives such as [parse_std_addr].\nslice my_address() asm \"MYADDR\";\n\n;;; Returns the balance of the smart contract as a tuple consisting of an int\n;;; (balance in nanotoncoins) and a `cell`\n;;; (a dictionary with 32-bit keys representing the balance of \"extra currencies\")\n;;; at the start of Computation Phase.\n;;; Note that RAW primitives such as [send_raw_message] do not update this field.\n[int, cell] get_balance() asm \"BALANCE\";\n\n;;; Returns the logical time of the current transaction.\nint cur_lt() asm \"LTIME\";\n\n;;; Returns the starting logical time of the current block.\nint block_lt() asm \"BLOCKLT\";\n\n;;; Computes the representation hash of a `cell` [c] and returns it as a 256-bit unsigned integer `x`.\n;;; Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.\nint cell_hash(cell c) asm \"HASHCU\";\n\n;;; Computes the hash of a `slice s` and returns it as a 256-bit unsigned integer `x`.\n;;; The result is the same as if an ordinary cell containing only data and references from `s` had been created\n;;; and its hash computed by [cell_hash].\nint slice_hash(slice s) asm \"HASHSU\";\n\n;;; Computes sha256 of the data bits of `slice` [s]. If the bit length of `s` is not divisible by eight,\n;;; throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer `x`.\nint string_hash(slice s) asm \"SHA256U\";\n\n{-\n  # Signature checks\n-}\n\n;;; Checks the Ed25519-`signature` of a `hash` (a 256-bit unsigned integer, usually computed as the hash of some data)\n;;; using [public_key] (also represented by a 256-bit unsigned integer).\n;;; The signature must contain at least 512 data bits; only the first 512 bits are used.\n;;; The result is `−1` if the signature is valid, `0` otherwise.\n;;; Note that `CHKSIGNU` creates a 256-bit slice with the hash and calls `CHKSIGNS`.\n;;; That is, if [hash] is computed as the hash of some data, these data are hashed twice,\n;;; the second hashing occurring inside `CHKSIGNS`.\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\n\n;;; Checks whether [signature] is a valid Ed25519-signature of the data portion of `slice data` using `public_key`,\n;;; similarly to [check_signature].\n;;; If the bit length of [data] is not divisible by eight, throws a cell underflow exception.\n;;; The verification of Ed25519 signatures is the standard one,\n;;; with sha256 used to reduce [data] to the 256-bit number that is actually signed.\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n{---\n  # Computation of boc size\n  The primitives below may be useful for computing storage fees of user-provided data.\n-}\n\n;;; Returns `(x, y, z, -1)` or `(null, null, null, 0)`.\n;;; Recursively computes the count of distinct cells `x`, data bits `y`, and cell references `z`\n;;; in the DAG rooted at `cell` [c], effectively returning the total storage used by this DAG taking into account\n;;; the identification of equal cells.\n;;; The values of `x`, `y`, and `z` are computed by a depth-first traversal of this DAG,\n;;; with a hash table of visited cell hashes used to prevent visits of already-visited cells.\n;;; The total count of visited cells `x` cannot exceed non-negative [max_cells];\n;;; otherwise the computation is aborted before visiting the `(max_cells + 1)`-st cell and\n;;; a zero flag is returned to indicate failure. If [c] is `null`, returns `x = y = z = 0`.\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n\n;;; Similar to [compute_data_size?], but accepting a `slice` [s] instead of a `cell`.\n;;; The returned value of `x` does not take into account the cell that contains the `slice` [s] itself;\n;;; however, the data bits and the cell references of [s] are accounted for in `y` and `z`.\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n\n;;; A non-quiet version of [compute_data_size?] that throws a cell overflow exception (`8`) on failure.\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; A non-quiet version of [slice_compute_data_size?] that throws a cell overflow exception (8) on failure.\n(int, int, int, int) slice_compute_data_size?(slice s, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;;; Throws an exception with exit_code excno if cond is not 0 (commented since implemented in compilator)\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n{--\n  # Debug primitives\n  Only works for local TVM execution with debug level verbosity\n-}\n;;; Dumps the stack (at most the top 255 values) and shows the total stack depth.\n() dump_stack() impure asm \"DUMPSTK\";\n\n{-\n  # Persistent storage save and load\n-}\n\n;;; Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.\ncell get_data() asm \"c4 PUSH\";\n\n;;; Sets `cell` [c] as persistent contract data. You can update persistent contract storage with this primitive.\n() set_data(cell c) impure asm \"c4 POP\";\n\n{-\n  # Continuation primitives\n-}\n;;; Usually `c3` has a continuation initialized by the whole code of the contract. It is used for function calls.\n;;; The primitive returns the current value of `c3`.\ncont get_c3() impure asm \"c3 PUSH\";\n\n;;; Updates the current value of `c3`. Usually, it is used for updating smart contract code in run-time.\n;;; Note that after execution of this primitive the current code\n;;; (and the stack of recursive function calls) won't change,\n;;; but any other function call will use a function from the new code.\n() set_c3(cont c) impure asm \"c3 POP\";\n\n;;; Transforms a `slice` [s] into a simple ordinary continuation `c`, with `c.code = s` and an empty stack and savelist.\ncont bless(slice s) impure asm \"BLESS\";\n\n{---\n  # Gas related primitives\n-}\n\n;;; Sets current gas limit `gl` to its maximal allowed value `gm`, and resets the gas credit `gc` to zero,\n;;; decreasing the value of `gr` by `gc` in the process.\n;;; In other words, the current smart contract agrees to buy some gas to finish the current transaction.\n;;; This action is required to process external messages, which bring no value (hence no gas) with themselves.\n;;;\n;;; For more details check [accept_message effects](https://docs.ton.org/develop/smart-contracts/guidelines/accept).\n() accept_message() impure asm \"ACCEPT\";\n\n;;; Sets current gas limit `gl` to the minimum of limit and `gm`, and resets the gas credit `gc` to zero.\n;;; If the gas consumed so far (including the present instruction) exceeds the resulting value of `gl`,\n;;; an (unhandled) out of gas exception is thrown before setting new gas limits.\n;;; Notice that [set_gas_limit] with an argument `limit ≥ 2^63 − 1` is equivalent to [accept_message].\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n\n;;; Commits the current state of registers `c4` (“persistent data”) and `c5` (“actions”)\n;;; so that the current execution is considered “successful” with the saved values even if an exception\n;;; in Computation Phase is thrown later.\n() commit() impure asm \"COMMIT\";\n\n;;; Not implemented\n;;() buy_gas(int gram) impure asm \"BUYGAS\";\n\n;;; Computes the amount of gas that can be bought for `amount` nanoTONs,\n;;; and sets `gl` accordingly in the same way as [set_gas_limit].\n() buy_gas(int amount) impure asm \"BUYGAS\";\n\n;;; Computes the minimum of two integers [x] and [y].\nint min(int x, int y) asm \"MIN\";\n\n;;; Computes the maximum of two integers [x] and [y].\nint max(int x, int y) asm \"MAX\";\n\n;;; Sorts two integers.\n(int, int) minmax(int x, int y) asm \"MINMAX\";\n\n;;; Computes the absolute value of an integer [x].\nint abs(int x) asm \"ABS\";\n\n{-\n  # Slice primitives\n\n  It is said that a primitive _loads_ some data,\n  if it returns the data and the remainder of the slice\n  (so it can also be used as [modifying method](https://docs.ton.org/develop/func/statements#modifying-methods)).\n\n  It is said that a primitive _preloads_ some data, if it returns only the data\n  (it can be used as [non-modifying method](https://docs.ton.org/develop/func/statements#non-modifying-methods)).\n\n  Unless otherwise stated, loading and preloading primitives read the data from a prefix of the slice.\n-}\n\n\n;;; Converts a `cell` [c] into a `slice`. Notice that [c] must be either an ordinary cell,\n;;; or an exotic cell (see [TVM.pdf](https://ton-blockchain.github.io/docs/tvm.pdf), 3.1.2)\n;;; which is automatically loaded to yield an ordinary cell `c'`, converted into a `slice` afterwards.\nslice begin_parse(cell c) asm \"CTOS\";\n\n;;; Checks if [s] is empty. If not, throws an exception.\n() end_parse(slice s) impure asm \"ENDS\";\n\n;;; Loads the first reference from the slice.\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\n\n;;; Preloads the first reference from the slice.\ncell preload_ref(slice s) asm \"PLDREF\";\n\n{- Functions below are commented because are implemented on compilator level for optimisation -}\n\n;;; Loads a signed [len]-bit integer from a slice [s].\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n\n;;; Loads an unsigned [len]-bit integer from a slice [s].\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n\n;;; Preloads a signed [len]-bit integer from a slice [s].\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n\n;;; Preloads an unsigned [len]-bit integer from a slice [s].\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n\n;;; Loads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n\n;;; Preloads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n\n;;; Loads serialized amount of TonCoins (any unsigned integer up to `2^120 - 1`).\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDGRAMS\";\n\n;;; Returns all but the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n\n;;; Returns the first `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\n\n;;; Returns all but the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n\n;;; Returns the last `0 ≤ len ≤ 1023` bits of `slice` [s].\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n\n;;; Loads a dictionary `D` (HashMapE) from `slice` [s].\n;;; (returns `null` if `nothing` constructor is used).\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\n\n;;; Preloads a dictionary `D` from `slice` [s].\ncell preload_dict(slice s) asm \"PLDDICT\";\n\n;;; Loads a dictionary as [load_dict], but returns only the remainder of the slice.\nslice skip_dict(slice s) asm \"SKIPDICT\";\n(slice, ()) ~skip_dict(slice s) asm \"SKIPDICT\";\n\n;;; Loads (Maybe ^Cell) from `slice` [s].\n;;; In other words loads 1 bit and if it is true\n;;; loads first ref and return it with slice remainder\n;;; otherwise returns `null` and slice remainder\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\n\n;;; Preloads (Maybe ^Cell) from `slice` [s].\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\n\n\n;;; Returns the depth of `cell` [c].\n;;; If [c] has no references, then return `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [c].\n;;; If [c] is a `null` instead of a cell, returns zero.\nint cell_depth(cell c) asm \"CDEPTH\";\n\n\n{-\n  # Slice size primitives\n-}\n\n;;; Returns the number of references in `slice` [s].\nint slice_refs(slice s) asm \"SREFS\";\n\n;;; Returns the number of data bits in `slice` [s].\nint slice_bits(slice s) asm \"SBITS\";\n\n;;; Returns both the number of data bits and the number of references in `slice` [s].\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\n\n;;; Checks whether a `slice` [s] is empty (i.e., contains no bits of data and no cell references).\nint slice_empty?(slice s) asm \"SEMPTY\";\n\n;;; Checks whether `slice` [s] has no bits of data.\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\n\n;;; Checks whether `slice` [s] has no references.\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\n\n;;; Returns the depth of `slice` [s].\n;;; If [s] has no references, then returns `0`;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [s].\nint slice_depth(slice s) asm \"SDEPTH\";\n\n{-\n  # Builder size primitives\n-}\n\n;;; Returns the number of cell references already stored in `builder` [b]\nint builder_refs(builder b) asm \"BREFS\";\n\n;;; Returns the number of data bits already stored in `builder` [b].\nint builder_bits(builder b) asm \"BBITS\";\n\n;;; Returns the depth of `builder` [b].\n;;; If no cell references are stored in [b], then returns 0;\n;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [b].\nint builder_depth(builder b) asm \"BDEPTH\";\n\n{-\n  # Builder primitives\n  It is said that a primitive _stores_ a value `x` into a builder `b`\n  if it returns a modified version of the builder `b'` with the value `x` stored at the end of it.\n  It can be used as [non-modifying method](https://docs.ton.org/develop/func/statements#non-modifying-methods).\n\n  All the primitives below first check whether there is enough space in the `builder`,\n  and only then check the range of the value being serialized.\n-}\n\n;;; Creates a new empty `builder`.\nbuilder begin_cell() asm \"NEWC\";\n\n;;; Converts a `builder` into an ordinary `cell`.\ncell end_cell(builder b) asm \"ENDC\";\n\n;;; Stores a reference to `cell` [c] into `builder` [b].\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n\n;;; Stores an unsigned [len]-bit integer `x` into `b` for `0 ≤ len ≤ 256`.\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n\n;;; Stores a signed [len]-bit integer `x` into `b` for` 0 ≤ len ≤ 257`.\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\n\n\n;;; Stores `slice` [s] into `builder` [b]\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\n\n;;; Stores (serializes) an integer [x] in the range `0..2^120 − 1` into `builder` [b].\n;;; The serialization of [x] consists of a 4-bit unsigned big-endian integer `l`,\n;;; which is the smallest integer `l ≥ 0`, such that `x < 2^8l`,\n;;; followed by an `8l`-bit unsigned big-endian representation of [x].\n;;; If [x] does not belong to the supported range, a range check exception is thrown.\n;;;\n;;; Store amounts of TonCoins to the builder as VarUInteger 16\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_coins(builder b, int x) asm \"STGRAMS\";\n\n;;; Stores dictionary `D` represented by `cell` [c] or `null` into `builder` [b].\n;;; In other words, stores a `1`-bit and a reference to [c] if [c] is not `null` and `0`-bit otherwise.\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n;;; Stores (Maybe ^Cell) to builder:\n;;; if cell is null store 1 zero bit\n;;; otherwise store 1 true bit and ref to cell\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\n\n{-\n  # Address manipulation primitives\n  The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme:\n  ```TL-B\n  addr_none$00 = MsgAddressExt;\n  addr_extern$01 len:(## 8) external_address:(bits len)\n               = MsgAddressExt;\n  anycast_info$_ depth:(#<= 30) { depth >= 1 }\n    rewrite_pfx:(bits depth) = Anycast;\n  addr_std$10 anycast:(Maybe Anycast)\n    workchain_id:int8 address:bits256 = MsgAddressInt;\n  addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)\n    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;\n  _ _:MsgAddressInt = MsgAddress;\n  _ _:MsgAddressExt = MsgAddress;\n\n  int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n    src:MsgAddress dest:MsgAddressInt\n    value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt\n    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  ```\n  A deserialized `MsgAddress` is represented by a tuple `t` as follows:\n\n  - `addr_none` is represented by `t = (0)`,\n    i.e., a tuple containing exactly one integer equal to zero.\n  - `addr_extern` is represented by `t = (1, s)`,\n    where slice `s` contains the field `external_address`. In other words, `\n    t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`.\n  - `addr_std` is represented by `t = (2, u, x, s)`,\n    where `u` is either a `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if anycast is present).\n    Next, integer `x` is the `workchain_id`, and slice `s` contains the address.\n  - `addr_var` is represented by `t = (3, u, x, s)`,\n    where `u`, `x`, and `s` have the same meaning as for `addr_std`.\n-}\n\n;;; Loads from slice [s] the only prefix that is a valid `MsgAddress`,\n;;; and returns both this prefix `s'` and the remainder `s''` of [s] as slices.\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\n\n;;; Decomposes slice [s] containing a valid `MsgAddress` into a `tuple t` with separate fields of this `MsgAddress`.\n;;; If [s] is not a valid `MsgAddress`, a cell deserialization exception is thrown.\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n\n;;; Parses slice [s] containing a valid `MsgAddressInt` (usually a `msg_addr_std`),\n;;; applies rewriting from the anycast (if present) to the same-length prefix of the address,\n;;; and returns both the workchain and the 256-bit address as integers.\n;;; If the address is not 256-bit, or if [s] is not a valid serialization of `MsgAddressInt`,\n;;; throws a cell deserialization exception.\n(int, int) parseStdAddress(slice s) asm \"REWRITESTDADDR\";\n\n;;; A variant of [parseStdAddress] that returns the (rewritten) address as a slice [s],\n;;; even if it is not exactly 256 bit long (represented by a `msg_addr_var`).\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\n{-\n  # Dictionary primitives\n-}\n\n\n;;; Sets the value associated with [key_len]-bit key signed index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n\n;;; Sets the value associated with [key_len]-bit key unsigned index in dictionary [dict] to [value] (cell),\n;;; and returns the resulting dictionary.\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\n\n;;; Creates an empty dictionary, which is actually a null value. Equivalent to PUSHNULL\ncell new_dict() asm \"NEWDICT\";\n;;; Checks whether a dictionary is empty. Equivalent to cell_null?.\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n\n{- Prefix dictionary primitives -}\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\n;;; Returns the value of the global configuration parameter with integer index `i` as a `cell` or `null` value.\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\n;;; Checks whether c is a null. Note, that FunC also has polymorphic null? built-in.\nint cell_null?(cell c) asm \"ISNULL\";\n\n;;; Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if mode = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b − amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means `amount <- -amount` before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently, amount must be a non-negative integer, and mode must be in the range 0..15.\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n;;; Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n;;; Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smart contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n;;; Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract\n() set_code(cell new_code) impure asm \"SETCODE\";\n\n;;; Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.\nint random() impure asm \"RANDU256\";\n;;; Generates a new pseudo-random integer z in the range 0..range−1 (or range..−1, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.\nint rand(int range) impure asm \"RAND\";\n;;; Returns the current random seed as an unsigned 256-bit Integer.\nint get_seed() impure asm \"RANDSEED\";\n;;; Sets the random seed to unsigned 256-bit seed.\n() set_seed(int) impure asm \"SETRAND\";\n;;; Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.\n() randomize(int x) impure asm \"ADDRAND\";\n;;; Equivalent to randomize(cur_lt());.\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\n;;; Checks whether the data parts of two slices coinside\nint equal_slice_bits(slice a, slice b) asm \"SDEQ\";\n\n;;; Concatenates two builders\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/constants.fc",
        "content": "const int ERRORCODE_MASK = 0x7ff;\nconst int CLASSLIB::ERROR::INVALID_FIELD_TYPE = 1059;\nconst int CLASSLIB::ERROR::WRONG_ORDER_CONSTRUCTOR = 1060;\n\nconst int MAX_U8    = 0xFF;\nconst int MAX_U16   = 0xFFFF;\nconst int MAX_U32   = 0xFFFFFFFF;\nconst int MAX_U64   = 0xFFFFFFFFFFFFFFFF;\nconst int MAX_U128  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nconst int MAX_U256  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\nconst int MAX_COINS = 1329227995784915872903807060280344575; ;; 2^120 - 1\n\nconst int ADDR_TYPE_NONE = 0;\nconst int ADDR_TYPE_EXTERN = 1;\nconst int ADDR_TYPE_STD = 2;\nconst int ADDR_TYPE_VAR = 3;\n\nconst int TRUE = -1;\nconst int FALSE = 0;\nconst int MASTERCHAIN = -1;\nconst int BASECHAIN = 0;\n\n;; 0b011000 tag - 0, ihr_disabled - 1, bounce - 1, bounced - 0, src = adr_none$00\nconst int SEND_MSG_BOUNCEABLE = 0x18;\n;; 0b010000 tag - 0, ihr_disabled - 1, bounce - 0, bounced - 0, src = adr_none$00\nconst int SEND_MSG_NON_BOUNCEABLE = 0x10;\n\n;; MODIFIER\nconst int NORMAL = 0;\nconst int PAID_EXTERNALLY = 1;\nconst int IGNORE_ERRORS = 2;\n\n;; SEND MODES\nconst int BOUNCE_IF_FAIL = 16;\nconst int DESTROY_IF_ZERO = 32;\nconst int CARRY_REMAINING_GAS = 64;\nconst int CARRY_ALL_BALANCE = 128;\n\n;; SENDMSG modes\nconst int SUB_BALANCE_MSG = 64;\nconst int SUB_BALANCE_CONTRACT = 128;\nconst int ONLY_ESTIMATE_FEES = 1024;\n\n;; SEND MODES QUIETED\nconst int QDESTROY_IF_ZERO = 34;\nconst int QCARRY_REMAINING_GAS = 66;\nconst int QCARRY_ALL_BALANCE = 130;\n\nconst int RESERVE_EXACTLY    = 0;\nconst int RESERVE_ALL_EXCEPT = 1;\nconst int RESERVE_AT_MOST    = 2;\nconst int EXTRN_DO_NOT_FAIL  = 2;\nconst int BALANCE_INCREASED  = 4;\nconst int BALANCE_DECREASED  = 8;\nconst int RESERVE_BOUNCE_ON_ACTION_FAIL = 16;\n\n;; a lot of different constants, because arithmetic manipulation of constants is not optimized\nconst int MAX_CELL_BITS = 1023;\nconst int MAX_CELL_BYTES = 127;\nconst int MAX_CELL_WHOLE_BYTE_BITS = MAX_CELL_BYTES * 8;\nconst int MAX_CELL_BIT_INDEX = 1022;\nconst int MAX_CELL_REFS = 4;\n\nconst int NULLADDRESS = 0;\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/utils.fc",
        "content": "#include \"constants.fc\";\n#include \"stdlib.fc\";\n\nconst int ERROR::WrongWorkchain = 2047;\n\nforall X -> tuple unsafeTuple(X x) asm \"NOP\";\n(slice) as_slice(builder b) asm \"ENDC CTOS\";\n(slice, int) load_uint8(slice s) asm \"8 LDU SWAP\";\n(builder) store_uint8(builder b, int t) inline asm(t b) \"8 STU\";\n(slice, int) load_uint16(slice s) asm \"16 LDU SWAP\";\n(builder) store_uint16(builder b, int t) inline asm(t b) \"16 STU\";\n(slice, int) load_uint32(slice s) asm \"32 LDU SWAP\";\n(builder) store_uint32(builder b, int t) inline asm(t b) \"32 STU\";\n(slice, int) load_uint64(slice s) asm \"64 LDU SWAP\";\n(builder) store_uint64(builder b, int t) inline asm(t b) \"64 STU\";\n(slice, int) load_uint128(slice s) asm \"128 LDU SWAP\";\n(builder) store_uint128(builder b, int t) inline asm(t b) \"128 STU\";\n(slice, int) load_uint256(slice s) asm \"256 LDU SWAP\";\n(builder) store_uint256(builder b, int t) inline asm(t b) \"256 STU\";\nforall X -> int   is_null(X x) asm \"ISNULL\";\nforall X -> int   is_int(X x) asm \"<{ TRY:<{ 0 PUSHINT ADD DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS\";\nforall X -> int   is_cell(X x) asm \"<{ TRY:<{ CTOS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS\";\nforall X -> int   is_slice(X x) asm \"<{ TRY:<{ SBITS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS\";\nforall X -> int   is_tuple(X x) asm \"ISTUPLE\";\nforall X -> cell  cast_to_cell(X x) asm \"NOP\";\nforall X -> slice cast_to_slice(X x) asm \"NOP\";\nforall X -> int   cast_to_int(X x) asm \"NOP\";\nforall X -> tuple cast_to_tuple(X x) asm \"NOP\";\n(cell) my_code() asm \"MYCODE\";\n(tuple) get_values() asm \"INCOMINGVALUE\";\nint storage_fees() asm \"STORAGEFEES\";\n(int, slice) ldones(slice s) asm \"LDONES\";\n\n(int) get_gas_consumed() asm \"GASCONSUMED\";\n\nbuilder store_zeroes(builder b, int x) asm \"STZEROES\";\nbuilder store_ones(builder b, int x) asm \"STONES\";\ncell preload_first_ref(slice s) asm \"0 PLDREFIDX\";\nslice preload_bits_offset(slice s, int offset, int len) asm \"SDSUBSTR\";\n(slice, int) load_bool(slice s) asm(-> 1 0) \"1 LDI\";\nint preload_bool(slice s) asm \"1 PUSHINT PLDIX\";\n(builder) store_bool(builder b, int v) asm(v b) \"1 STI\";\ncell empty_cell() asm \"<b b> PUSHREF\";\nforall X -> tuple tset(tuple t, int k, X x) asm(t x k) \"SETINDEXVAR\";\nforall X -> (tuple, ()) ~tset(tuple t, int k, X x) asm(t x k) \"SETINDEXVAR\";\nforall X -> (tuple, X) tpop(tuple t) asm \"TPOP\";\nint tlen(tuple t) asm \"TLEN\";\nint keccak256Builder(builder b) asm \"1 PUSHINT HASHEXT_KECCAK256\";\n\nint cell_is_empty(cell c) impure inline {\n    return c.cell_hash() == 68134197439415885698044414435951397869210496020759160419881882418413283430343;\n}\n\nint get_compute_fee(int workchain, int gas_used) asm(gas_used workchain) \"GETGASFEE\";\nint get_storage_fee(int workchain, int seconds, int bits, int cells) asm(cells bits seconds workchain) \"GETSTORAGEFEE\";\nint get_forward_fee(int workchain, int bits, int cells) asm(cells bits workchain) \"GETFORWARDFEE\";\n\nint ilog4(int x) asm(x) \"UBITSIZE 4 PUSHINT DIV\";\ncell preload_ref_at(slice s, int idx) inline asm \"PLDREFVAR\";\nslice scutfirst(slice s, int bits, int refs) inline asm \"SCUTFIRST\";\nslice scutlast(slice s, int bits, int refs) inline asm \"SCUTLAST\";\nslice subslice(slice s, int start_bits, int start_refs, int bits, int refs) inline asm \"SUBSLICE\";\nslice sskipfirst(slice s, int bits, int refs) inline asm \"SSKIPFIRST\";\nslice sskiplast(slice s, int bits, int refs) inline asm \"SSKIPLAST\";\nslice sdskipfirst(slice s, int bits) inline asm \"SDSKIPFIRST\";\nforall X -> builder cast_to_builder(X x) inline asm \"NOP\";\nint abs(int x) inline asm \"ABS\";\ntuple self_balance() asm \"BALANCE\";\n\n() throwError(slice reason) impure inline {\n    ~strdump(reason);\n    throw(reason.slice_hash() & ERRORCODE_MASK);\n}\n\n() throwErrorUnless(int condition, slice reason) impure inline {\n    ifnot (condition) {\n        throwError(reason);\n    }\n}\nint _SDCNTLEAD0(slice x) asm \"SDCNTLEAD0\";\nint POW2(int y) asm \"POW2\";\n\n;; numCells, num_bits\n(int, int) getContractStateSize(cell code, cell init_storage) impure inline {\n    cell stateInit = begin_cell()\n        .store_uint(6, 5)\n        .store_ref(code)\n        .store_ref(init_storage)\n        .end_cell();\n    (int cellsCount, int bitsCount, int success) = stateInit.compute_data_size(MAX_U16);\n    throw_unless(8, success);\n    return (cellsCount, bitsCount);\n}\n\nint calculateStorageFees(int cellsCount, int bitsCount, int timeDelta) impure inline {\n    return get_storage_fee(BASECHAIN, timeDelta, bitsCount, cellsCount);\n}\n\nforall X -> tuple castToTuple(X x) asm \"NOP\";\n\nslice empty_slice() asm \"<b b> <s PUSHSLICE\";\n\nint treeShapeEqual(cell lhs, cell rhs) inline {\n    slice lhsSlice = lhs.begin_parse();\n    slice rhsSlice = rhs.begin_parse();\n    (int lhsBits, int lhsRefs) = lhsSlice.slice_bits_refs();\n    (int rhsBits, int rhsRefs) = rhsSlice.slice_bits_refs();\n    if ((lhsBits != rhsBits) | (lhsRefs != rhsRefs)) {\n        return false;\n    }\n    if (lhsRefs == 0) {\n        return true;\n    }\n    int subtreeShapeEqual = true;\n    int refIdx = 0;\n    while (refIdx < lhsRefs) {\n        subtreeShapeEqual &= treeShapeEqual(\n            lhsSlice.preload_ref_at(refIdx),\n            rhsSlice.preload_ref_at(refIdx)\n        );\n    }\n    return subtreeShapeEqual;\n}\n\nint _globvarIsNull(int idx) impure asm \"GETGLOBVAR ISNULL\";\n\nint _gasToNanoton(int gas) impure inline {\n    return get_compute_fee(false, gas);\n}\n\n(cell, int) getConfigParam(int idx) inline asm \"CONFIGPARAM\";\n\n;; https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb\n;; gas_prices#dd gas_price:uint64 gas_limit:uint64 gas_credit:uint64\n;; block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64\n;; = GasLimitsPrices;\n;;\n;; gas_prices_ext#de gas_price:uint64 gas_limit:uint64 special_gas_limit:uint64 gas_credit:uint64\n;; block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64\n;; = GasLimitsPrices;\n;;\n;; gas_flat_pfx#d1 flat_gas_limit:uint64 flat_gas_price:uint64 other:GasLimitsPrices\n;; = GasLimitsPrices;\n;;\n;; config_mc_gas_prices#_ GasLimitsPrices = ConfigParam 20;\n;; config_gas_prices#_ GasLimitsPrices = ConfigParam 21;\n;; return -1 on any failure\n(int, int, int, int, int, int, int, int, int) parseGasLimitsPrices(int workchainId) impure {\n    int configIdx = workchainId == BASECHAIN ? 21 : 20;\n    (cell cfg, int success) = getConfigParam(configIdx);\n    ifnot (success) {\n        return (-1, -1, -1, -1, -1, -1, -1, -1, -1);\n    }\n    slice cfgSlice = cfg.begin_parse();\n    ifnot (cfgSlice.slice_bits() >= 592) {\n        return (-1, -1, -1, -1, -1, -1, -1, -1, -1);\n    }\n\n    if (\n        (cfgSlice.preload_uint(8) != 0xd1)\n        | (cfgSlice.preload_bits_offset(136, 8).preload_uint(8) != 0xde)\n    ) {\n        return (-1, -1, -1, -1, -1, -1, -1, -1, -1);\n    }\n\n    cfgSlice~load_uint8();\n    int specialGasLimit = cfgSlice~load_uint64();\n    int flatGasLimit = cfgSlice~load_uint64();\n    int flatGasPrice = cfgSlice~load_uint64();\n    cfgSlice~load_uint8();\n    int gasPrice = cfgSlice~load_uint64();\n    int gasLimit = cfgSlice~load_uint64();\n    int gasCredit = cfgSlice~load_uint64();\n    int blockGasLimit = cfgSlice~load_uint64();\n    int freezeDueLimit = cfgSlice~load_uint64();\n    int deleteDueLimit = cfgSlice~load_uint64();\n    return (\n        specialGasLimit,\n        flatGasLimit,\n        flatGasPrice,\n        gasPrice,\n        gasLimit,\n        gasCredit,\n        blockGasLimit,\n        freezeDueLimit,\n        deleteDueLimit\n    );\n}\n\n;;; ====================== Address functions ======================\nint basechainAddressStdToHashpart(slice full_address) impure inline {\n    (int wc, int hp) = parseStdAddress(full_address);\n    throw_if(ERROR::WrongWorkchain, wc != BASECHAIN);\n    return hp;\n}\n\nslice hashpartToBasechainAddressStd(int hashpart) impure inline {\n    return begin_cell()\n        .store_uint(4, 3) ;; 0b100\n        .store_int(BASECHAIN, 8)\n        .store_uint(hashpart, 256)\n        .as_slice();\n}\n\nint getContractAddress() impure inline {\n    return my_address().preload_bits_offset(11, 256).preload_uint(256);\n}\n\n() setContractStorage(cell $obj) impure inline {\n    set_data($obj);\n}\n\ncell getContractStorage() impure inline method_id {\n    return get_data();\n}\n\nint getContractBalanceView(int futureSeconds) impure inline method_id {\n    (int cellsCount, int bitsCount) = getContractStateSize(my_code(), getContractStorage());\n\n    int ret = self_balance().int_at(0) - calculateStorageFees(cellsCount, bitsCount, futureSeconds);\n\n    return max(0, ret);\n}\n\nint computeContractAddress(cell $storage, cell code) impure inline {\n    return begin_cell()\n        .store_uint(6, 5)\n        .store_ref(code)\n        .store_ref($storage)\n        .end_cell()\n        .cell_hash();\n}\n\n;; ============================== Optimization Functions ==============================\n\n;; ========================== For Slices ==========================\n\nint preloadBoolAt(slice self, int offset) impure inline {\n    ;; bools should be returned as bools\n    return self.preload_bits_offset(offset, 1).preload_bool();\n}\n\nint preloadUint8At(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 8).preload_uint(8);\n}\n\nint preloadUint16At(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 16).preload_uint(16);\n}\n\nint preloadUint32At(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 32).preload_uint(32);\n}\n\nint preloadUint64At(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 64).preload_uint(64);\n}   \n\nint preloadCoinsAt(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 128).preload_uint(128);\n}\n\nint preloadUint256At(slice self, int offset) impure inline {\n    return self.preload_bits_offset(offset, 256).preload_uint(256);\n}\n\nint preloadAddressAt(slice self, int offset) impure inline {\n    return self.preloadUint256At(offset);\n}\n\n;; slice -> cell\ncell preloadRefAt(slice self, int offset) impure inline {\n    return self.preload_ref_at(offset);\n}\n\n;; slice -> slice\nslice preloadRefSliceAt(slice self, int offset) impure inline {\n    return self.preload_ref_at(offset).begin_parse();\n}\n\n;; ========================== For Cells ==========================\n\nint cellPreloadBoolAt(cell self, int offset) impure inline {\n    return self.begin_parse().preloadBoolAt(offset);\n}\n\nint cellPreloadUint8At(cell self, int offset) impure inline {\n    return self.begin_parse().preloadUint8At(offset);\n}\n\nint cellPreloadUint16At(cell self, int offset) impure inline {\n    return self.begin_parse().preloadUint16At(offset);\n}\n\nint cellPreloadUint32At(cell self, int offset) impure inline {\n    return self.begin_parse().preloadUint32At(offset);\n}\n\nint cellPreloadUint64At(cell self, int offset) impure inline {\n    return self.begin_parse().preloadUint64At(offset);\n}\n\nint cellPreloadCoinsAt(cell self, int offset) impure inline {\n    return self.begin_parse().preloadCoinsAt(offset);\n}\n\nint cellPreloadUint256At(cell self, int offset) impure inline {\n    return self.begin_parse().preloadUint256At(offset);\n}\n\nint cellPreloadAddressAt(cell self, int offset) impure inline {\n    return self.cellPreloadUint256At(offset);\n}\n\n;; cell -> cell\ncell cellPreloadRefAt(cell self, int offset) impure inline {\n    return self.begin_parse().preloadRefAt(offset);\n}\n\n;; cell -> slice\nslice cellPreloadRefSliceAt(cell self, int offset) impure inline {\n    return self.begin_parse().preloadRefAt(offset).begin_parse();\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/txnContext.fc",
        "content": "#include \"utils.fc\";\n\nglobal tuple txnContext;\n\nconst int _IS_BOUNCED = 0;\nconst int _CALLER = 1;\nconst int _FWD_FEE = 2;\nconst int _OPCODE = 3;\nconst int _QUERY_ID = 4;\nconst int _BALANCE = 5;\nconst int _MSG_VALUE = 6;\nconst int _BODY = 7;\nconst int _RAW_MSG = 8;\nconst int _ORIGIN = 9;\nconst int _DONATION_NANOS = 10;\nconst int _MD = 11;\n\nint getMsgValue() impure inline {\n    return txnContext.int_at(_MSG_VALUE);\n}\n\nint getOpcode() impure inline {\n    return txnContext.int_at(_OPCODE);\n}\n\nint txnIsBounced() impure inline {\n    return txnContext.int_at(_IS_BOUNCED);\n}\n\nint getContractBalance() impure inline {\n    return txnContext.int_at(_BALANCE);\n}\n\nint getInitialContractBalance() impure inline {\n    return getContractBalance() - getMsgValue();\n}\n\nint getCaller() impure inline {\n    return txnContext.int_at(_CALLER);\n}\n\nint getOrigin() impure inline {\n    return txnContext.int_at(_ORIGIN);\n}\n\nslice getOriginStd() impure inline {\n    return hashpartToBasechainAddressStd(getOrigin());\n}\n\nint getDonationNanos() impure inline {\n    return txnContext.int_at(_DONATION_NANOS);\n}\n\n() setDonationNanos(int nanos) impure inline {\n    txnContext~tset(_DONATION_NANOS, nanos);\n}\n\ncell getMsgData() impure inline {\n    return txnContext.cell_at(_MD);\n}\n\n() setOrigin(int newOrigin) impure inline {\n    txnContext~tset(_ORIGIN, newOrigin);\n}\n\n;; returns if slice empty\n;; if empty body, sets opcode=-1 & query_id=-1, so it cannot be faked\n() initTxnContext(int myBalance, int msgValue, cell inMsgFull, slice inMsgBody) impure inline {\n    slice cs = inMsgFull.begin_parse();\n    int flags = cs~load_uint(4);\n\n    int _is_bounced = false;\n    if flags & 1 {\n        _is_bounced = true;\n        inMsgBody~skip_bits(32); ;; 0xFFFFFFFF\n    }\n\n    int opcode = -1;\n    int query_id = -1;\n    int donationNanos = 0;\n    cell md = null();\n\n    slice _sender_address = cs~load_msg_addr();\n    cs~load_msg_addr();\n    cs~load_coins();\n    cs~skip_dict();\n    cs~load_coins();\n    int senderAddress = basechainAddressStdToHashpart(_sender_address);\n\n    ;; by default, the origin is the sender address\n    int origin = senderAddress;\n\n    ;; the inMsgBody parsing is technically compatible with the reference jetton implementation\n    ;; where donationNanos == the amount of tokens received\n    ;; and and the origin will contain garbage data\n    ifnot (inMsgBody.slice_empty?()) {\n        opcode = inMsgBody~load_uint(32);\n        query_id = inMsgBody~load_uint(64);\n        donationNanos = inMsgBody~load_coins();\n        ;; if the origin is explicitly overriden in the body, use that\n        if (inMsgBody.slice_bits() >= 267) {\n            origin = inMsgBody.preload_bits_offset(11, 256).preload_uint(256);\n        }\n        ifnot (inMsgBody.slice_refs_empty?()) {\n            md = inMsgBody.preload_ref();\n        }\n    }\n\n    txnContext = castToTuple([\n        _is_bounced,\n        senderAddress,\n        muldiv(cs~load_coins(), 3, 2),\n        opcode,\n        query_id,\n        myBalance,\n        msgValue,\n        inMsgBody, ;; could be an empty slice\n        inMsgFull,\n        origin,\n        donationNanos,\n        md\n    ]);\n}\n\n(builder) beginTonMessage(int _opcode) asm \"txnContext GETGLOB 4 INDEX SWAP NEWC 32 STU 64 STU\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/utils.fc",
        "content": "#include \"../txnContext.fc\";\n\n;; Small file for now, but a placeholder for generic actions utility functions\n\nconst int ACTIONS_OUTFLOW = 0;\n\ntuple emptyActions() inline {\n    return unsafeTuple([0]);\n}\n\n;;; ======================================================================================\n;; @info terminal actions are always sent using all non-reserved balance on the contract\n() sendTerminalAction(int toAddress, cell messageBody, cell stateInit, int extraFlags) impure inline {\n    builder b = begin_cell()\n        .store_uint(SEND_MSG_BOUNCEABLE, 6)\n        .store_slice(hashpartToBasechainAddressStd(toAddress))\n        .store_coins(0);\n    b = stateInit.is_null()\n        ? b.store_uint(1, 107)\n        : b.store_uint(7, 108).store_ref(stateInit);\n    send_raw_message(b.store_ref(messageBody).end_cell(), CARRY_ALL_BALANCE | extraFlags);\n}\n\n;; @info non-terminal actions must specify the amount of funds to send\n() sendNonTerminalAction(int bounceable, int amount, int toAddress, cell messageBody, int extraFlags) impure inline {\n    cell msg = begin_cell()\n        .store_uint(bounceable, 6)\n        .store_slice(hashpartToBasechainAddressStd(toAddress))\n        .store_coins(amount)\n        .store_uint(1, 107)\n        .store_ref(messageBody)\n        .end_cell();\n    send_raw_message(msg, extraFlags);\n}\n;; @param donationNanos: the amount of TON that the sender intended to be\n;; withheld within our contract\n;; @info baseHandler::refund_addr is the last known \"origin\" of a message\n;; flow, and is used to refund the sender if the handler does not\n;; use all remaining value from the in_message\ncell buildLayerzeroMessageBody(int donationNanos, int opcode, cell $md) impure inline {\n    cell ret = beginTonMessage(opcode)\n        .store_coins(donationNanos)\n        .store_slice(getOriginStd())\n        .store_ref($md)\n        .end_cell();\n    return ret;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/actions/call.fc",
        "content": "#include \"utils.fc\";\n#include \"../classlib.fc\";\n\nconst int action::call::NAME = \"actionCall\"u;\n\nconst int action::call::to = 1;\nconst int action::call::opcode = 2;\nconst int action::call::md = 3;\n\n;; Call a method on the contract at address `to` with the given message data `md`\n;; optionally provide value provisioned from this contract's balance\n;; @terminal\ntuple action::call::create(int to, int opcode, cell $md) impure inline {\n    return unsafeTuple([action::call::NAME, to, opcode, $md]);\n}\n\n;; returns true if equals\nint action::call::equals(tuple self, tuple other) impure inline {\n    int equalMdField = compareObjectFields(self.cell_at(action::call::md), other.cell_at(action::call::md));\n    if (equalMdField != -1) {\n        ~strdump(\"call: not equal md field at idx \");\n        ~dump(equalMdField);\n    }\n    return (\n        (self.int_at(0) == other.int_at(0)) ;; NAME\n        & (self.int_at(action::call::to) == other.int_at(action::call::to))\n        & (self.int_at(action::call::opcode) == other.int_at(action::call::opcode))\n        & (equalMdField == -1)\n    );\n}\n\n;; overloaded when you want to pass 0 outflowNanos\ntuple _newAction<call>(int to, int opcode, cell $body) impure inline {\n    return action::call::create(to, opcode, $body);\n}\n\n;; overloaded when you want to pass 0 outflowNanos\n(tuple, ()) ~pushAction<call>(tuple actions, int to, int opcode, cell $body) impure inline {\n    return (actions.tpush(_newAction<call>(to, opcode, $body)), ());\n}\n\nint executeCall(tuple callAction) impure inline {\n    sendTerminalAction(\n        callAction.int_at(action::call::to),\n        buildLayerzeroMessageBody(\n            0,\n            callAction.int_at(action::call::opcode),\n            callAction.cell_at(action::call::md)\n        ),\n        null(),\n        NORMAL\n    );\n    return false;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/core/abstract/protocolMain.fc",
        "content": ";;; ================================================================\n;; The base main function for LayerZero Endpoint, UltraLightNode, and OApp\n;;; ================================================================\n#include \"../../../funC++/actions/call.fc\";\n#include \"../../../funC++/actions/deploy.fc\";\n#include \"../../../funC++/actions/dispatch.fc\";\n#include \"../../../funC++/actions/event.fc\";\n#include \"../../../funC++/actions/payment.fc\";\n\n#include \"../../../funC++/contractMain.fc\";\n#include \"../../../funC++/handlerCore.fc\";\n\nint _executeAction(int actionType, tuple action) impure inline {\n    if (actionType == action::event::NAME) {\n        return executeEvent(action);\n    } elseif (actionType == action::call::NAME) {\n        return executeCall(action);\n    } elseif (actionType == action::payment::NAME) {\n        return executePayment(action);\n    } elseif (actionType == action::dispatch::NAME) {\n        return executeDispatch(action);\n    } elseif (actionType == action::deploy::NAME) {\n        return executeDeploy(action);\n    } else {\n        throw(BaseInterface::ERROR::invalidActionType);\n    }\n\n    ;; compiler freaks out if you dont have something here returning an int, but this should never be reached\n    return false;\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/funC++/dataStructures/DeterministicInsertionCircularQueue.fc",
        "content": ";;; =================== DeterministicInsertionCircularQueue.fc ===================\n;; the DeterministicInsertionCircularQueue is a deterministic-gas circular buffer\n;; that stores key-value pairs along with one piece of metadata (8-bits) per entry.\n#include \"../utils.fc\";\n\nconst int DeterministicInsertionCircularQueue::statusBits = 8;\nconst int DeterministicInsertionCircularQueue::keyBits = 64;\n\nconst int DeterministicInsertionCircularQueue::invalidKey = -1;\nconst int DeterministicInsertionCircularQueue::invalidStatus = -1;\nconst int DeterministicInsertionCircularQueue::ERROR::invalidObject = 1185;\n\ncell DeterministicInsertionCircularQueue::_buildLevel(int level, cell initialContents) impure inline {\n    if (level == 0) {\n        return begin_cell()\n            .store_ref(initialContents)\n            .store_ref(initialContents)\n            .store_ref(initialContents)\n            .store_ref(initialContents)\n            .end_cell();\n    } else {\n        int nextLevel = level - 1;\n        return begin_cell()\n            .store_ref(DeterministicInsertionCircularQueue::_buildLevel(nextLevel, initialContents))\n            .store_ref(DeterministicInsertionCircularQueue::_buildLevel(nextLevel, initialContents))\n            .store_ref(DeterministicInsertionCircularQueue::_buildLevel(nextLevel, initialContents))\n            .store_ref(DeterministicInsertionCircularQueue::_buildLevel(nextLevel, initialContents))\n            .end_cell();\n    }\n}\n\n;; Given a well-formed commit_verification_queue\n;; get the content of the queue at a given relative nonce\n;; (actual key, entry, status, exists)\n(int, cell, int, int) DeterministicInsertionCircularQueue::get(cell self, int key) impure inline {\n    int position = key % MAX_CELL_BITS;\n\n    slice commitSlice = self\n        .begin_parse()\n        .preload_ref_at(position / 256)\n        .begin_parse()\n        .preload_ref_at((position % 256) / 64)\n        .begin_parse()\n        .preload_ref_at((position % 64) / 16)\n        .begin_parse()\n        .preload_ref_at((position % 16) / 4)\n        .begin_parse()\n        .preload_ref_at(position % 4)\n        .begin_parse();\n\n    ;; guaranteed to always have state stored\n    int exists = commitSlice~load_bool();\n    int state = commitSlice~load_uint(DeterministicInsertionCircularQueue::statusBits);\n    if (exists) {\n        return (\n            commitSlice.preload_uint(DeterministicInsertionCircularQueue::keyBits),\n            commitSlice.preload_first_ref(),\n            state,\n            exists\n        );\n    }\n    return (\n        DeterministicInsertionCircularQueue::invalidKey,\n        empty_cell(),\n        DeterministicInsertionCircularQueue::invalidStatus,\n        exists\n    );\n}\n\ncell DeterministicInsertionCircularQueue::_setRaw(cell self, int key, cell newLeaf) impure inline {\n    int slot = key % MAX_CELL_BITS;\n    slice queueSlice = self.begin_parse();\n    int l0_idx = slot / 256;\n    int l1_idx = (slot % 256) / 64;\n    int l2_idx = (slot % 64) / 16;\n    int l3_idx = (slot % 16) / 4;\n    int leaf_idx = slot % 4;\n\n    slice l0Slice = queueSlice.preload_ref_at(l0_idx).begin_parse();\n    slice l1Slice = l0Slice.preload_ref_at(l1_idx).begin_parse();\n    slice l2Slice = l1Slice.preload_ref_at(l2_idx).begin_parse();\n    slice l3Slice = l2Slice.preload_ref_at(l3_idx).begin_parse();\n\n    cell new_l3 = begin_cell()\n        .store_slice(scutfirst(l3Slice, 0, leaf_idx))\n        .store_ref(newLeaf)\n        .store_slice(scutlast(l3Slice, 0, 3 - leaf_idx))\n        .end_cell();\n\n    cell new_l2 = begin_cell()\n        .store_slice(scutfirst(l2Slice, 0, l3_idx))\n        .store_ref(new_l3)\n        .store_slice(scutlast(l2Slice, 0, 3 - l3_idx))\n        .end_cell();\n\n    cell new_l1 = begin_cell()\n        .store_slice(scutfirst(l1Slice, 0, l2_idx))\n        .store_ref(new_l2)\n        .store_slice(scutlast(l1Slice, 0, 3 - l2_idx))\n        .end_cell();\n\n    cell new_l0 = begin_cell()\n        .store_slice(scutfirst(l0Slice, 0, l1_idx))\n        .store_ref(new_l1)\n        .store_slice(scutlast(l0Slice, 0, 3 - l1_idx))\n        .end_cell();\n\n    return (\n        begin_cell()\n            .store_slice(scutfirst(queueSlice, 0, l0_idx))\n            .store_ref(new_l0)\n            .store_slice(scutlast(queueSlice, 0, 3 - l0_idx))\n            .end_cell()\n    );\n}\n\n;; self\ncell DeterministicInsertionCircularQueue::set(cell self, int key, cell $obj, int newState) impure inline {\n    return DeterministicInsertionCircularQueue::_setRaw(\n        self,\n        key,\n        begin_cell()\n            .store_bool(true) ;; occupied\n            .store_uint(newState, DeterministicInsertionCircularQueue::statusBits)\n            .store_uint(key, DeterministicInsertionCircularQueue::keyBits)\n            .store_ref($obj)\n            .end_cell()\n    );\n}\n\ncell DeterministicInsertionCircularQueue::delete(cell self, int key) impure inline {\n    return DeterministicInsertionCircularQueue::_setRaw(\n        self,\n        key,\n        begin_cell()\n            .store_bool(false) ;; occupied\n            .store_uint(0, DeterministicInsertionCircularQueue::statusBits)\n            .store_uint(0, DeterministicInsertionCircularQueue::keyBits)\n            .store_ref(empty_cell())\n            .end_cell()\n    );\n}\n\ncell DeterministicInsertionCircularQueue::create() impure method_id {\n    ;; ceil(log4(MAX_CELL_BITS)) == 4\n    ;; build the initial contents of each leaf in the outer scope to save gas\n    cell initialContents = begin_cell()\n        .store_bool(false) ;; unoccupied\n        .store_uint(0, DeterministicInsertionCircularQueue::statusBits) ;; value not used until set\n        .store_uint(0, DeterministicInsertionCircularQueue::keyBits) ;; value not used until set\n        .store_ref(empty_cell()) ;; value not used until set\n        .end_cell();\n    return DeterministicInsertionCircularQueue::_buildLevel(4, initialContents);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/PacketSent.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::PacketSent::NAME = \"pktSent\"u;\n\n;; field names\nconst int md::PacketSent::nativeFee = 0;\nconst int md::PacketSent::zroFee = 1;\nconst int md::PacketSent::extraOptions = 2;\nconst int md::PacketSent::enforcedOptions = 3;\nconst int md::PacketSent::packetEncoded = 4;\nconst int md::PacketSent::nonce = 5;\nconst int md::PacketSent::msglibAddress = 6;\nconst int md::PacketSent::msglibSendEvents = 7;\n\ncell md::PacketSent::New(\n    int nativeFee,\n    int zroFee,\n    cell $extraOptions,\n    cell $enforcedOptions,\n    cell packetEncoded,\n    int nonce,\n    int msglibAddress,\n    cell $msglibSendEvents\n) impure inline method_id {\n    return cl::declare(\n        md::PacketSent::NAME,\n        unsafeTuple([\n            [cl::t::coins, nativeFee],          ;; md::PacketSent::nativeFee\n            [cl::t::coins, zroFee],             ;; md::PacketSent::zroFee\n            [cl::t::objRef, $extraOptions],     ;; md::PacketSent::extraOptions\n            [cl::t::objRef, $enforcedOptions],  ;; md::PacketSent::enforcedOptions\n            [cl::t::cellRef, packetEncoded],    ;; md::PacketSent::packetEncoded\n            [cl::t::uint64, nonce],             ;; md::PacketSent::nonce\n            [cl::t::address, msglibAddress],    ;; md::PacketSent::msglibAddress\n            [cl::t::objRef, $msglibSendEvents]  ;; md::PacketSent::msglibEvents\n        ])\n    );\n}\n\n;; ========================== Object Builders ==========================\n\nconst int md::PacketSent::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 8);\nconst int md::PacketSent::_headerFillerBits = _HEADER_WIDTH - md::PacketSent::_headerInfoBits;\nconst int md::PacketSent::_headerInfo = 705670168524170966093988960735291442056898952154447392698365;\n\ncell md::PacketSent::build(\n    int nativeFee,\n    int zroFee,\n    cell $extraOptions,\n    cell $enforcedOptions,\n    cell packetEncoded,\n    int nonce,\n    int msglibAddress,\n    cell $msglibSendEvents\n) impure inline {\n    return begin_cell()\n        .store_uint(md::PacketSent::_headerInfo, md::PacketSent::_headerInfoBits)\n        .store_ones(md::PacketSent::_headerFillerBits)\n        .store_uint128(nativeFee)\n        .store_uint128(zroFee)\n        .store_uint64(nonce)\n        .store_uint256(msglibAddress)\n        .store_ref($extraOptions)\n        .store_ref($enforcedOptions)\n        .store_ref(\n            begin_cell()\n            .store_ref(packetEncoded)\n            .store_ref($msglibSendEvents)\n            .end_cell()\n        )\n        .end_cell();\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/PacketId.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::PacketId::NAME = \"pktId\"u;\n\n;; field names\nconst int md::PacketId::path = 0;\nconst int md::PacketId::nonce = 1;\n\ncell md::PacketId::New(cell $path, int nonce) impure inline method_id {\n    return cl::declare(\n        md::PacketId::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $path], ;; md::PacketId::path\n            [cl::t::uint64, nonce]  ;; md::PacketId::nonce\n        ])\n    );\n}\n\n;; ========================== Object Builders ==========================\n\nconst int md::PacketId::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 2);\nconst int md::PacketId::_headerFillerBits = _HEADER_WIDTH - md::PacketId::_headerInfoBits;\nconst int md::PacketId::_headerInfo = 33180451689778480514427;\n\ncell md::PacketId::build(cell $path, int nonce) impure inline {\n    return begin_cell()\n        .store_uint(md::PacketId::_headerInfo, md::PacketId::_headerInfoBits) ;; header info\n        .store_ones(md::PacketId::_headerFillerBits)                          ;; header filler\n        .store_ref($path)                                                     ;; ref[0]\n        .store_uint(nonce, 64)                                                ;; uint[1]\n        .end_cell();\n}\n\n;; ========================== Sanitize ==========================\n\ncell md::PacketId::sanitize(cell $self) impure {\n    cell $path = $self.cl::get<objRef>(md::PacketId::path);\n    int nonce = $self.cl::get<uint64>(md::PacketId::nonce);\n\n    return md::PacketId::New($path, nonce);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/Nonce.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::Nonce::NAME = \"nonce\"u;\n\n;; field names\nconst int md::Nonce::nonce = 0;\n\ncell md::Nonce::New(int nonce) impure inline method_id {\n    return cl::declare(\n        md::Nonce::NAME,\n        unsafeTuple([\n            [cl::t::uint64, nonce] ;; md::Nonce::nonce\n        ])\n    );\n}\n\n;; ========================== Object Builders ==========================\nconst int md::Nonce::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 1);\nconst int md::Nonce::_headerFillerBits = _HEADER_WIDTH - md::Nonce::_headerInfoBits;\nconst int md::Nonce::_headerInfo = 124339069371385211;\n\n;; this function is unused by the protocol but will be used by OApps\ncell md::Nonce::build(int nonce) impure inline {\n    return begin_cell()\n        .store_uint(md::Nonce::_headerInfo, md::Nonce::_headerInfoBits) ;; header info\n        .store_ones(md::Nonce::_headerFillerBits)                       ;; header filler\n        .store_uint64(nonce)\n        .end_cell();\n}\n\n\n;; ========================== Object Getters ==========================\nconst int md::Nonce::_nonceOffset = _HEADER_WIDTH;\n\nint md::Nonce::getNonce(cell $self) impure inline {\n    return $self.cellPreloadUint64At(md::Nonce::_nonceOffset);\n}\n\n;; ========================== Sanitize ==========================\n\ncell md::Nonce::sanitize(cell $self) impure inline_ref {\n    int nonce = $self.cl::get<uint64>(md::Nonce::nonce);\n\n    return md::Nonce::New(nonce);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/MsglibSendCallback.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::MsglibSendCallback::NAME = \"libSndCb\"u;\n\n;; field names\nconst int md::MsglibSendCallback::nativeFee = 0;\nconst int md::MsglibSendCallback::zroFee = 1;\nconst int md::MsglibSendCallback::lzSend = 2;\nconst int md::MsglibSendCallback::packetEncoded = 3;\nconst int md::MsglibSendCallback::payees = 4;\nconst int md::MsglibSendCallback::nonceByteOffset = 5;\nconst int md::MsglibSendCallback::nonceBytes = 6;\nconst int md::MsglibSendCallback::guidByteOffset = 7;\nconst int md::MsglibSendCallback::guidBytes = 8;\nconst int md::MsglibSendCallback::msglibSendEvents = 9;\nconst int md::MsglibSendCallback::errorCode = 10;\n\ncell md::MsglibSendCallback::New(\n    int nativeFee,\n    int zroFee,\n    cell $lzSend,\n    cell packetEncoded,\n    cell payees,\n    int nonceByteOffset,\n    int nonceBytes,\n    int guidByteOffset,\n    int guidBytes,\n    cell $msglibSendEvents,\n    int errorCode\n) impure inline method_id {\n    return cl::declare(\n        md::MsglibSendCallback::NAME,\n        unsafeTuple([\n            [cl::t::coins, nativeFee],          ;; md::MsglibSendCallback::nativeFee\n            [cl::t::coins, zroFee],             ;; md::MsglibSendCallback::zroFee\n            [cl::t::objRef, $lzSend],           ;; md::MsglibSendCallback::lzSend\n            [cl::t::cellRef, packetEncoded],    ;; md::MsglibSendCallback::packetEncoded\n            [cl::t::cellRef, payees],           ;; md::MsglibSendCallback::payees\n            [cl::t::uint16, nonceByteOffset],   ;; md::MsglibSendCallback::nonceByteOffset\n            [cl::t::uint8, nonceBytes],         ;; md::MsglibSendCallback::nonceBytes\n            [cl::t::uint16, guidByteOffset],    ;; md::MsglibSendCallback::guidByteOffset\n            [cl::t::uint8, guidBytes],          ;; md::MsglibSendCallback::guidBytes\n            [cl::t::objRef, $msglibSendEvents], ;; md::MsglibSendCallback::msglibEvents\n            [cl::t::uint8, errorCode]           ;; md::MsglibSendCallback::errorCode\n        ])\n    );\n}\n\n;; ========================== Object Builders ==========================\n\nconst int md::MsglibSendCallback::_headerInfoBits = 198;\nconst int md::MsglibSendCallback::_headerFillerBits = _HEADER_WIDTH - (198 + _NAME_WIDTH);\nconst int md::MsglibSendCallback::_headerInfo = 177909621499943220462532613625031755041688677811453802367547;\n\ncell md::MsglibSendCallback::build(\n    int nativeFee,\n    int zroFee,\n    cell $lzSend,\n    cell packetEncoded,\n    cell payees,\n    int nonceByteOffset,\n    int nonceBytes,\n    int guidByteOffset,\n    int guidBytes,\n    cell $msglibSendEvents,\n    int errorCode\n) impure inline {\n    return begin_cell()\n        .store_uint(md::MsglibSendCallback::NAME, _NAME_WIDTH)                                    ;; name\n        .store_uint(md::MsglibSendCallback::_headerInfo, md::MsglibSendCallback::_headerInfoBits) ;; rest of the header\n        .store_ones(md::MsglibSendCallback::_headerFillerBits)                                    ;; header filler\n        .store_uint128(nativeFee)                                                                 ;; nativeFee\n        .store_uint128(zroFee)                                                                    ;; zroFee\n        .store_uint16(nonceByteOffset)                                                            ;; nonceByteOffset\n        .store_uint8(nonceBytes)                                                                  ;; nonceBytes\n        .store_uint16(guidByteOffset)                                                             ;; guidByteOffset\n        .store_uint8(guidBytes)                                                                   ;; guidBytes\n        .store_uint8(errorCode)                                                                   ;; errorCode\n        .store_ref($lzSend)                                                                       ;; lzSend\n        .store_ref(packetEncoded)                                                                 ;; packetEncoded\n        .store_ref(\n            begin_cell()\n                .store_ref(payees)                                                                ;; payees\n                .store_ref($msglibSendEvents)                                                     ;; msglibSendEvents\n            .end_cell()\n        )\n        .end_cell();\n}\n\n;; ========================== Object Getters ==========================\n\nconst int md::MsglibSendCallback::_nativeFeeOffset = _HEADER_WIDTH;\nconst int md::MsglibSendCallback::_zroFeeOffset = md::MsglibSendCallback::_nativeFeeOffset + 128;\nconst int md::MsglibSendCallback::_nonceByteOffsetOffset = md::MsglibSendCallback::_zroFeeOffset + 128;\nconst int md::MsglibSendCallback::_nonceBytesOffset = md::MsglibSendCallback::_nonceByteOffsetOffset + 16;\nconst int md::MsglibSendCallback::_guidByteOffsetOffset = md::MsglibSendCallback::_nonceBytesOffset + 8;\nconst int md::MsglibSendCallback::_guidBytesOffset = md::MsglibSendCallback::_guidByteOffsetOffset + 16;\nconst int md::MsglibSendCallback::_errorCodeOffset = md::MsglibSendCallback::_guidBytesOffset + 8;\n\n\ncell md::MsglibSendCallback::getLzSend(cell $self) impure inline {\n    return $self\n        .begin_parse()\n        .preload_ref_at(0);\n}\n\n;; ========================== Object Multi-Getters ==========================\n\n;; (errorCode, nativeFee, zroFee, lzSend, payees, encodedPacket, nonceByteOffset, nonceBytes, guidByteOffset, guidBytes, sendEvents)\n(int, int, int, cell, cell, cell, int, int, int, int, cell) md::MsglibSendCallback::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    slice ref2 = selfSlice.preloadRefSliceAt(2);\n    \n    return (\n        selfSlice.preloadUint8At(md::MsglibSendCallback::_errorCodeOffset),       ;; errorCode\n        selfSlice.preloadCoinsAt(md::MsglibSendCallback::_nativeFeeOffset),       ;; nativeFee\n        selfSlice.preloadCoinsAt(md::MsglibSendCallback::_zroFeeOffset),          ;; zroFee\n        selfSlice.preloadRefAt(0),                                                ;; lzSend\n        ref2.preloadRefAt(0),                                                     ;; payees\n        selfSlice.preloadRefAt(1),                                                ;; encodedPacket\n        selfSlice.preloadUint16At(md::MsglibSendCallback::_nonceByteOffsetOffset),;; nonceByteOffset\n        selfSlice.preloadUint8At(md::MsglibSendCallback::_nonceBytesOffset),      ;; nonceBytes\n        selfSlice.preloadUint16At(md::MsglibSendCallback::_guidByteOffsetOffset), ;; guidByteOffset\n        selfSlice.preloadUint8At(md::MsglibSendCallback::_guidBytesOffset),       ;; guidBytes\n        ref2.preloadRefAt(1)\n    );\n}\n\n;; ========================== Payees Utilities ==========================\n\nconst int payeesTuple::_addressIdx  = 0;\nconst int payeesTuple::_nativeAmountIdx = 1;\nconst int payees::_addressBits = 256;\nconst int payees::_nativeAmountBits = 64;\nconst int payees::_payeeBits = payees::_addressBits + payees::_nativeAmountBits;\n\n;; Serializes 3 payees (256-bit address => 64-bit TON coin amount) per cell.\ncell serializePayees(tuple payeesInfo) impure inline {\n    int numPayees = payeesInfo.tlen();\n    if (numPayees == 0) {\n        return empty_cell();\n    }\n\n    builder linkedList = begin_cell();\n    tuple curPayee = empty_tuple();\n    int idx = 1;\n    while (idx <= numPayees) {\n        curPayee = payeesInfo.tuple_at(numPayees - idx);\n        if (idx % 3 == 0) {\n            linkedList = begin_cell()\n                .store_ref(linkedList.end_cell())\n                .store_uint256(curPayee.int_at(payeesTuple::_addressIdx))\n                .store_uint64(curPayee.int_at(payeesTuple::_nativeAmountIdx));\n        } else {\n            linkedList = linkedList\n                .store_uint256(curPayee.int_at(payeesTuple::_addressIdx))\n                .store_uint64(curPayee.int_at(payeesTuple::_nativeAmountIdx));\n        }\n        idx += 1;\n    }\n\n    return linkedList.end_cell();\n}\n\n;; deserializePayees will ignore any bits beyond 960\ntuple deserializePayees(cell serializedPayees) impure inline {\n    slice payeesSlice = serializedPayees.begin_parse();\n    if (payeesSlice.slice_empty?()) {\n        return empty_tuple();\n    }\n    tuple payees = empty_tuple();\n    while (~ payeesSlice.slice_empty?()) {\n        payees = payees.tpush([payeesSlice~load_uint256(), payeesSlice~load_uint64()]);\n\n        ;; can you extract a second one?\n        if (payeesSlice.slice_bits() >= (payees::_payeeBits)) {\n            payees = payees.tpush([payeesSlice~load_uint256(), payeesSlice~load_uint64()]);\n        }\n\n        ;; how about a third?\n        if (payeesSlice.slice_bits() >= (payees::_payeeBits)) {\n            payees = payees.tpush([payeesSlice~load_uint256(), payeesSlice~load_uint64()]);\n        }\n\n        if (payeesSlice.slice_refs() > 0) {\n            payeesSlice = payeesSlice.preload_first_ref().begin_parse();\n        }\n    }\n    return payees;\n}\n\n;; Pop the last payee off the output of deserializePayees\n;; and return the modified payee list and the popped payee.\n(tuple, [int, int]) tpopPayee(tuple t) asm \"TPOP\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/MessagingReceipt.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::MessagingReceipt::NAME = \"MsgReceipt\"u;\n\n;; field names\nconst int md::MessagingReceipt::lzSend = 0;\nconst int md::MessagingReceipt::nativeFeeActual = 1;\nconst int md::MessagingReceipt::zroFeeActual = 2;\nconst int md::MessagingReceipt::errorCode = 3;\n\ncell md::MessagingReceipt::New(cell $lzSend, int nativeFee, int zroFee, int errorCode) impure inline method_id {\n    return cl::declare(\n        md::MessagingReceipt::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $lzSend],   ;; md::MessagingReceipt::lzSend\n            [cl::t::coins, nativeFee],  ;; md::MessagingReceipt::nativeFeeActual\n            [cl::t::coins, zroFee],     ;; md::MessagingReceipt::zroFeeActual\n            [cl::t::uint16, errorCode]  ;; md::MessagingReceipt::errorCode\n        ])\n    );\n}\n\n\n;; ========================== Object Builders ==========================\n\nconst int md::MessagingReceipt::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 4);\nconst int md::MessagingReceipt::_headerFillerBits = _HEADER_WIDTH - md::MessagingReceipt::_headerInfoBits;\nconst int md::MessagingReceipt::_headerInfo = 1727210451775936897226519655289233983117527419;\n\ncell md::MessagingReceipt::build(cell $lzSend, int nativeFee, int zroFee, int errorCode) impure inline {\n    return begin_cell()\n        .store_uint(md::MessagingReceipt::_headerInfo, md::MessagingReceipt::_headerInfoBits) ;; header info\n        .store_ones(md::MessagingReceipt::_headerFillerBits)                                  ;; header filler\n        .store_ref($lzSend)                                                                   ;; ref[0]\n        .store_uint128(nativeFee)                                                             ;; coins[1]\n        .store_uint128(zroFee)                                                                ;; coins[2]\n        .store_uint16(errorCode)                                                              ;; uint16[3]\n        .end_cell();\n}\n\n;; ========================== Object Accessors ==========================\n\nconst int md::MessagingReceipt::_nativeFeeOffset = _HEADER_WIDTH;\nconst int md::MessagingReceipt::_zroFeeOffset = _HEADER_WIDTH + 128;\nconst int md::MessagingReceipt::_errorCodeOffset = _HEADER_WIDTH + 256;\n\n;; this function is unused by the protocol but will be used by OApps\n(int, cell) md::MessagingReceipt::getErrorCodeAndLzSend(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadUint16At(md::MessagingReceipt::_errorCodeOffset),\n        selfSlice.preloadRefAt(0)\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/MdAddress.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::MdAddress::NAME = \"MdAddr\"u;\n\n;; field names\nconst int md::MdAddress::md = 0;\nconst int md::MdAddress::address = 1;\n\ncell md::MdAddress::New(cell $md, int address) inline method_id {\n    return cl::declare(\n        md::MdAddress::NAME,\n        unsafeTuple([\n            [cl::t::objRef, $md],       ;; md::MdAddress::md\n            [cl::t::address, address]   ;; md::MdAddress::address\n        ])\n    );\n}\n\n;; ========================== Object Builders ==========================\n\nconst int md::MdAddress::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 2);\nconst int md::MdAddress::_headerFillerBits = _HEADER_WIDTH - md::MdAddress::_headerInfoBits;\nconst int md::MdAddress::_headerInfo = 5847545689438192720283003;\n\ncell md::MdAddress::build(cell $md, int address) impure inline method_id {\n    return begin_cell()\n        .store_uint(md::MdAddress::_headerInfo, md::MdAddress::_headerInfoBits) ;; header info\n        .store_ones(md::MdAddress::_headerFillerBits)                          ;; header filler\n        .store_uint256(address)                                                 ;; md::MdAddress::address\n        .store_ref($md)                                                         ;; md::MdAddress::md = ref[0]\n        .end_cell();\n}\n\n;; ========================== Object Getters ==========================\n\nconst int md::MdAddress::_addressOffset = _HEADER_WIDTH;\n\ncell md::MdAddress::getMd(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0);\n}\n\n;; ========================== Object Multi-Getters ==========================\n\n(cell, int) md::MdAddress::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(0),\n        selfSlice.preloadAddressAt(md::MdAddress::_addressOffset)\n    );\n}\n\n;; ========================== Sanitize ==========================\n\ncell md::MdAddress::sanitize(cell $self) impure inline_ref {\n    int address = $self.cl::get<uint256>(md::MdAddress::address);\n    cell $md = $self.cl::get<objRef>(md::MdAddress::md);\n\n    return md::MdAddress::New($md, address);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/LzSend.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n#include \"../lz/Packet.fc\";\n\n;; required storage name\nconst int md::LzSend::NAME = \"lzSend\"u;\n\n;; field names\nconst int md::LzSend::sendRequestId = 0;\nconst int md::LzSend::sendMsglibManager = 1;\nconst int md::LzSend::sendMsglib = 2;\nconst int md::LzSend::sendMsglibConnection = 3;\nconst int md::LzSend::packet = 4;\nconst int md::LzSend::nativeFee = 5;\nconst int md::LzSend::zroFee = 6;\nconst int md::LzSend::extraOptions = 7;\nconst int md::LzSend::enforcedOptions = 8;\nconst int md::LzSend::callbackData = 9;\n\ncell md::LzSend::New(\n    int nativeFee,\n    int zroFee,\n    cell $extraOptions,\n    cell $enforcedOptions,\n    cell $packet,\n    cell callbackData\n) impure inline method_id {\n    return cl::declare(\n        md::LzSend::NAME,\n        unsafeTuple([\n            [cl::t::uint64, 0],                 ;; md::LzSend::sendRequestId\n            [cl::t::address, NULLADDRESS],      ;; md::LzSend::sendMsglibManager\n            [cl::t::address, NULLADDRESS],      ;; md::lzSend::sendMsglib\n            [cl::t::address, NULLADDRESS],      ;; md::lzSend::sendMsglibConnection\n            [cl::t::objRef, $packet],           ;; md::LzSend::packet\n            [cl::t::coins, nativeFee],          ;; md::LzSend::nativeFee\n            [cl::t::coins, zroFee],             ;; md::LzSend::zroFee\n            [cl::t::objRef, $extraOptions],     ;; md::LzSend::extraOptions\n            [cl::t::objRef, $enforcedOptions],  ;; md::LzSend::enforcedOptions\n            [cl::t::objRef, callbackData]       ;; md::LzSend::callbackData\n        ])\n    );\n}\n\nconst int md::LzSend::_headerPostNameBits = 180;\nconst int md::LzSend::_headerFillerBits = _HEADER_WIDTH - (md::LzSend::_headerPostNameBits + _NAME_WIDTH);\nconst int md::LzSend::_headerInfo = 582890735024998957421269964955452773563747974476099581;\n\n;; ========================== Object Builders ==========================\n\n;; this function is unused by the protocol but will be used by OApps\ncell md::LzSend::build(\n    int nativeFee,\n    int zroFee,\n    cell $extraOptions,\n    cell $enforcedOptions,\n    cell $packet,\n    cell callbackData\n) impure inline {\n    return begin_cell()\n        .store_uint(md::LzSend::NAME, _NAME_WIDTH)\n        .store_uint(md::LzSend::_headerInfo, md::LzSend::_headerPostNameBits)\n        .store_ones(md::LzSend::_headerFillerBits)\n        .store_uint64(0)                       ;; sendRequestId\n        .store_uint256(NULLADDRESS)            ;; sendMsglibManager\n        .store_uint256(NULLADDRESS)            ;; sendMsglib\n        .store_ref($packet)\n        .store_ref($extraOptions)\n        .store_ref(\n            begin_cell()\n                .store_uint256(NULLADDRESS)    ;; sendMsglibConnection\n                .store_uint128(nativeFee)      ;; nativeFee\n                .store_uint128(zroFee)         ;; zroFee\n                .store_ref($enforcedOptions)   ;; enforcedOptions\n                .store_ref(callbackData)       ;; callbackData\n                .end_cell()\n        )\n        .end_cell();\n}\n\n;; ====================== Object Accessors =====================\n\n;; in root cell\nconst int md::LzSend::_sendRequestIdffset = _HEADER_WIDTH;\nconst int md::LzSend::_sendMsglibManagerOffset = md::LzSend::_sendRequestIdffset + 64;\nconst int md::LzSend::_sendMsglibOffset = md::LzSend::_sendMsglibManagerOffset + 256;\n\n;; in ref[2]\nconst int md::LzSend::_sendMsglibConnectionOffset = 0;\nconst int md::LzSend::_nativeFeeOffset = md::LzSend::_sendMsglibConnectionOffset + 256;\nconst int md::LzSend::_zroFeeOffset = md::LzSend::_nativeFeeOffset + 128;\n\nint md::LzSend::getSendRequestId(cell $self) impure inline {\n    return $self.cellPreloadUint64At(md::LzSend::_sendRequestIdffset);\n}\n\nint md::LzSend::getSendMsglib(cell $self) impure inline {\n    return $self.cellPreloadAddressAt(md::LzSend::_sendMsglibOffset);\n}\n\ncell md::LzSend::getPacket(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0);\n}\n\n;; gets the path from the packet inside the LzSend\ncell md::LzSend::getPath(cell $self) impure inline {\n    return $self.cellPreloadRefAt(0).cellPreloadRefAt(0);\n}\n\n;; (requestId, nativeFee, zroFee, extraOptions, enforcedOptions, sendMsglibManager)\n(int, int, int, cell, cell, int) md::LzSend::deserializeSendCallback(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    slice ref2Slice = selfSlice.preloadRefSliceAt(2);\n    return (\n        selfSlice.preloadUint64At(md::LzSend::_sendRequestIdffset),\n        ref2Slice.preloadCoinsAt(md::LzSend::_nativeFeeOffset),\n        ref2Slice.preloadCoinsAt(md::LzSend::_zroFeeOffset),\n        selfSlice.preloadRefAt(1),\n        ref2Slice.preloadRefAt(0),\n        selfSlice.preloadAddressAt(md::LzSend::_sendMsglibManagerOffset)\n    );\n}\n\n;; (packet, extraOptions, enforcedOptions)\n(cell, cell, cell) md::LzSend::getQuoteInformation(cell $self) impure inline {\n    return (\n        $self.cellPreloadRefAt(0),\n        $self.cellPreloadRefAt(1),\n        $self.cellPreloadRefAt(2).cellPreloadRefAt(0)\n    );\n}\n\n(cell, cell) md::LzSend::getPacketAndCallbackData(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadRefAt(0),\n        selfSlice.preloadRefSliceAt(2).preloadRefAt(1)\n    );\n}\n\n;; ====================== Object Composite Modifiers =====================\n\nconst int md::lzSend::requestInfoWidth = _HEADER_WIDTH + 64 + 256 + 256;\n;; Can't easily store a slice constant because the header isn't byte-aligned\nconst int md::lzSend::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 10);\nconst int md::lzSend::_headerPrefix = 11424049401754228397633815938683071207390004427712457772775726065407;\nconst int md::lzSend::_headerSuffix = 17331160549995323848587739135;\nconst int md::lzSend::_headerTrailingBits = _HEADER_WIDTH - 256;\n\ncell md::LzSend::fillRequestInfo(\n    cell $self,\n    int requestId,\n    int sendMsglibManager,\n    int sendMsglib,\n    int sendMsglibConnection\n) impure inline method_id {\n    slice selfslice = $self.begin_parse();\n    slice ref2Slice = selfslice.preloadRefSliceAt(2);\n\n    ;; Fill in the fields AND overwrite the entire header to match the expected format\n    return begin_cell()\n        .store_uint256(md::lzSend::_headerPrefix)\n        .store_uint(md::lzSend::_headerSuffix, md::lzSend::_headerTrailingBits)\n        .store_slice(selfslice.scutfirst(0, 2))\n        .store_uint64(requestId)\n        .store_uint256(sendMsglibManager)\n        .store_uint256(sendMsglib)\n        .store_ref(\n            begin_cell()\n                .store_uint256(sendMsglibConnection)\n                .store_slice(ref2Slice.sskipfirst(md::LzSend::_nativeFeeOffset, 0))\n                .end_cell()\n        )\n        .end_cell();\n}\n\ncell md::LzSend::setPacketNonceAndGuid(cell $self, int packetNonce, int packetGuid) impure inline {\n    slice selfSlice = $self.begin_parse();\n\n    cell $newPacket = selfSlice~load_ref()\n        .lz::Packet::setNonceAndGuid(packetNonce, packetGuid);\n\n    return begin_cell()\n        .store_ref($newPacket)\n        .store_slice(selfSlice)\n        .end_cell();\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/LzReceiveStatus.fc",
        "content": "#include \"../lz/Packet.fc\";\n\n;; required storage name\nconst int md::LzReceiveStatus::NAME = \"LzRecvSts\"u;\n\n;; field names\nconst int md::LzReceiveStatus::success = 0;\nconst int md::LzReceiveStatus::nonce = 1;\nconst int md::LzReceiveStatus::value = 2;\nconst int md::LzReceiveStatus::extraData = 3;\nconst int md::LzReceiveStatus::reason = 4;\nconst int md::LzReceiveStatus::sender = 5;\nconst int md::LzReceiveStatus::packet = 6;\nconst int md::LzReceiveStatus::executionStatus = 7;\n\ncell md::LzReceiveStatus::New(int success, int nonce) impure inline method_id {\n    return cl::declare(\n        md::LzReceiveStatus::NAME,\n        unsafeTuple([\n            [cl::t::bool, success],             ;; md::LzReceiveStatus::success\n            [cl::t::uint64, nonce],             ;; md::LzReceiveStatus::nonce\n            [cl::t::coins, 0],                  ;; md::LzReceiveAlert::value\n            [cl::t::cellRef, empty_cell()],     ;; md::LzReceiveAlert::extraData\n            [cl::t::cellRef, empty_cell()],     ;; md::LzReceiveAlert::reason\n            [cl::t::address, NULLADDRESS],      ;; md::LzReceiveAlert::sender\n            [cl::t::objRef, cl::nullObject()],  ;; md::LzReceiveAlert::packet\n            [cl::t::uint8, 0]                   ;; md::LzReceiveAlert::executionStatus\n        ])\n    );\n}\n\ncell md::LzReceiveStatus::NewFull(\n    int success,\n    int nonce,\n    int value,\n    cell extraData,\n    cell reason,\n    int sender,\n    cell $packet,\n    int executionStatus\n) impure inline method_id {\n    lz::Packet::_assertValidLinkedList(extraData, lz::Packet::MAX_RECEIVE_MESSAGE_CELLS);\n    lz::Packet::_assertValidLinkedList(reason, lz::Packet::MAX_RECEIVE_MESSAGE_CELLS);\n    return cl::declare(\n        md::LzReceiveStatus::NAME,\n        unsafeTuple([\n            [cl::t::bool, success],         ;; md::LzReceiveStatus::success\n            [cl::t::uint64, nonce],         ;; md::LzReceiveStatus::nonce\n            [cl::t::coins, value],          ;; md::LzReceiveAlert::sendRequestId\n            [cl::t::cellRef, extraData],    ;; md::LzReceiveAlert::extraData\n            [cl::t::cellRef, reason],       ;; md::LzReceiveAlert::reason\n            [cl::t::address, sender],       ;; md::LzReceiveAlert::sender\n            [cl::t::objRef, $packet],       ;; md::LzReceiveAlert::packet\n            [cl::t::uint8, executionStatus] ;; md::LzReceiveAlert::executionStatus\n        ])\n    );\n}\n\n;; ====================== Object Builders =====================\n\nconst int md::LzReceiveStatus::_headerInfoBits = _BASIC_HEADER_WIDTH + (_FIELD_INFO_WIDTH * 8);\nconst int md::LzReceiveStatus::_headerFillerBits = _HEADER_WIDTH - md::LzReceiveStatus::_headerInfoBits;\nconst int md::LzReceiveStatus::_headerInfo = 31461150238884194531671275676859177915085721713836393515717807231;\n\n;; this function is unused by the protocol but will be used by OApps\ncell md::LzReceiveStatus::build(\n    int success,\n    int nonce\n) impure inline method_id {\n    return begin_cell()\n        .store_uint(md::LzReceiveStatus::_headerInfo, md::LzReceiveStatus::_headerInfoBits) ;; header info\n        .store_ones(md::LzReceiveStatus::_headerFillerBits)                                 ;; header filler\n        .store_bool(success)                                                                 ;; bool[0]\n        .store_uint64(nonce)                                                                 ;; uint64[1]\n        .store_uint128(0)                                                                    ;; coins[2]\n        .store_uint256(NULLADDRESS)                                                          ;; address[3]\n        .store_uint8(0)                                                                      ;; uint8[4]\n        .store_ref(cl::nullObject())                                                         ;; ref[0]\n        .store_ref(cl::nullObject())                                                         ;; ref[1]\n        .store_ref(\n            begin_cell()\n                .store_ref(cl::nullObject())                                                 ;; ref[2]\n            .end_cell()\n        )\n        .end_cell();\n}\n\n\n;; ====================== Object Multi-Getters =====================\n\nconst int md::LzReceiveStatus::_successOffset = _HEADER_WIDTH;\nconst int md::LzReceiveStatus::_nonceOffset = md::LzReceiveStatus::_successOffset + 1;\nconst int md::LzReceiveStatus::_valueOffset = md::LzReceiveStatus::_nonceOffset + 64;\nconst int md::LzReceiveStatus::_senderOffset = md::LzReceiveStatus::_valueOffset + 128;\nconst int md::LzReceiveStatus::_executionStatusOffset = md::LzReceiveStatus::_senderOffset + 256;\nconst int md::LzReceiveStatus::_extraDataOffset = md::LzReceiveStatus::_executionStatusOffset + 8;\n\n(int, int) md::LzReceiveStatus::getSuccessAndNonce(cell $self) impure inline {\n    slice $selfSlice = $self.begin_parse(); \n    return (\n        $selfSlice.preloadBoolAt(md::LzReceiveStatus::_successOffset),\n        $selfSlice.preloadUint64At(md::LzReceiveStatus::_nonceOffset)\n    );\n}\n\n;; ========================== Sanitize ==========================\n\ncell md::LzReceiveStatus::NewFull::sanitize(cell $self) impure {\n    int success = $self.cl::get<bool>(md::LzReceiveStatus::success);\n    int nonce = $self.cl::get<uint64>(md::LzReceiveStatus::nonce);\n    int value = $self.cl::get<coins>(md::LzReceiveStatus::value);\n    cell extraData = $self.cl::get<cellRef>(md::LzReceiveStatus::extraData);\n    cell reason = $self.cl::get<cellRef>(md::LzReceiveStatus::reason);\n    int sender = $self.cl::get<address>(md::LzReceiveStatus::sender);\n    cell $packet = $self.cl::get<objRef>(md::LzReceiveStatus::packet);\n    int executionStatus = $self.cl::get<uint8>(md::LzReceiveStatus::executionStatus);\n\n    return md::LzReceiveStatus::NewFull(\n        success,\n        nonce,\n        value,\n        extraData,\n        reason,\n        sender,\n        $packet,\n        executionStatus\n    );\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/LzReceivePrepare.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::LzReceivePrepare::NAME = \"lzrecvprep\"u;\n\n;; field names\nconst int md::LzReceivePrepare::nonce = 0;\nconst int md::LzReceivePrepare::nanotons = 1;\n\ncell md::LzReceivePrepare::New(int nonce, int nanotons) impure method_id {\n    return cl::declare(\n        md::LzReceivePrepare::NAME,\n        unsafeTuple([\n            [cl::t::uint64, nonce], ;; md::LzReceivePrepare::nonce\n            [cl::t::coins, nanotons] ;; md::LzReceivePrepare::nanotons\n        ])\n    );\n}\n\n;; ====================== Object Getters =====================\n\nconst int md::LzReceivePrepare::_nonceOffset = _HEADER_WIDTH;\nconst int md::LzReceivePrepare::_nanotonsOffset = md::LzReceivePrepare::_nonceOffset + 64;\n\n;; this function is unused by the protocol but will be used by OApps\nint md::LzReceivePrepare::getNanotons(cell $self) impure inline {\n    return $self.cellPreloadCoinsAt(md::LzReceivePrepare::_nanotonsOffset);\n}\n\n;; ====================== Object Multi-Getters =====================\n\n(int, int) md::LzReceivePrepare::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadUint64At(md::LzReceivePrepare::_nonceOffset),\n        selfSlice.preloadCoinsAt(md::LzReceivePrepare::_nanotonsOffset)\n    );\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/classes/msgdata/ChannelNonceInfo.fc",
        "content": "#include \"../../funC++/classlib.fc\";\n\n;; required storage name\nconst int md::ChannelNonceInfo::NAME = \"cNonceInfo\"u;\n\n;; field names\nconst int md::ChannelNonceInfo::nonce = 0;\nconst int md::ChannelNonceInfo::firstUnexecutedNonce = 1;\n\ncell md::ChannelNonceInfo::New(int nonce, int firstUnexecutedNonce) impure inline method_id {\n    return cl::declare(\n        md::ChannelNonceInfo::NAME,\n        unsafeTuple([\n            [cl::t::uint64, nonce], ;; md::ChannelNonceInfo::nonce\n            [cl::t::uint64, firstUnexecutedNonce]   ;; md::ChannelNonceInfo::firstUnexecutedNonce\n        ])\n    );\n}\n\n;; ====================== Object Getters =====================\n\nconst int md::ChannelNonceInfo::_nonceOffset = _HEADER_WIDTH;\nconst int md::ChannelNonceInfo::_firstUnexecutedNonceOffset = md::ChannelNonceInfo::_nonceOffset + 64;\n\n(int, int) md::ChannelNonceInfo::deserialize(cell $self) impure inline {\n    slice selfSlice = $self.begin_parse();\n    return (\n        selfSlice.preloadUint64At(md::ChannelNonceInfo::_nonceOffset),\n        selfSlice.preloadUint64At(md::ChannelNonceInfo::_firstUnexecutedNonceOffset)\n    );\n}\n\ncell md::ChannelNonceInfo::sanitize(cell $self) impure inline_ref {\n    int nonce = $self.cl::get<uint64>(md::ChannelNonceInfo::nonce);\n    int firstUnexecutedNonce = $self.cl::get<uint64>(md::ChannelNonceInfo::firstUnexecutedNonce);\n\n    return md::ChannelNonceInfo::New(nonce, firstUnexecutedNonce);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "src/protocol/channel/main.fc",
        "content": "#include \"../core/abstract/protocolMain.fc\";\n\n#include \"handler.fc\";\n#include \"interface.fc\";\n\ntuple _executeOpcode(int op, cell $md) impure inline {\n    if (op == Channel::OP::SET_EP_CONFIG_OAPP) {\n        return setEpConfigOApp($md);\n    } elseif (op == Channel::OP::CHANNEL_SEND) {\n        return channelSend($md);\n    } elseif (op == Channel::OP::MSGLIB_SEND_CALLBACK) {\n        return msglibSendCallback($md);\n    } elseif (op == Channel::OP::CHANNEL_COMMIT_PACKET) {\n        return channelCommitPacket($md);\n    } elseif (op == Channel::OP::LZ_RECEIVE_PREPARE) {\n        return lzReceivePrepare($md);\n    } elseif (op == Channel::OP::LZ_RECEIVE_LOCK) {\n        return lzReceiveLock($md);\n    } elseif (op == Channel::OP::LZ_RECEIVE_EXECUTE_CALLBACK) {\n        return lzReceiveExecuteCallback($md);\n    } elseif (op == Channel::OP::DEPOSIT_ZRO) {\n        return depositZro($md);\n    } elseif (op == Channel::OP::NILIFY) {\n        return nilify($md);\n    } elseif (op == Channel::OP::BURN) {\n        return burn($md);\n    } elseif (op == Channel::OP::FORCE_ABORT) {\n        return forceAbort($md);\n    } elseif (op == Channel::OP::SYNC_MSGLIB_CONNECTION) {\n        return syncMsglibConnection($md);\n    } elseif (op == Channel::OP::NOTIFY_PACKET_EXECUTED) {\n        return notifyPacketExecuted($md);\n    } elseif (op == Channel::OP::EMIT_LZ_RECEIVE_ALERT) {\n        return emitLzReceiveAlert($md);\n    } else {\n        throw(BaseInterface::ERROR::invalidOpcode);\n    }\n    return empty_tuple();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}