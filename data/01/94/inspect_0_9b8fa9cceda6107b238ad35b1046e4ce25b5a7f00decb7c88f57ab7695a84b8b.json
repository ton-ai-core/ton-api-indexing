{
  "code": "b5ee9c7201021c0100059c000114ff00f4a413f4bcf2c80b01020120020302014804050228f230db3c8103eef844c0fff2f2f8007ff864db3c1a1b0202ce0607028ba03859b679b679041082aa87f085f0a1f087f0a7f0a5f09df09bf099f097f095f08bf09ff08c1a22261a182224181622221614222014213e211c20fa20d820b620f420d220b11a190201200809020120171804f5007434c0c05c6c3c903e900c36cf3e10b03ffe10d48831c16c23b40ccc74c7c87000234127265706561745f656e645f61756374696f6e8148831c16c23a0d6f6cf380cb00023411656d657267656e63795f6d6573736167658148831c16c26b50c3434c1f50c007ec0380c383e14d48431c163a10ccc76cf3800601a100a0b001320840ee6b280006a6120015c318103e9f852d749c202f2f28103ea01d31f821005138d9112ba12f2f48040d721fa4030f87270f8627ff864db3c1b04e8db3c20c0018ebd30328103edf823f850bef2f28103edf842c0fff2f28103f00182103b9aca00b9f2f28103f1f84ec200f2f2f8525210c705f8435220c705b1f2e193db3ce020c002e302c003925f03e0f842c0fff823f850beb1975f038103edf2f0e0f84b82103b9aca00a05220bef84bc200b00c0d0e0f008c20c700c0ff923070e0d31f318b663616e63656c821c705923071e08b473746f70821c705923072e08b666696e697368821c705923072e08b66465706c6f79801c7059173e070018a7020f82582105fcc3d14c8cb1fcb3ff852cf165003cf1612cb0021fa02cb00c9718018c8cb05f853cf1670fa02cb6acc82080f424070fb02c98306fb007ff8627ff866db3c1b017630328103edf842c0fff2f28103f00182103b9aca00b9f2f28103f2f823f850b9f2f2f8525210c705f8435220c705b1f84d5220c705b1f2e193db3c1004ce8f160270db3c21f86d82103b9aca00a1f86ef823f86fdb3ce0f850f851a1f823b997f850f851a0f870def84e8e95328103e8f84a5220b9f2f2f86ef86df823f86fdb3ce1f84e821005f5e100a0f84ef84ca6648064f003b6095220b9975f038103e8f2f0e0027014101b110294f84ec0008e3d7020f82582105fcc3d14c8cb1fcb3ff852cf165003cf1612cb0021fa02cb00c9718018c8cb05f853cf1670fa02cb6acc82080f424070fb02c98306fb00e30e7ff862db3c121b021adb3c01f86df86ef823f86fdb3c141b02fadb3cf84e4054f00320c2008e2b70208010c8cb055007cf1622fa0216cb6a15cb1f8bf4d61726b6574706c616365206665658cf16c972fb009134e2f84e4003f00320c2008e2370208010c8cb055004cf1622fa0213cb6a12cb1f8b7526f79616c74798cf16c972fb009131e282080f424070fb02f84e58a101a120c200191300c08e2270208010c8cb05f852cf165003fa0212cb6acb1f8b650726f6669748cf16c972fb009130e27020f82582105fcc3d14c8cb1fcb3ff84dcf165003cf1612cb008208989680fa02cb00c9718018c8cb05f853cf1670fa02cb6accc98306fb0002f2f84ec101915be0f84ef847a1228208989680a15210bc9930018208989680a1019132e28d0a565bdd5c88189a59081a185cc81899595b881bdd5d189a5908189e48185b9bdd1a195c881d5cd95c8ba001c0ff8e1f308d06d05d58dd1a5bdb881a185cc81899595b8818d85b98d95b1b19590ba0de21c200e30f1516003870208018c8cb05f84dcf165004fa0213cb6a12cb1f01cf16c972fb0000025b001120840ee6b2802a6120001d08300024d7c0dc38167c00807c00600020f848d0fa40d31fd31ffa40d31fd31f3000caf8416edded44d0d20001f862d20001f864d20001f866fa4001f86dfa0001f86ed31f01f86fd31f01f870fa4001f872d401f868d430f869f849d0d21f01f867fa4001f863fa0001f86afa0001f86bfa0001f86cd31f01f871fa4001f873d31f30f8657ff8610054f849f848f850f84ff846f844f842c8ca00ca00ca00f84dcf16f84efa02cb1fcb1ff852cf16ccccc9ed54",
  "code_hash": "ad0daa79d94b1f4c9d4c3dd8cfd8f933ef92b170abaceeca9145b5066a91251b",
  "methods": [
    {
      "id": 72748,
      "method": "get_sale_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "struct/op-codes.func",
        "content": ";;\r\n;;  op codes\r\n;;\r\n\r\nint op::transfer()              asm \"0x5fcc3d14 PUSHINT\";\r\nint op::ownership_assigned()    asm \"0x05138d91 PUSHINT\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/storage.func",
        "content": ";;\r\n;;  persistant and runtime storage Ð²escription\r\n;;\r\n\r\nglobal int      init?; ;; init_data safe check\r\nglobal int      end?; ;; end auction or not\r\nglobal slice    mp_addr; ;; the address of the marketplace from which the contract is deployed\r\nglobal int      activated?; ;; contract is activated by external message or by nft transfer\r\nglobal int      created_at?; ;; timestamp of created acution\r\nglobal int      is_canceled?; ;; auction was cancelled by owner\r\nglobal int      sub_gas_price_from_bid?; ;; amound of gas used for processing bif\r\n\r\nglobal cell fees_cell;\r\nglobal cell constant_cell;\r\n\r\n;; bids info cell (ref)\r\nglobal int      min_bid; ;; minimal bid\r\nglobal int      max_bid; ;; maximum bid\r\nglobal int      min_step; ;; minimum step (can be 0)\r\nglobal slice    last_member; ;; last member address\r\nglobal int      last_bid; ;; last bid amount\r\nglobal int      last_bid_at; ;; timestamp of last bid\r\nglobal int      end_time; ;; unix end time\r\nglobal int      step_time; ;; by how much the time increases with the new bid (e.g. 30)\r\n\r\n;; nft info cell (ref)\r\nglobal slice    nft_owner; ;; nft owner addres (should be sent nft if auction canceled or money from auction)\r\nglobal slice    nft_addr; ;; nft address\r\n\r\n\r\n() init_data() impure inline_ref {- save for get methods -} {\r\n    ifnot(null?(init?)) { return ();}\r\n\r\n    slice ds = get_data().begin_parse();\r\n    end? = ds~load_int(1);\r\n    activated? = ds~load_int(1);\r\n    is_canceled? = ds~load_int(1);\r\n    last_member = ds~load_msg_addr();\r\n    last_bid = ds~load_coins();\r\n    last_bid_at = ds~load_uint(32);\r\n    end_time = ds~load_uint(32);\r\n    nft_owner = ds~load_msg_addr();\r\n\r\n    fees_cell = ds~load_ref();\r\n    constant_cell = ds~load_ref();\r\n    slice constants = constant_cell.begin_parse();\r\n    sub_gas_price_from_bid? = constants~load_int(32);\r\n    mp_addr = constants~load_msg_addr();\r\n    min_bid = constants~load_coins();\r\n    max_bid = constants~load_coins();\r\n    min_step = constants~load_coins();\r\n    step_time = constants~load_uint(32);\r\n    nft_addr = constants~load_msg_addr();\r\n    created_at? = constants~load_uint(32);\r\n\r\n\r\n    init? = true;\r\n}\r\n\r\n() pack_data() impure inline_ref {\r\n    set_data(\r\n            begin_cell()\r\n                    .store_int(end?, 1) ;; + stc    1\r\n                    .store_int(activated?, 1) ;; activated? 1\r\n                    .store_int(is_canceled?, 1) ;; 1\r\n                    .store_slice(last_member) ;; + max    267 ($10 with Anycast = 0)\r\n                    .store_coins(last_bid) ;; + max    124\r\n                    .store_uint(last_bid_at, 32) ;; + stc    32\r\n                    .store_uint(end_time, 32) ;; + stc    32\r\n                    .store_slice(nft_owner) ;; 267\r\n                    .store_ref(fees_cell) ;; + ref\r\n                    .store_ref(constant_cell) ;; + ref\r\n                    .end_cell()\r\n            ;; total 267 + 124 + 32 + 32 + 267 + 1 + 1 + 1 = 725\r\n    );\r\n}\r\n\r\n(slice, int, int, slice, int, int) get_fees() inline_ref {\r\n    slice fees = fees_cell.begin_parse();\r\n    slice mp_fee_addr = fees~load_msg_addr();\r\n    int mp_fee_factor = fees~load_uint(32);\r\n    int mp_fee_base = fees~load_uint(32);\r\n    slice royalty_fee_addr = fees~load_msg_addr();\r\n    int royalty_fee_factor = fees~load_uint(32);\r\n    int royalty_fee_base = fees~load_uint(32);\r\n    return (\r\n            mp_fee_addr,\r\n            mp_fee_factor,\r\n            mp_fee_base,\r\n            royalty_fee_addr,\r\n            royalty_fee_factor,\r\n            royalty_fee_base\r\n    );\r\n}\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/math.func",
        "content": ";;\r\n;;  math utils\r\n;;\r\n\r\nint division(int a, int b) { ;; division with factor\r\n    return muldiv(a, 1000000000 {- 1e9 -}, b);\r\n}\r\n\r\nint multiply(int a, int b) { ;; multiply with factor\r\n    return muldiv (a, b, 1000000000 {- 1e9 -});\r\n}\r\n\r\nint math::get_percent(int a, int percent, int factor) {\r\n    if (factor == 0) {\r\n        return 0;\r\n    } else {\r\n        return division(multiply(a, percent), factor);\r\n    }\r\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/msg-utils.func",
        "content": ";;\r\n;;  text constants for msg comments\r\n;;\r\n\r\nslice msg::cancel_msg()     asm \"<b 124 word cancel| $, b> <s PUSHSLICE\";\r\nslice msg::stop_msg()       asm \"<b 124 word stop| $, b> <s PUSHSLICE\";\r\nslice msg::finish_msg()       asm \"<b 124 word finish| $, b> <s PUSHSLICE\";\r\nslice msg::deploy()       asm \"<b 124 word deploy| $, b> <s PUSHSLICE\";\r\n\r\nslice msg::return_msg()     asm \"<b 124 word Your transaction has not been accepted.| $, b> <s PUSHSLICE\";\r\nslice msg::bid_return()     asm \"<b 124 word Your bid has been outbid by another user.| $, b> <s PUSHSLICE\";\r\nslice msg::mp_msg()         asm \"<b 124 word Marketplace fee| $, b> <s PUSHSLICE\";\r\nslice msg::royalty_msg()    asm \"<b 124 word Royalty| $, b> <s PUSHSLICE\";\r\nslice msg::profit_msg()     asm \"<b 124 word Profit| $, b> <s PUSHSLICE\";\r\nslice msg::auc_is_canceled() asm \"<b 124 word Auction has been cancelled.| $, b> <s PUSHSLICE\";\r\n\r\nslice msg::repeat_end_auction()     asm \"<b 124 word repeat_end_auction| $, b> <s PUSHSLICE\";\r\nslice msg::emergency_message()      asm \"<b 124 word emergency_message| $, b> <s PUSHSLICE\";",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/exit-codes.func",
        "content": ";;\r\n;;  custom TVM exit codes\r\n;;\r\n\r\nint exit::low_bid()           asm \"1000 PUSHINT\";\r\nint exit::auction_init()      asm \"1001 PUSHINT\";\r\nint exit::no_transfer()       asm \"1002 PUSHINT\";\r\nint exit::not_message()       asm \"1003 PUSHINT\";\r\nint exit::not_cancel()        asm \"1004 PUSHINT\";\r\nint exit::auction_end()       asm \"1005 PUSHINT\";\r\nint exit::already_activated() asm \"1006 PUSHINT\";\r\nint exit::cant_cancel_end()   asm \"1007 PUSHINT\";\r\nint exit::low_amount()        asm \"1008 PUSHINT\";\r\nint exit::cant_cancel_bid()   asm \"1009 PUSHINT\";\r\nint exit::cant_stop_time()    asm \"1010 PUSHINT\";\r\n\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "struct/handles.func",
        "content": "{-\r\n    SHOULD\r\n    [+] check init auction or not\r\n    [+] check op\r\n    [+] change nft owner\r\n    [+] change auction status\r\n-}\r\n() handle::try_init_auction(slice sender_addr, slice in_msg_body) impure inline_ref {\r\n    throw_if(exit::auction_init(), nft_owner.slice_bits() > 2); ;; throw if auction already init\r\n    throw_unless(exit::no_transfer(), in_msg_body~load_uint(32) == op::ownership_assigned()); ;; throw if it`s not ownership assigned\r\n    in_msg_body~skip_bits(64); ;; query id\r\n    nft_owner = in_msg_body~load_msg_addr();\r\n    end? = false;\r\n    activated? = true;\r\n    pack_data();\r\n}\r\n\r\n\r\n() handle::cancel(slice sender_addr) impure inline_ref {\r\n    builder nft_transfer_body = begin_cell()\r\n            .store_uint(op::transfer(), 32)\r\n            .store_uint(cur_lt(), 64) ;; query id\r\n            .store_slice(nft_owner) ;; return nft no creator\r\n            .store_slice(sender_addr) ;; response_destination\r\n            .store_uint(0, 1) ;; custom payload\r\n            .store_coins(0) ;; forward amount\r\n            .store_uint(0, 1); ;; forward payload\r\n\r\n    builder nft_return_msg = begin_cell()\r\n            .store_uint(0x18, 6)\r\n            .store_slice(nft_addr)\r\n            .store_coins(0)\r\n            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n            .store_ref(nft_transfer_body.end_cell());\r\n\r\n    raw_reserve(1000000, 0); ;; reserve some bebras  ðŸˆ\r\n\r\n    send_raw_message(nft_return_msg.end_cell(), 128);\r\n    end? = true;\r\n    is_canceled? = true;\r\n    pack_data();\r\n}\r\n\r\n() handle::end_auction(slice sender_addr) impure inline_ref {\r\n    if (last_bid == 0) { ;; just return nft\r\n        builder nft_transfer_body = begin_cell()\r\n                .store_uint(op::transfer(), 32)\r\n                .store_uint(cur_lt(), 64) ;; query id\r\n                .store_slice(nft_owner) ;; owner who create auction\r\n                .store_slice(sender_addr) ;; response_destination\r\n                .store_uint(0, 1) ;; custom payload\r\n                .store_coins(0) ;; forward amount\r\n                .store_uint(0, 1); ;; forward payload\r\n\r\n        builder nft_return_msg = begin_cell()\r\n                .store_uint(0x18, 6)\r\n                .store_slice(nft_addr)\r\n                .store_coins(0)\r\n                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                .store_ref(nft_transfer_body.end_cell());\r\n\r\n        raw_reserve(1000000, 0); ;; reserve some bebras  ðŸˆ\r\n\r\n        send_raw_message(nft_return_msg.end_cell(), 128);\r\n    } else {\r\n        var (\r\n                mp_fee_addr,\r\n                mp_fee_factor,\r\n                mp_fee_base,\r\n                royalty_fee_addr,\r\n                royalty_fee_factor,\r\n                royalty_fee_base\r\n        ) = get_fees();\r\n\r\n        int mp_fee = math::get_percent(last_bid, mp_fee_factor, mp_fee_base);\r\n\r\n        if (mp_fee > 0) {\r\n            builder mp_transfer = begin_cell()\r\n                    .store_uint(0x10, 6) ;; 0 (int_msg_info) 1 (ihr_disabled) 1 (no bounces) 00 (address)\r\n                    .store_slice(mp_fee_addr)\r\n                    .store_coins(mp_fee)\r\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                    .store_uint(0, 32)\r\n                    .store_slice(msg::mp_msg());\r\n\r\n            send_raw_message(mp_transfer.end_cell(), 2);\r\n        }\r\n\r\n        int royalty_fee = math::get_percent(last_bid, royalty_fee_factor, royalty_fee_base);\r\n\r\n        if (royalty_fee > 0) {\r\n            builder royalty_transfer = begin_cell()\r\n                    .store_uint(0x10, 6) ;; 0 (int_msg_info) 1 (ihr_disabled) 1 (no bounces) 00 (address)\r\n                    .store_slice(royalty_fee_addr)\r\n                    .store_coins(royalty_fee)\r\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                    .store_uint(0, 32)\r\n                    .store_slice(msg::royalty_msg());\r\n\r\n            send_raw_message(royalty_transfer.end_cell(), 2);\r\n        }\r\n\r\n        raw_reserve(1000000, 0); ;; reserve some bebras  ðŸˆ\r\n\r\n        int profit = last_bid - mp_fee - royalty_fee;\r\n        if (profit > 0) {\r\n            builder prev_owner_msg = begin_cell()\r\n                    .store_uint(0x10, 6) ;; 0 (int_msg_info) 1 (ihr_disabled) 1 (no bounces) 00 (address)\r\n                    .store_slice(nft_owner)\r\n                    .store_coins(profit)\r\n                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                    .store_uint(0, 32)\r\n                    .store_slice(msg::profit_msg());\r\n\r\n            send_raw_message(prev_owner_msg.end_cell(), 2);\r\n        }\r\n\r\n        builder nft_transfer_body = begin_cell()\r\n                .store_uint(op::transfer(), 32)\r\n                .store_uint(cur_lt(), 64) ;; query id\r\n                .store_slice(last_member) ;; new owner\r\n                .store_slice(sender_addr) ;; response_destination\r\n                .store_uint(0, 1) ;; custom payload\r\n                .store_coins(10000000) ;; forward amount  0.01 ton\r\n                .store_uint(0, 1); ;; forward payload\r\n        builder nft_transfer = begin_cell()\r\n                .store_uint(0x18, 6)\r\n                .store_slice(nft_addr)\r\n                .store_coins(0)\r\n                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                .store_ref(nft_transfer_body.end_cell());\r\n        send_raw_message(nft_transfer.end_cell(), 128);\r\n    }\r\n    end? = true;\r\n    pack_data();\r\n}\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "nft-auction-v3.func",
        "content": "#include \"struct/op-codes.func\";\r\n#include \"struct/exit-codes.func\";\r\n#include \"struct/math.func\";\r\n#include \"struct/msg-utils.func\";\r\n#include \"struct/storage.func\";\r\n#include \"struct/handles.func\";\r\n#include \"struct/get-met.func\";\r\n\r\n() return_last_bid(int my_balance, int is_cancel_auc) impure inline_ref {\r\n    if (last_bid <= 0) {\r\n        return ();\r\n    }\r\n\r\n    int return_bid_amount = last_bid - sub_gas_price_from_bid?; ;; 0.009909 TON magic gas price per bid processing\r\n    if (return_bid_amount > (my_balance - 10000000)) { ;; - 0.01 TON\r\n        return_bid_amount = my_balance - 10000000;\r\n    }\r\n\r\n    slice msg = msg::bid_return();\r\n\r\n    if (is_cancel_auc == true) {\r\n        msg = msg::auc_is_canceled();\r\n    }\r\n\r\n    if (return_bid_amount > 0) {\r\n        builder return_prev_bid = begin_cell()\r\n                .store_uint(0x18, 6)\r\n                .store_slice(last_member)\r\n                .store_coins(return_bid_amount)\r\n                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\r\n                .store_uint(0, 32)\r\n                .store_slice(msg);\r\n\r\n        send_raw_message(return_prev_bid.end_cell(), 2);\r\n    }\r\n}\r\n\r\n(int) get_command_code(slice s) inline_ref {\r\n    if (slice_empty?(s) == true) {\r\n        return 0;\r\n    }\r\n\r\n    int op = s~load_uint(32);\r\n    if (equal_slices(msg::cancel_msg(), s)) {\r\n        return 1;\r\n    } elseif (equal_slices(msg::stop_msg(), s)) {\r\n        return 2;\r\n    } elseif (equal_slices(msg::finish_msg(), s)) {\r\n        return 2; ;; 2 its ok\r\n    } elseif (equal_slices(msg::deploy(), s)) {\r\n        return 3;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\n() recv_internal(int my_balance, int msg_value, cell in_msg_cell, slice in_msg_body) impure {\r\n    slice cs = in_msg_cell.begin_parse();\r\n    throw_if(0, cs~load_uint(4) & 1);\r\n\r\n    slice sender_addr = cs~load_msg_addr();\r\n    init_data();\r\n\r\n    if ((end? == true) & equal_slices(sender_addr, mp_addr)) {\r\n        int op = in_msg_body~load_uint(32);\r\n        if ((op == 0) & equal_slices(in_msg_body, msg::repeat_end_auction())) {\r\n            ;; special case for repeat end_auction logic if nft not transfered from auc contract\r\n            handle::end_auction(sender_addr);\r\n            return ();\r\n        }\r\n        if ((op == 0) & equal_slices(in_msg_body, msg::emergency_message())) {\r\n            ;; way to fix unexpected troubles with auction contract\r\n            ;; for example if some one transfer nft to this contract\r\n            var msg = in_msg_body~load_ref().begin_parse();\r\n            var mode = msg~load_uint(8);\r\n            send_raw_message(msg~load_ref(), mode);\r\n            return ();\r\n        }\r\n        ;; accept coins for deploy\r\n        return ();\r\n    }\r\n\r\n    if (equal_slices(sender_addr, nft_addr)) {\r\n        handle::try_init_auction(sender_addr, in_msg_body);\r\n        return ();\r\n    }\r\n\r\n    int command = get_command_code(in_msg_body);\r\n\r\n\r\n    if (command == 1) { ;; cancel command, return nft, return last bid\r\n        throw_if(exit::auction_end(), now() >= end_time); ;; after timeout can't cancel\r\n        throw_if(exit::auction_end(), end? == true); ;; already canceled/ended\r\n        throw_if(exit::low_amount(), msg_value < 1000000000);\r\n        throw_if(exit::cant_cancel_bid(), last_bid > 0); ;; can't cancel if someone already placed a bid\r\n        throw_unless(403, equal_slices(sender_addr, nft_owner) | equal_slices(sender_addr, mp_addr));\r\n        handle::cancel(sender_addr);\r\n        return ();\r\n    }\r\n\r\n    if (command == 2) { ;; stop auction\r\n        throw_if(exit::auction_end(), end? == true); ;; end = true mean this action already executed\r\n        throw_if(exit::low_amount(), msg_value < 1000000000);\r\n        throw_if(exit::cant_stop_time(), now() < end_time); ;; can't end auction in progress, only after end time\r\n        throw_unless(403, equal_slices(sender_addr, nft_owner) | equal_slices(sender_addr, mp_addr) | equal_slices(sender_addr, last_member));\r\n        handle::end_auction(sender_addr);\r\n        return ();\r\n    }\r\n\r\n    if (command == 3) {\r\n        ;; jsut accept coins\r\n        return ();\r\n    }\r\n\r\n\r\n    if ((end? == true) | (now() >= end_time)) {\r\n        throw(exit::auction_end());\r\n        return ();\r\n    }\r\n\r\n    ;; new bid\r\n\r\n    ;; max bid buy nft\r\n    if ((msg_value >= max_bid + 1000000000) & (max_bid > 0)) { ;; 1 TON\r\n        ;; end aution for this bid\r\n        return_last_bid(my_balance, false);\r\n        last_member = sender_addr;\r\n        last_bid = msg_value - 1000000000;\r\n        last_bid_at = now();\r\n        handle::end_auction(sender_addr);\r\n        return ();\r\n    }\r\n\r\n    ;; prevent bid at last second\r\n    if ((end_time - step_time) < now()) {\r\n        end_time += step_time;\r\n    }\r\n\r\n    ifnot(last_bid) {\r\n        throw_if(exit::low_bid(), msg_value < min_bid);\r\n        last_bid = msg_value;\r\n        last_member = sender_addr;\r\n        last_bid_at = now();\r\n        pack_data();\r\n        return ();\r\n    }\r\n\r\n    int new_min_bid = max(\r\n        last_bid + 100000000,\r\n        math::get_percent(last_bid, 100 + min_step, 100)\r\n    );\r\n    if (msg_value < new_min_bid) {\r\n        throw(exit::low_bid());\r\n        return ();\r\n    }\r\n\r\n    return_last_bid(my_balance, false);\r\n\r\n    last_member = sender_addr;\r\n    last_bid = msg_value;\r\n    last_bid_at = now();\r\n\r\n    pack_data();\r\n}\r\n\r\n{-\r\n    Message for deploy contract external\r\n-}\r\n() recv_external(slice in_msg) impure {\r\n    init_data();\r\n    throw_if(exit::already_activated(), activated? == true);\r\n    accept_message();\r\n    activated? = true;\r\n    pack_data();\r\n}",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\r\n;;\r\n\r\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\r\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\r\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\r\nforall X -> X car(tuple list) asm \"CAR\";\r\ntuple cdr(tuple list) asm \"CDR\";\r\ntuple empty_tuple() asm \"NIL\";\r\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\r\nforall X -> [X] single(X x) asm \"SINGLE\";\r\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\r\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\r\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\r\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\r\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\r\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\r\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\r\nforall X -> X first(tuple t) asm \"FIRST\";\r\nforall X -> X second(tuple t) asm \"SECOND\";\r\nforall X -> X third(tuple t) asm \"THIRD\";\r\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\r\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\r\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\r\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\r\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\r\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\r\nforall X -> X null() asm \"PUSHNULL\";\r\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\r\n\r\nint now() asm \"NOW\";\r\nslice my_address() asm \"MYADDR\";\r\n[int, cell] get_balance() asm \"BALANCE\";\r\nint cur_lt() asm \"LTIME\";\r\nint block_lt() asm \"BLOCKLT\";\r\n\r\nint cell_hash(cell c) asm \"HASHCU\";\r\nint slice_hash(slice s) asm \"HASHSU\";\r\nint string_hash(slice s) asm \"SHA256U\";\r\n\r\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\r\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\r\n\r\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\r\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\r\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\r\n\r\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\r\n\r\n() dump_stack() impure asm \"DUMPSTK\";\r\n\r\ncell get_data() asm \"c4 PUSH\";\r\n() set_data(cell c) impure asm \"c4 POP\";\r\ncont get_c3() impure asm \"c3 PUSH\";\r\n() set_c3(cont c) impure asm \"c3 POP\";\r\ncont bless(slice s) impure asm \"BLESS\";\r\n\r\n() accept_message() impure asm \"ACCEPT\";\r\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\r\n() commit() impure asm \"COMMIT\";\r\n() buy_gas(int gram) impure asm \"BUYGAS\";\r\n\r\nint min(int x, int y) asm \"MIN\";\r\nint max(int x, int y) asm \"MAX\";\r\n(int, int) minmax(int x, int y) asm \"MINMAX\";\r\nint abs(int x) asm \"ABS\";\r\n\r\nslice begin_parse(cell c) asm \"CTOS\";\r\n() end_parse(slice s) impure asm \"ENDS\";\r\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\r\ncell preload_ref(slice s) asm \"PLDREF\";\r\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\r\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\r\n;; int preload_int(slice s, int len) asm \"PLDIX\";\r\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\r\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\r\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\r\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\r\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\r\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\r\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\r\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\r\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\r\ncell preload_dict(slice s) asm \"PLDDICT\";\r\nslice skip_dict(slice s) asm \"SKIPDICT\";\r\n\r\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\r\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\r\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\r\n\r\nint cell_depth(cell c) asm \"CDEPTH\";\r\n\r\nint slice_refs(slice s) asm \"SREFS\";\r\nint slice_bits(slice s) asm \"SBITS\";\r\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\r\nint slice_empty?(slice s) asm \"SEMPTY\";\r\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\r\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\r\nint slice_depth(slice s) asm \"SDEPTH\";\r\n\r\nint builder_refs(builder b) asm \"BREFS\";\r\nint builder_bits(builder b) asm \"BBITS\";\r\nint builder_depth(builder b) asm \"BDEPTH\";\r\n\r\nbuilder begin_cell() asm \"NEWC\";\r\ncell end_cell(builder b) asm \"ENDC\";\r\n    builder store_ref(builder b, cell c) asm(c b) \"STREF\";\r\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\r\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\r\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\r\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\r\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\r\n\r\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\r\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\r\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\r\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\r\n\r\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\r\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\r\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\r\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\r\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\r\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\r\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\r\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\r\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\r\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\r\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\r\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\r\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\r\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\r\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\r\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\r\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\r\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\r\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\r\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\r\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\r\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\r\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\r\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\r\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\r\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\r\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\r\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\r\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\r\ncell new_dict() asm \"NEWDICT\";\r\nint dict_empty?(cell c) asm \"DICTEMPTY\";\r\n\r\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\r\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\r\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\r\n\r\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\r\nint cell_null?(cell c) asm \"ISNULL\";\r\n\r\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\r\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\r\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\r\n() set_code(cell new_code) impure asm \"SETCODE\";\r\n\r\nint random() impure asm \"RANDU256\";\r\nint rand(int range) impure asm \"RAND\";\r\nint get_seed() impure asm \"RANDSEED\";\r\nint set_seed() impure asm \"SETRAND\";\r\n() randomize(int x) impure asm \"ADDRAND\";\r\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\r\n\r\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\r\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\r\n\r\nint equal_slices (slice a, slice b) asm \"SDEQ\";\r\nint builder_null?(builder b) asm \"ISNULL\";\r\nbuilder store_builder(builder to, builder from) asm \"STBR\";",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "struct/get-met.func",
        "content": ";; 1  2    3    4      5      6      7    8      9    10     11   12   13     14   15   16   17   18   19   20\r\n(int, int, int, slice, slice, slice, int, slice, int, slice, int, int, slice, int, int, int, int, int, int, int) get_sale_data() method_id {\r\n    init_data();\r\n\r\n    var (\r\n            mp_fee_addr,\r\n            mp_fee_factor,\r\n            mp_fee_base,\r\n            royalty_fee_addr,\r\n            royalty_fee_factor,\r\n            royalty_fee_base\r\n    ) = get_fees();\r\n\r\n    return (\r\n            0x415543, ;; 1 nft aucion (\"AUC\")\r\n            end?, ;; 2\r\n            end_time, ;; 3\r\n            mp_addr, ;; 4\r\n            nft_addr, ;; 5\r\n            nft_owner, ;; 6\r\n            last_bid, ;; 7\r\n            last_member, ;; 8\r\n            min_step, ;; 9\r\n            mp_fee_addr, ;; 10\r\n            mp_fee_factor, mp_fee_base, ;; 11, 12\r\n            royalty_fee_addr, ;; 13\r\n            royalty_fee_factor, royalty_fee_base, ;; 14, 15\r\n            max_bid, ;; 16\r\n            min_bid, ;; 17\r\n            created_at?, ;; 18\r\n            last_bid_at, ;; 19\r\n            is_canceled? ;; 20\r\n    );\r\n}\r\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}