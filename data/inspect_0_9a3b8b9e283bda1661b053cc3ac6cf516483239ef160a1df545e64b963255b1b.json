{
  "code": "b5ee9c7201020b010001ed000114ff00f4a413f4bcf2c80b0102016202030202cc040502037a60090a03efd9910e38048adf068698180b8d848adf07d201800e98fe99ff6a2687d007d206a6a18400aa9385d47181a9aa8aae382f9702480fd207d006a18106840306b90fd001812881a28217804d02a906428027d012c678b666664f6aa7041083deecbef29385d71811a92e001f1811802600271812f82c207f97840607080093b3f0508806e0a84026a8280790a009f404b19e2c039e2d99924591960225e801e80196019241f200e0e9919605940f97ff93a0ef003191960ab19e2ca009f4042796d625999992e3f60100fe3603fa00fa40f82854120870542013541403c85004fa0258cf1601cf16ccc922c8cb0112f400f400cb00c9f9007074c8cb02ca07cbffc9d05008c705f2e04a12a1035024c85004fa0258cf16ccccc9ed5401fa403020d70b01c3008e1f8210d53276db708010c8cb055003cf1622fa0212cb6acb1fcb3fc98042fb00915be200303515c705f2e049fa403059c85004fa0258cf16ccccc9ed54002e5143c705f2e049d43001c85004fa0258cf16ccccc9ed54007dadbcf6a2687d007d206a6a183618fc1400b82a1009aa0a01e428027d012c678b00e78b666491646580897a007a00658064fc80383a6465816503e5ffe4e840001faf16f6a2687d007d206a6a183faa9040",
  "code_hash": "13f5d7a316c6d76e1053e88ac59b5de65a072a388451371dc5c5becbba13f50e",
  "methods": [
    {
      "id": 103289,
      "method": "get_wallet_address"
    },
    {
      "id": 106029,
      "method": "get_jetton_data"
    }
  ],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "imports/constants.fc",
        "content": ";; operations (constant values taken from crc32 on op message in the companion .tlb files and appear during build)\nint op::increment() asm \"0x37491f2f PUSHINT\";\nint op::deposit() asm \"0x47d54391 PUSHINT\";\nint op::withdraw() asm \"0x41836980 PUSHINT\";\nint op::transfer_ownership() asm \"0x2da38aaf PUSHINT\";\n\n;; errors\nint error::unknown_op() asm \"101 PUSHINT\";\nint error::access_denied() asm \"102 PUSHINT\";\nint error::insufficient_balance() asm \"103 PUSHINT\";\n\n;; other\nint const::min_tons_for_storage() asm \"10000000 PUSHINT\"; ;; 0.01 TON",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "imports/params.fc",
        "content": "int workchain() asm \"0 PUSHINT\";\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == workchain());\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "imports/op-codes.fc",
        "content": "int op::transfer() asm \"0xf8a7ea5 PUSHINT\";\nint op::transfer_notification() asm \"0x7362d09c PUSHINT\";\nint op::internal_transfer() asm \"0x178d4519 PUSHINT\";\nint op::excesses() asm \"0xd53276db PUSHINT\";\nint op::burn() asm \"0x595f07bc PUSHINT\";\nint op::burn_notification() asm \"0x7bdd97de PUSHINT\";\n\n;; Minter\nint op::mint() asm \"21 PUSHINT\";\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\nint set_seed() impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "imports/utils.fc",
        "content": "() send_grams(slice address, int amount) impure {\n  cell msg = begin_cell()\n    .store_uint (0x18, 6) ;; bounce\n    .store_slice(address) ;; 267 bit address\n    .store_grams(amount)\n    .store_uint(0, 107) ;; 106 zeroes +  0 as an indicator that there is no cell with the data\n    .end_cell(); \n  send_raw_message(msg, 3); ;; mode, 2 for ignoring errors, 1 for sender pays fees, 64 for returning inbound message value\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      },
      {
        "name": "jetton-minter.fc",
        "content": ";; Jettons minter smart contract\n\n;; storage scheme\n;; storage#_ total_supply:Coins admin_address:MsgAddress content:^Cell jetton_wallet_code:^Cell = Storage;\n\n#include \"imports/stdlib.fc\";\n#include \"imports/params.fc\";\n#include \"imports/constants.fc\";\n#include \"imports/jetton-utils.fc\";\n#include \"imports/op-codes.fc\";\n#include \"imports/utils.fc\";\n#pragma version >=0.2.0;\n\n(int, slice, cell, cell) load_data() inline {\n  slice ds = get_data().begin_parse();\n  return (\n      ds~load_coins(), ;; total_supply\n      ds~load_msg_addr(), ;; admin_address\n      ds~load_ref(), ;; content\n      ds~load_ref()  ;; jetton_wallet_code\n  );\n}\n\n() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {\n  set_data(begin_cell()\n            .store_coins(total_supply)\n            .store_slice(admin_address)\n            .store_ref(content)\n            .store_ref(jetton_wallet_code)\n           .end_cell()\n          );\n}\n\n() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {\n  cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);\n  slice to_wallet_address = calculate_jetton_wallet_address(state_init);\n  var msg = begin_cell()\n    .store_uint(0x18, 6)\n    .store_slice(to_wallet_address)\n    .store_coins(amount)\n    .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)\n    .store_ref(state_init)\n    .store_ref(master_msg);\n  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors\n}\n\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n  \n    int op = in_msg_body~load_uint(32);\n    int query_id = in_msg_body~load_uint(64);\n\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n\n    if (op == op::mint()) {\n        throw_unless(73, equal_slices(sender_address, admin_address));\n        slice to_address = in_msg_body~load_msg_addr();\n        int amount = in_msg_body~load_coins();\n        cell master_msg = in_msg_body~load_ref();\n        slice master_msg_cs = master_msg.begin_parse();\n        master_msg_cs~skip_bits(32 + 64); ;; op + query_id\n        int jetton_amount = master_msg_cs~load_coins();\n        mint_tokens(to_address, jetton_wallet_code, amount, master_msg);\n        save_data(total_supply + jetton_amount, admin_address, content, jetton_wallet_code);\n        return ();\n    }\n\n    if (op == op::burn_notification()) {\n        int jetton_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n        throw_unless(74,\n            equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address)\n        );\n        save_data(total_supply - jetton_amount, admin_address, content, jetton_wallet_code);\n        slice response_address = in_msg_body~load_msg_addr();\n        if (response_address.preload_uint(2) != 0) {\n          var msg = begin_cell()\n            .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000\n            .store_slice(response_address)\n            .store_coins(0)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(op::excesses(), 32)\n            .store_uint(query_id, 64);\n          send_raw_message(msg.end_cell(), 2 + 64);\n        }\n        return ();\n    }\n\n    if (op == 3) { ;; change admin\n        throw_unless(73, equal_slices(sender_address, admin_address));\n        slice new_admin_address = in_msg_body~load_msg_addr();\n        save_data(total_supply, new_admin_address, content, jetton_wallet_code);\n        return ();\n    }\n\n    if (op == 4) { ;; change content, delete this for immutable tokens\n        throw_unless(73, equal_slices(sender_address, admin_address));\n        save_data(total_supply, admin_address, in_msg_body~load_ref(), jetton_wallet_code);\n        return ();\n    }\n\n    throw(0xffff);\n}\n\n(int, int, slice, cell, cell) get_jetton_data() method_id {\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n    return (total_supply, -1, admin_address, content, jetton_wallet_code);\n}\n\nslice get_wallet_address(slice owner_address) method_id {\n    (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();\n    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "imports/jetton-utils.fc",
        "content": "cell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n   return  begin_cell()\n            .store_coins(balance)\n            .store_slice(owner_address)\n            .store_slice(jetton_master_address)\n            .store_ref(jetton_wallet_code)\n           .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n  return begin_cell()\n          .store_uint(0, 2)\n          .store_dict(jetton_wallet_code)\n          .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\n          .store_uint(0, 1)\n         .end_cell();\n}\n\nslice calculate_jetton_wallet_address(cell state_init) inline {\n  return begin_cell().store_uint(4, 3)\n                     .store_int(workchain(), 8)\n                     .store_uint(cell_hash(state_init), 256)\n                     .end_cell()\n                     .begin_parse();\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n  return calculate_jetton_wallet_address(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": false
      }
    ]
  }
}