{
  "code": "b5ee9c7201021101000301000114ff00f4a413f4bcf2c80b0102016202030202cb040502016e0d0e02d5d007434c0c05c6c2497c0f80871c03cb4320074c7f4cfd66103c8a0841ef765f7af48f0c12c08f0c22c08e084354c9db6ef6c3cbc80fe900c083e9136cf041157c14c8cc1303fc0ee84ac092084354c9db6eea55b1c7cb4643809300126cd00fcb86445440d167c06f8c3a060704f9a5ed9e1903698390e180116182d8116183d8796869923a5879696010e000476b9a1a11e002c71d981a7d2068e4400800e58292e78b28027d013800e5b564b87d80410c0ba43b7400397d8164400800e582a801e78b387d013800e5b564c080417d80474918916003c74400fd2068a0226d9e492d997171718680e182c010090a0b005c804ff833206e953080b1f833de206ef2d29ad0d30731d3ffd3fff404d307d430d0fa00fa00fa00fa00fa00fa0030018e313522c0088e3e6c2102f2d19059baf2e197d3ff308210c0550ccf01c8cbffc970830771800cc8cb03cb01cb0813cbff02957158cb61cc987058cb6101d0cf16e2c970fb00e30e0801ee3033330282107bdd97deba8ee701fa00fa40fa4031d39fd4d120db3c305005c705f2e19203d0d31fd39fd307d13001c001f2e19a01fa4401c000f2e19d8210c0470ccf04c8cb9f13cb7fcb9fcbffc971830771800cc8cb03cb01cb0813cbff02957158cb61cc987058cb6101d0cf16e2c970fb00915be20f0014c85003cf16ccccc9ed5401d66c22350172b0f2d2c003d3ff31d20f31d3fffa00d4fa00d121d0d31fd39fd307d15bc001f2e19a70500474c8cb0212ca07cbffc9d05343bcf2e18f01db3cc880152802cb1fcb3f5003cf165003fa025003fa02c9c8801801cb0558cf165003fa027701cb6bccccc970fb000f01228e8c82010009705412008040db3c915be20c0044708010c8cb055007cf1658fa0215cb6a13cb1fcb3f21c2ff92cbff9131e2c901fb000115b6973b67805f4888006e3010010bb5159b6786100f0152db3c32c870fa0213ccccc97020c8cb0113f400f400cb00c9207001f90074c8cb0212ca07cbffc9d001100010ed44d0fa40d4d4d1",
  "code_hash": "649e1cd227476b07abb193da4166ea0f560576571b7b645c130241ead14ae430",
  "methods": [],
  "compiler": "func",
  "source": {
    "files": [
      {
        "name": "jetton-wallet.fc",
        "content": ";; Jetton Wallet Smart Contract\n\n#include \"stdlib.fc\";\n#include \"params.fc\";\n#include \"op-codes.fc\";\n#include \"messages.fc\";\n#include \"utils.fc\";\n#include \"errors.fc\";\n#include \"config.fc\";\n\n\n{-\n\nNOTE that this tokens can be transferred within the same workchain.\n\nThis is suitable for most tokens, if you need tokens transferable between workchains there are two solutions:\n\n1) use more expensive but universal function to calculate message forward fee for arbitrary destination (see `misc/forward-fee-calc.cs`)\n\n2) use token holder proxies in target workchain (that way even 'non-universal' token can be used from any workchain)\n\n-}\n\n{-\n  Storage\n  storage#_ balance:Coins owner_address:MsgAddressInt jetton_master_address:MsgAddressInt jetton_wallet_code:^Cell = Storage;\n-}\n\n(int, slice, slice, cell) load_data() inline {\n  slice ds = get_data().begin_parse();\n\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = (ds~load_coins(), ds~load_msg_addr(), ds~load_msg_addr(), ds~load_ref());\n  ds.end_parse();\n\n  return (balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() save_data (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) impure inline {\n  set_data(pack_jetton_wallet_data(balance, owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n{-\n  transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress\n           response_destination:MsgAddress custom_payload:(Maybe ^Cell)\n           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)\n           = InternalMsgBody;\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell)\n                     = InternalMsgBody;\n-}\n\n() send_tokens (slice in_msg_body, slice sender_address, int msg_value, int fwd_fee, int wallet_min_tons_for_storage, int wallet_gas_consumption) impure {\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  slice to_owner_address = in_msg_body~load_msg_addr();\n  force_chain(to_owner_address);\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  balance -= jetton_amount;\n\n  throw_unless(error::unauthorized_transfer, equal_slices(owner_address, sender_address));\n  throw_unless(error::not_enough_funds, balance >= 0);\n\n  cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, jetton_wallet_code);\n  slice to_wallet_address = calculate_address_by_state_init(state_init);\n  slice response_address = in_msg_body~load_msg_addr();\n  cell custom_payload = in_msg_body~load_dict();\n  int forward_ton_amount = in_msg_body~load_coins();\n  throw_unless(error::malformed_forward_payload, slice_bits(in_msg_body) >= 1);\n  slice either_forward_payload = in_msg_body;\n  var msg = begin_cell()\n          .store_msg_flags(BOUNCEABLE)\n          .store_slice(to_wallet_address)\n          .store_coins(0)\n          .store_msgbody_prefix_stateinit()\n          .store_ref(state_init);\n  var msg_body = begin_cell()\n          .store_body_header(op::internal_transfer, query_id)\n          .store_coins(jetton_amount)\n          .store_slice(owner_address)\n          .store_slice(response_address)\n          .store_coins(forward_ton_amount)\n          .store_slice(either_forward_payload)\n          .end_cell();\n\n  msg = msg.store_ref(msg_body);\n  int fwd_count = forward_ton_amount ? 2 : 1;\n  throw_unless(error::not_enough_tons, msg_value >\n          forward_ton_amount +\n                  ;; 3 messages: wal1->wal2,  wal2->owner, wal2->response\n                  ;; but last one is optional (it is ok if it fails)\n                  fwd_count * fwd_fee +\n                  (2 * wallet_gas_consumption + wallet_min_tons_for_storage));\n  ;; universal message send fee calculation may be activated here\n  ;; by using this instead of fwd_fee\n  ;; msg_fwd_fee(to_wallet, msg_body, state_init, 15)\n\n  send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE); ;; revert on errors\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n{-\n  internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress\n                     response_address:MsgAddress\n                     forward_ton_amount:(VarUInteger 16)\n                     forward_payload:(Either Cell ^Cell)\n                     = InternalMsgBody;\n-}\n\n() receive_tokens (slice in_msg_body, slice sender_address, int my_ton_balance, int fwd_fee, int msg_value, int wallet_min_tons_for_storage, int wallet_gas_consumption) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  slice from_address = in_msg_body~load_msg_addr();\n  slice response_address = in_msg_body~load_msg_addr();\n  throw_unless(error::unauthorized_incoming_transfer,\n          equal_slices(jetton_master_address, sender_address)\n                  |\n                  equal_slices(calculate_user_jetton_wallet_address(from_address, jetton_master_address, jetton_wallet_code), sender_address)\n  );\n  int forward_ton_amount = in_msg_body~load_coins();\n\n  int ton_balance_before_msg = my_ton_balance - msg_value;\n  int storage_fee = wallet_min_tons_for_storage - min(ton_balance_before_msg, wallet_min_tons_for_storage);\n  msg_value -= (storage_fee + wallet_gas_consumption);\n  if(forward_ton_amount) {\n    msg_value -= (forward_ton_amount + fwd_fee);\n    slice either_forward_payload = in_msg_body;\n\n    var msg_body = begin_cell()\n            .store_body_header(op::transfer_notification, query_id)\n            .store_coins(jetton_amount)\n            .store_slice(from_address)\n            .store_slice(either_forward_payload)\n            .end_cell();\n\n    var msg = begin_cell()\n            .store_msg_flags(NON_BOUNCEABLE) ;; we should not bounce here cause receiver can have uninitialized contract\n            .store_slice(owner_address)\n            .store_coins(forward_ton_amount)\n            .store_msgbody_prefix_ref()\n            .store_ref(msg_body);\n\n    send_raw_message(msg.end_cell(), SEND_MODE_PAY_FEES_SEPARETELY);\n  }\n\n  if ((response_address.preload_uint(2) != 0) & (msg_value > 0)) {\n    var msg = begin_cell()\n            .store_msg_flags(NON_BOUNCEABLE)\n            .store_slice(response_address)\n            .store_coins(msg_value)\n            .store_msgbody_prefix_slice()\n            .store_body_header(op::excesses, query_id);\n    send_raw_message(msg.end_cell(), SEND_MODE_IGNORE_ERRORS);\n  }\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() burn_tokens (slice in_msg_body, slice sender_address) impure {\n  ;; NOTE we can not allow fails in action phase since in that case there will be\n  ;; no bounce. Thus check and throw in computation phase.\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  throw_unless(error::not_enough_funds, jetton_amount > 0);\n  slice response_address = in_msg_body~load_msg_addr();\n  cell custom_payload = in_msg_body~load_dict();\n  slice custom_payload_slice = custom_payload.begin_parse();\n  int destination_address = custom_payload_slice~load_uint(160); ;; destination address in other network\n  custom_payload_slice.end_parse();\n  in_msg_body.end_parse();\n\n  balance -= jetton_amount;\n  throw_unless(error::unauthorized_transfer, equal_slices(owner_address, sender_address));\n  throw_unless(error::not_enough_funds, balance >= 0);\n\n  var msg_body = begin_cell()\n          .store_body_header(op::burn_notification, query_id) ;; 32 + 64 = 96 bit\n          .store_coins(jetton_amount) ;; max 124 bit\n          .store_slice(owner_address) ;; 3 + 8 + 256 = 267 bit\n          .store_slice(response_address) ;; 3 + 8 + 256 = 267 bit\n          .store_uint(destination_address, 160) ;; 160 bit\n          .end_cell();\n\n  var msg = begin_cell()\n          .store_msg_flags(BOUNCEABLE)\n          .store_slice(jetton_master_address)\n          .store_coins(0)\n          .store_msgbody_prefix_ref()\n          .store_ref(msg_body);\n\n  send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);\n\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() on_bounce (slice in_msg_body) impure {\n  in_msg_body~skip_bits(32); ;; 0xFFFFFFFF\n  (int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();\n  int op = in_msg_body~load_op();\n  throw_unless(error::unknown_op, (op == op::internal_transfer) | (op == op::burn_notification));\n  int query_id = in_msg_body~load_query_id();\n  int jetton_amount = in_msg_body~load_coins();\n  balance += jetton_amount;\n  save_data(balance, owner_address, jetton_master_address, jetton_wallet_code);\n}\n\n() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {\n  if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n    return ();\n  }\n\n  slice cs = in_msg_full.begin_parse();\n  int flags = cs~load_uint(4);\n  if (flags & 1) {\n    on_bounce(in_msg_body);\n    return ();\n  }\n  slice sender_address = cs~load_msg_addr();\n  cs~load_msg_addr(); ;; skip dst\n  cs~load_coins(); ;; skip value\n  cs~skip_bits(1); ;; skip extracurrency collection\n  cs~load_coins(); ;; skip ihr_fee\n  int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\n\n  int op = in_msg_body~load_op();\n\n  (_, _, _, int state_flags, int bridge_burn_fee, int bridge_mint_fee, int wallet_min_tons_for_storage, int wallet_gas_consumption, _, _) = get_jetton_bridge_config();\n\n  if (op == op::transfer) { ;; outgoing transfer\n    send_tokens(in_msg_body, sender_address, msg_value, fwd_fee, wallet_min_tons_for_storage, wallet_gas_consumption);\n    return ();\n  }\n\n  if (op == op::internal_transfer) { ;; incoming transfer\n    receive_tokens(in_msg_body, sender_address, my_balance, fwd_fee, msg_value, wallet_min_tons_for_storage, wallet_gas_consumption);\n    return ();\n  }\n\n  if (op == op::burn) { ;; burn\n    throw_if( error::operation_suspended, state_flags & STATE_BURN_SUSPENDED);\n    throw_unless(error::burn_fee_not_matched, msg_value == bridge_burn_fee);\n    burn_tokens(in_msg_body, sender_address);\n    return ();\n  }\n\n  throw(error::unknown_op);\n}\n\n(int, slice, slice, cell) get_wallet_data() method_id {\n  return load_data();\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "jetton-bridge.fc",
        "content": "#include \"stdlib.fc\";\n#include \"params.fc\";\n#include \"op-codes.fc\";\n#include \"errors.fc\";\n#include \"messages.fc\";\n#include \"utils.fc\";\n#include \"config.fc\";\n\n;; collector_address: MsgAddress jetton_minter_code:^Cell jetton_wallet_code:^Cell\n(slice, cell, cell) load_data() inline_ref {\n    slice slice_data = get_data().begin_parse();\n    (slice collector_address, cell jetton_minter_code, cell jetton_wallet_code) = (slice_data~load_msg_addr(), slice_data~load_ref(), slice_data~load_ref());\n    slice_data.end_parse();\n    return (collector_address, jetton_minter_code, jetton_wallet_code);\n}\n\n() save_data(slice collector_address, cell jetton_minter_code, cell jetton_wallet_code) impure inline_ref {\n    set_data(begin_cell()\n        .store_slice(collector_address)\n        .store_ref(jetton_minter_code)\n        .store_ref(jetton_wallet_code)\n        .end_cell()\n    );\n}\n\n(slice, cell) calculate_minter_address(cell wrapped_token_data) impure inline_ref {\n    (slice collector_address, cell jetton_minter_code, cell jetton_wallet_code) = load_data();\n\n    cell jetton_minter_data = begin_cell()\n            .store_coins(0) ;; total_supply\n            .store_ref(wrapped_token_data)\n            .store_ref(jetton_wallet_code)\n            .end_cell();\n\n    cell jetton_minter_state_init = begin_cell()\n            .store_uint(0, 2)\n            .store_dict(jetton_minter_code)\n            .store_dict(jetton_minter_data)\n            .store_uint(0, 1)\n            .end_cell();\n\n    slice minter_address = calculate_address_by_state_init(jetton_minter_state_init); ;; calculate minter address by init_state\n    return (minter_address, jetton_minter_state_init);\n}\n\n() execute_voting (slice oracles_address, slice voting_data, int query_id, int bridge_mint_fee, int state_flags, int msg_value) impure {\n    (slice collector_address, cell jetton_minter_code, cell jetton_wallet_code) = load_data();\n\n    int op = voting_data~load_uint(8);\n\n    throw_if(error::unknown_execute_voting_op,\n        (op != op::execute_voting::swap) &\n        (op != op::execute_voting::get_reward) &\n        (op != op::execute_voting::change_collector));\n\n    throw_if(error::operation_suspended, state_flags & STATE_GOVERNANCE_SUSPENDED);\n\n    if (op == op::execute_voting::swap) {\n        throw_if(error::operation_suspended, state_flags & STATE_SWAPS_SUSPENDED);\n        (\n            int ext_chain_hash,\n            int internal_index, \n            int addr_hash,\n            int mint_jetton_amount,\n            cell wrapped_token_data,\n            int forward_coins_amount\n        ) = (\n            voting_data~load_uint(256),\n            voting_data~load_int(16),\n            voting_data~load_uint(256),\n            voting_data~load_coins(), ;; max 124 bits\n            voting_data~load_ref(),\n            voting_data~load_coins()\n        );\n\n        voting_data.end_parse();\n\n        (\n                int chain_id,\n                int token_address,\n                int token_decimals\n        ) = unpack_wrapped_token_data(wrapped_token_data);\n\n        throw_unless(error::wrong_external_chain_id, chain_id == MY_CHAIN_ID);\n\n        slice to_address = create_address(WORKCHAIN, addr_hash);\n\n        throw_unless(error::mint_fee_less_forward, bridge_mint_fee > forward_coins_amount);\n\n        (slice minter_address, cell jetton_minter_state_init) = calculate_minter_address(wrapped_token_data);\n\n        cell master_msg = begin_cell() ;; mint tokens to wallet address\n                .store_body_header(op::mint, query_id)\n                .store_slice(to_address) ;; 3 + 8 + 256 = 267 bit\n                .store_coins(mint_jetton_amount) ;; max 124 bit\n                .store_coins(forward_coins_amount) ;; max 124 bit\n                .end_cell();\n\n        var msg = begin_cell()\n                .store_msg_flags(BOUNCEABLE)\n                .store_slice(minter_address)\n                .store_coins(bridge_mint_fee)\n                .store_msgbody_prefix_stateinit()\n                .store_ref(jetton_minter_state_init)\n                .store_ref(master_msg);\n\n        send_raw_message(msg.end_cell(), SEND_MODE_REGULAR); ;; revert on errors\n\n    } elseif (op == op::execute_voting::get_reward) {\n\n        slice reward_address = voting_data~load_msg_addr();\n        voting_data.end_parse();\n\n        var msg = begin_cell() ;; send msg_value from oracles back to prevent withdrawing stakes\n                .store_msg_flags(NON_BOUNCEABLE)\n                .store_slice(oracles_address)\n                .store_coins(msg_value)\n                .store_msgbody_prefix_slice();\n        send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);\n\n        ;; reserve 100 Toncoins for storage fees\n        raw_reserve(100000000000, 2);\n\n        var msg = begin_cell() ;; send rewards to specified address\n                .store_msg_flags(NON_BOUNCEABLE)\n                .store_slice(reward_address)\n                .store_coins(0)\n                .store_msgbody_prefix_slice();\n        send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_BALANCE + SEND_MODE_IGNORE_ERRORS);\n\n    } elseif (op == op::execute_voting::change_collector) {\n\n        collector_address = voting_data~load_msg_addr();\n        voting_data.end_parse();\n\n        save_data(collector_address, jetton_minter_code, jetton_wallet_code);\n\n    }\n\n    if (op != op::execute_voting::get_reward) {\n        send_receipt_message(oracles_address, 0x10000 + 9, query_id, 0, 0, 64); ;; thanks\n    }\n}\n\n() recv_internal(int msg_value, cell in_msg_cell, slice in_msg_body) impure {\n    var cs = in_msg_cell.begin_parse();\n    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool\n    if (flags & 1) {\n        ;; ignore all bounced messages\n        return ();\n    }\n\n    throw_if(error::inbound_message_has_empty_body, in_msg_body.slice_empty?());\n\n    (int op, int query_id) = in_msg_body~load_body_header();\n\n    throw_if(error::unknown_op, (op != op::burn_notification) & (op != op::execute_voting) & (op != op::pay_swap) & (op != op::excesses));\n\n    slice sender_address = cs~load_msg_addr();\n    (int sender_wc, int sender_address_hash) = parse_std_addr(sender_address);\n\n    (_, int oracles_address_hash, _, int state_flags, int bridge_burn_fee, int bridge_mint_fee, _, _, _, _) = get_jetton_bridge_config();\n\n    int is_oracles = (sender_wc == -1) & (oracles_address_hash == sender_address_hash);\n\n    if (op == op::excesses) {\n        throw_if(error::oracles_sender, is_oracles);\n        return (); ;; just accept coins\n    }\n\n    if (op == op::execute_voting) {\n        throw_unless(error::oracles_not_sender, is_oracles);\n\n        execute_voting(sender_address, in_msg_body, query_id, bridge_mint_fee, state_flags, msg_value);\n\n    } elseif (op == op::pay_swap) {\n\n        throw_if(error::oracles_sender, is_oracles);\n        throw_unless(error::mint_fee_not_matched, msg_value == bridge_mint_fee);\n        int swap_id = in_msg_body~load_uint(256);\n        emit_log_simple(LOG_SWAP_PAID, begin_cell().store_uint(swap_id, 256).end_cell(), 0);\n    } elseif (op == op::burn_notification) {\n        int jetton_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n        slice response_address = in_msg_body~load_msg_addr();\n        int destination_address = in_msg_body~load_uint(160);\n        cell wrapped_token_data = in_msg_body~load_ref();\n        in_msg_body.end_parse();\n\n        (slice minter_address, _) = calculate_minter_address(wrapped_token_data);\n\n        throw_unless(error::minter_not_sender, equal_slices(minter_address, sender_address));\n        (int chain_id, int token_address, _) = unpack_wrapped_token_data(wrapped_token_data);\n\n        throw_unless(error::wrong_external_chain_id, chain_id == MY_CHAIN_ID); ;; can never happen\n\n        (int from_address_wc, int from_address_hash) = parse_std_addr(from_address);\n\n        throw_unless(error::wrong_sender_workchain, from_address_wc == WORKCHAIN); ;; can never happen\n\n        emit_log_simple(LOG_BURN, \n            begin_cell() ;; 704 bit\n                    .store_uint(destination_address, 160)\n                    .store_uint(jetton_amount, 128) ;; max 124 bits\n                    .store_uint(token_address, 160)\n                    .store_uint(from_address_hash, 256)\n                    .end_cell(),\n            1\n        );\n    }\n}\n\n;; get methods\n\nslice get_minter_address(cell wrapped_token_data) method_id {\n    (slice minter_address, _) = calculate_minter_address(wrapped_token_data);\n    return minter_address;\n}\n\n(int, int, cell, cell, int) get_bridge_data() method_id {\n    (slice collector_address, cell jetton_minter_code, cell jetton_wallet_code) = load_data();\n    (int wc, int addr) = parse_std_addr(collector_address);\n    return (wc, addr, jetton_minter_code, jetton_wallet_code, MY_CHAIN_ID);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "errors.fc",
        "content": ";; global errors\nconst int error::inbound_message_has_empty_body = 200;\nconst int error::unknown_op = 0xffff;\nconst int error::unknown_execute_voting_op = 211;\n\n;; data errors\nconst int error::incorrect_voting_data = 320;\nconst int error::decimals_out_of_range = 330;\n\n;; wrong sender errors\nconst int error::oracles_sender = 400;\nconst int error::oracles_not_sender = 401;\nconst int error::minter_not_sender = 402;\nconst int error::bridge_not_sender = 403;\nconst int error::owner_not_sender = 404;\nconst int error::operation_suspended = 704;\n\n;; jetton wallet errors\nconst int error::unauthorized_transfer = 705;\nconst int error::not_enough_funds = 706;\nconst int error::unauthorized_incoming_transfer = 707;\nconst int error::malformed_forward_payload = 708;\nconst int error::not_enough_tons = 709;\nconst int error::burn_fee_not_matched = 710;\n\n;; jetton minter errors\nconst int error::discovery_fee_not_matched = 75;\n\n;; jetton bridge errors\nconst int error::wrong_external_chain_id = 410;\nconst int error::wrong_sender_workchain = 413;\nconst int error::mint_fee_not_matched = 407;\nconst int error::mint_fee_less_forward = 399;\n\nconst int error::no_bridge_config = 666;",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "discovery-params.fc",
        "content": "const int op::provide_wallet_address = 0x2c76b973;\nconst int op::take_wallet_address = 0xd1735400;\n\nint is_resolvable?(slice addr) inline {\n    (int wc, _) = parse_std_addr(addr);\n\n    return wc == WORKCHAIN;\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "params.fc",
        "content": "const int CONFIG_PARAM_ID = 79;\nconst int MY_CHAIN_ID = 1;\nconst int LOG_BURN = 0xc0470ccf;\nconst int LOG_SWAP_PAID = 0xc0550ccf;\nconst int LOG_MINT_ON_MINTER = 0xc0660ccf;\nconst int LOG_BURN_ON_MINTER = 0xc0770ccf;\n\nconst int WORKCHAIN = 0;\n\n() force_chain(slice addr) impure {\n  (int wc, _) = parse_std_addr(addr);\n  throw_unless(333, wc == WORKCHAIN);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "utils.fc",
        "content": "#include \"messages.fc\";\n#include \"op-codes.fc\";\n\ncell pack_jetton_wallet_data(int balance, slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return  begin_cell()\n            .store_coins(balance)\n            .store_slice(owner_address)\n            .store_slice(jetton_master_address)\n            .store_ref(jetton_wallet_code)\n            .end_cell();\n}\n\ncell calculate_jetton_wallet_state_init(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return begin_cell()\n            .store_uint(0, 2)\n            .store_dict(jetton_wallet_code)\n            .store_dict(pack_jetton_wallet_data(0, owner_address, jetton_master_address, jetton_wallet_code))\n            .store_uint(0, 1)\n            .end_cell();\n}\n\nslice create_address(int wc, int address_hash) inline {\n    return begin_cell().store_uint(4, 3)\n            .store_int(wc, 8)\n            .store_uint(address_hash, 256)\n            .end_cell()\n            .begin_parse();\n}\n\nslice calculate_address_by_state_init(cell state_init) inline {\n    return create_address(WORKCHAIN, cell_hash(state_init));\n}\n\nslice calculate_user_jetton_wallet_address(slice owner_address, slice jetton_master_address, cell jetton_wallet_code) inline {\n    return calculate_address_by_state_init(calculate_jetton_wallet_state_init(owner_address, jetton_master_address, jetton_wallet_code));\n}\n\n() send_receipt_message(addr, ans_tag, query_id, body, grams, mode) impure inline_ref {\n    var msg = begin_cell()\n            .store_uint(NON_BOUNCEABLE, 6)\n            .store_slice(addr)\n            .store_grams(grams)\n            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n            .store_uint(ans_tag, 32)\n            .store_uint(query_id, 64);\n    if (body >= 0) {\n        msg~store_uint(body, 256);\n    }\n    send_raw_message(msg.end_cell(), mode);\n}\n\n;; LIMITS:\n;; chainId: uint32 (it seems EVM chainId is uint256, but for our cases 32 bits is enough https://chainlist.org/)\n;; token address in EVM network: 160 bit (an Ethereum address is a 42-character hexadecimal address derived from the last 20 bytes of the public key controlling the account with 0x appended in front. e.g., 0x71C7656EC7ab88b098defB751B7401B5f6d8976F - https://info.etherscan.com/what-is-an-ethereum-address)\n;; decimals: uint8 (ERC-20 has uint8 decimals - https://eips.ethereum.org/EIPS/eip-20)\n(int, int, int) unpack_wrapped_token_data(cell data) inline {\n    slice slice_data = data.begin_parse();\n\n    (\n        int chain_id,\n        int token_address,\n        int token_decimals\n    ) = (\n        slice_data~load_uint(32),\n        slice_data~load_uint(160),\n        slice_data~load_uint(8)\n    );\n    slice_data.end_parse();\n\n    return (\n        chain_id,\n        token_address,\n        token_decimals\n    );\n}\n\n;; https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#data-serialization\ncell pack_metadata_value(slice a) inline {\n    return begin_cell().store_uint(0, 8).store_slice(a).end_cell();\n}\n\nslice encode_number_to_text(int decimals, int radix) {\n    builder str = begin_cell();\n    int ctr  = 0;\n    tuple chars =  empty_tuple();\n\n    do {\n        (decimals, int rem) = decimals /% radix;\n\n        chars~tpush( rem >= 10 ? 87 + rem : 48 + rem);\n        ctr += 1;\n    } until (decimals == 0);\n\n    repeat( ctr ) {\n        str     = str.store_uint(chars.at(ctr - 1), 8);\n        ctr    -= 1;\n    }\n\n    return str.end_cell().begin_parse();\n}\n\n() emit_log_simple (int event_id, cell data, int need_separate_cell) impure inline {\n    ;; 1023 - (4+2+9+256+64+32+2) = 654 bit free\n\n    var msg = begin_cell()\n            .store_uint (12, 4)         ;; ext_out_msg_info$11 src:MsgAddressInt ()\n            .store_uint (1, 2)          ;; addr_extern$01\n            .store_uint (256, 9)        ;; len:(## 9)\n            .store_uint(event_id, 256); ;; external_address:(bits len)\n\n    if (need_separate_cell) {\n        msg = msg.store_uint(1, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n                .store_ref(data);\n    } else {\n        msg = msg.store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either\n                .store_slice(data.begin_parse());\n    }\n\n    send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);\n}",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "config.fc",
        "content": "const int STATE_BURN_SUSPENDED = 1; ;; state_flags & 1 - burn (TON->EVM transfer) suspended\nconst int STATE_SWAPS_SUSPENDED = 2; ;; state_flags & 2 - swaps (EVM->TON transfer) suspended\nconst int STATE_GOVERNANCE_SUSPENDED = 4; ;; state_flags & 4 - all governance actions suspended\nconst int STATE_COLLECTOR_SIGNATURE_REMOVAL_SUSPENDED = 8; ;; state_flags & 8 - collector signature removal suspended\n\n(int, int, cell, int, int, int, int, int, int, int) get_jetton_bridge_config() impure inline_ref {\n    cell bridge_config = config_param(CONFIG_PARAM_ID);\n    if (bridge_config.cell_null?()) {\n        bridge_config = config_param(- CONFIG_PARAM_ID);\n    }\n    throw_if(error::no_bridge_config, bridge_config.cell_null?());\n\n    slice slice_config = bridge_config.begin_parse();\n\n    int prefix = slice_config~load_uint(8);\n\n    int bridge_address_hash = slice_config~load_uint(256);\n\n    int oracles_address_hash = slice_config~load_uint(256);\n\n    ;; key: uint256 (public key) value: uint256 (eth address)\n    cell oracles = slice_config~load_dict();\n\n    int state_flags = slice_config~load_uint(8);\n\n    slice prices = slice_config~load_ref().begin_parse();\n\n    int bridge_burn_fee = prices~load_coins(); ;; ATTENTION: burn_fee must include burn network fees (at least 2 * fwd_fee + 3 * gas_consumption + minter_min_tons_for_storage)\n\n    int bridge_mint_fee = prices~load_coins(); ;; ATTENTION: mint_fee must include mint network fees (at least 2 * fwd_fee + 3 * gas_consumption + minter_min_tons_for_storage + wallet_min_tons_for_storage) and forward_coins_amount\n\n    int wallet_min_tons_for_storage = prices~load_coins();\n\n    int wallet_gas_consumption = prices~load_coins();\n\n    int minter_min_tons_for_storage = prices~load_coins();\n\n    int discover_gas_consumption = prices~load_coins();\n\n    return (bridge_address_hash, oracles_address_hash, oracles, state_flags, bridge_burn_fee, bridge_mint_fee, wallet_min_tons_for_storage, wallet_gas_consumption, minter_min_tons_for_storage, discover_gas_consumption);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "jetton-minter.fc",
        "content": ";; Jettons discoverable smart contract\n\n#include \"stdlib.fc\";\n#include \"params.fc\";\n#include \"op-codes.fc\";\n#include \"errors.fc\";\n#include \"messages.fc\";\n#include \"utils.fc\";\n#include \"config.fc\";\n#include \"discovery-params.fc\";\n\n\nslice zero_address() inline {\n    return begin_cell().store_uint(0, 2).end_cell().begin_parse();\n}\n\n;; storage scheme\n;; storage#_ total_supply:Coins content:^Cell jetton_wallet_code:^Cell = Storage;\n\n(int, cell, cell) load_data() inline {\n    slice ds = get_data().begin_parse();\n\n    (int total_supply, cell content, cell jetton_wallet_code) = (\n            ds~load_coins(), ;; total_supply\n            ds~load_ref(), ;; content\n            ds~load_ref() ;; jetton_wallet_code\n    );\n    ds.end_parse();\n\n    return (total_supply, content, jetton_wallet_code);\n}\n\n() save_data(int total_supply, cell content, cell jetton_wallet_code) impure inline {\n    set_data(begin_cell()\n            .store_coins(total_supply)\n            .store_ref(content)\n            .store_ref(jetton_wallet_code)\n            .end_cell()\n    );\n}\n\n() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {\n    cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);\n    slice to_wallet_address = calculate_address_by_state_init(state_init);\n    var msg = begin_cell()\n            .store_msg_flags(BOUNCEABLE)\n            .store_slice(to_wallet_address)\n            .store_coins(amount)\n            .store_msgbody_prefix_stateinit()\n            .store_ref(state_init)\n            .store_ref(master_msg);\n    send_raw_message(msg.end_cell(), SEND_MODE_REGULAR); ;; revert on errors\n}\n\n() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {\n    if (in_msg_body.slice_empty?()) { ;; ignore empty messages\n        return ();\n    }\n    slice cs = in_msg_full.begin_parse();\n    int flags = cs~load_uint(4);\n\n    if (flags & 1) { ;; ignore all bounced messages\n        return ();\n    }\n    slice sender_address = cs~load_msg_addr();\n    cs~load_msg_addr(); ;; skip dst\n    cs~load_coins(); ;; skip value\n    cs~skip_bits(1); ;; skip extracurrency collection\n    cs~load_coins(); ;; skip ihr_fee\n    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs\n\n    slice in_msg_body_copy = in_msg_body;\n    (int op, int query_id) = in_msg_body~load_body_header();\n\n    (int total_supply, cell content, cell jetton_wallet_code) = load_data();\n\n    (int bridge_address_hash, int oracles_address_hash, _, int state_flags, int bridge_burn_fee, int bridge_mint_fee, int wallet_min_tons_for_storage, int wallet_gas_consumption, int minter_min_tons_for_storage, int discover_gas_consumption) = get_jetton_bridge_config();\n    (int sender_wc, int sender_address_hash) = parse_std_addr(sender_address);\n\n    if (op == op::mint) {\n        throw_unless(error::bridge_not_sender, (sender_wc == -1) & (sender_address_hash == bridge_address_hash));\n        slice to_address = in_msg_body~load_msg_addr();\n\n        int rest_amount = pair_first(get_balance()) - minter_min_tons_for_storage;\n\n        int jetton_amount = in_msg_body~load_coins();\n        int forward_coins_amount = in_msg_body~load_coins();\n        in_msg_body.end_parse();\n\n        cell master_msg = begin_cell()\n                .store_body_header(op::internal_transfer, query_id)\n                .store_coins(jetton_amount) ;; max 124 bit\n                .store_slice(zero_address()) ;; from_address, 2 bit\n                .store_slice(create_address(-1, bridge_address_hash)) ;; response_address, 3 + 8 + 256 = 267 bit\n                .store_coins(forward_coins_amount) ;; forward_amount, 4 bit if zero\n                .store_uint(0, 1) ;; no forward_payload, 1 bit\n                .end_cell();\n\n        mint_tokens(to_address, jetton_wallet_code, rest_amount, master_msg);\n        int new_total_supply = total_supply + jetton_amount;\n        save_data(new_total_supply, content, jetton_wallet_code);\n\n        emit_log_simple(\n                LOG_MINT_ON_MINTER,\n                begin_cell().store_coins(new_total_supply).end_cell(),\n                0\n        );\n\n        return ();\n    }\n\n    if (op == op::burn_notification) {\n        int jetton_amount = in_msg_body~load_coins();\n        slice from_address = in_msg_body~load_msg_addr();\n\n        throw_unless(error::owner_not_sender,\n                equal_slices(calculate_user_jetton_wallet_address(from_address, my_address(), jetton_wallet_code), sender_address)\n        );\n        int new_total_supply = total_supply - jetton_amount;\n        save_data(new_total_supply, content, jetton_wallet_code);\n\n        cell new_body = begin_cell()\n                .store_slice(in_msg_body_copy)\n                .store_ref(content)\n                .end_cell();\n\n        int rest_amount = pair_first(get_balance()) - minter_min_tons_for_storage;\n\n        builder msg = begin_cell()\n                    .store_msg_flags(NON_BOUNCEABLE)\n                    .store_masterchain_address(bridge_address_hash)\n                    .store_coins(rest_amount)\n                    .store_msgbody_prefix_ref()\n                    .store_ref(new_body);\n\n        send_raw_message(msg.end_cell(), SEND_MODE_REGULAR);\n\n        emit_log_simple(\n                LOG_BURN_ON_MINTER,\n                begin_cell().store_coins(new_total_supply).end_cell(),\n                0\n        );\n\n        return ();\n    }\n\n    if (op == op::provide_wallet_address) {\n        throw_unless(error::discovery_fee_not_matched, msg_value > fwd_fee + discover_gas_consumption);\n\n        slice owner_address = in_msg_body~load_msg_addr();\n        int include_address? = in_msg_body~load_uint(1);\n        in_msg_body.end_parse();\n\n        cell included_address = include_address?\n                ? begin_cell().store_slice(owner_address).end_cell()\n                : null();\n\n        var msg = begin_cell()\n                .store_msg_flags(BOUNCEABLE)\n                .store_slice(sender_address)\n                .store_coins(0)\n                .store_msgbody_prefix_slice()\n                .store_body_header(op::take_wallet_address, query_id);\n\n        if (is_resolvable?(owner_address)) {\n            msg = msg.store_slice(calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code));\n        } else {\n            msg = msg.store_uint(0, 2); ;; addr_none\n        }\n        send_raw_message(msg.store_maybe_ref(included_address).end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);\n        return ();\n    }\n\n    throw(error::unknown_op);\n}\n\n(int, int, slice, cell, cell) get_jetton_data() method_id {\n    (int total_supply, cell content, cell jetton_wallet_code) = load_data();\n    cell content_dict = new_dict();\n\n    (\n        int chain_id,\n        int token_address,\n        int token_decimals\n    ) = unpack_wrapped_token_data(content);\n\n    slice decimals_slice = encode_number_to_text(token_decimals, 10);\n    slice chain_id_value = encode_number_to_text(chain_id, 10);\n    slice token_address_value = encode_number_to_text(token_address, 16);\n    builder uri_builder = begin_cell() ;; max (232 + 80 + 24 + 320) = 656 bits\n            .store_slice(\"https://bridge.ton.org/token/\") ;; 29 chars (232 bits)\n            .store_slice(chain_id_value) ;; max 10 chars (80 bits)\n            .store_slice(\"/0x\") ;; 24 bits\n            .store_slice(token_address_value); ;; 40 chars (320 bits)\n\n    slice uri_slice = uri_builder.store_slice(\".json\").end_cell().begin_parse();\n    slice image_slice = uri_builder.store_slice(\".png\").end_cell().begin_parse();\n\n    content_dict~udict_set_ref(256, \"uri\"H, pack_metadata_value(uri_slice));\n    content_dict~udict_set_ref(256, \"image\"H, pack_metadata_value(image_slice));\n    content_dict~udict_set_ref(256, \"decimals\"H, pack_metadata_value(decimals_slice));\n\n    ;; https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md#content-representation\n    cell onchain_content = begin_cell().store_uint(0, 8).store_dict(content_dict).end_cell();\n\n    return (total_supply, -1, zero_address(), onchain_content, jetton_wallet_code);\n}\n\nslice get_wallet_address(slice owner_address) method_id {\n    (int total_supply, cell content, cell jetton_wallet_code) = load_data();\n    return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);\n}\n\n;; chain_id, token_address, token_decimals\n(int, int, int) get_wrapped_token_data() method_id {\n    (int total_supply, cell content, cell jetton_wallet_code) = load_data();\n    return unpack_wrapped_token_data(content);\n}\n",
        "is_entrypoint": true,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "stdlib.fc",
        "content": ";; Standard library for funC\n;;\n\nforall X -> tuple cons(X head, tuple tail) asm \"CONS\";\nforall X -> (X, tuple) uncons(tuple list) asm \"UNCONS\";\nforall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) \"UNCONS\";\nforall X -> X car(tuple list) asm \"CAR\";\ntuple cdr(tuple list) asm \"CDR\";\ntuple empty_tuple() asm \"NIL\";\nforall X -> tuple tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> (tuple, ()) ~tpush(tuple t, X value) asm \"TPUSH\";\nforall X -> [X] single(X x) asm \"SINGLE\";\nforall X -> X unsingle([X] t) asm \"UNSINGLE\";\nforall X, Y -> [X, Y] pair(X x, Y y) asm \"PAIR\";\nforall X, Y -> (X, Y) unpair([X, Y] t) asm \"UNPAIR\";\nforall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm \"TRIPLE\";\nforall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm \"UNTRIPLE\";\nforall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm \"4 TUPLE\";\nforall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm \"4 UNTUPLE\";\nforall X -> X first(tuple t) asm \"FIRST\";\nforall X -> X second(tuple t) asm \"SECOND\";\nforall X -> X third(tuple t) asm \"THIRD\";\nforall X -> X fourth(tuple t) asm \"3 INDEX\";\nforall X, Y -> X pair_first([X, Y] p) asm \"FIRST\";\nforall X, Y -> Y pair_second([X, Y] p) asm \"SECOND\";\nforall X, Y, Z -> X triple_first([X, Y, Z] p) asm \"FIRST\";\nforall X, Y, Z -> Y triple_second([X, Y, Z] p) asm \"SECOND\";\nforall X, Y, Z -> Z triple_third([X, Y, Z] p) asm \"THIRD\";\nforall X -> X null() asm \"PUSHNULL\";\nforall X -> (X, ()) ~impure_touch(X x) impure asm \"NOP\";\n\nint now() asm \"NOW\";\nslice my_address() asm \"MYADDR\";\n[int, cell] get_balance() asm \"BALANCE\";\nint cur_lt() asm \"LTIME\";\nint block_lt() asm \"BLOCKLT\";\n\nint cell_hash(cell c) asm \"HASHCU\";\nint slice_hash(slice s) asm \"HASHSU\";\nint string_hash(slice s) asm \"SHA256U\";\n\nint check_signature(int hash, slice signature, int public_key) asm \"CHKSIGNU\";\nint check_data_signature(slice data, slice signature, int public_key) asm \"CHKSIGNS\";\n\n(int, int, int) compute_data_size(cell c, int max_cells) impure asm \"CDATASIZE\";\n(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm \"SDATASIZE\";\n(int, int, int, int) compute_data_size?(cell c, int max_cells) asm \"CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm \"SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT\";\n\n;; () throw_if(int excno, int cond) impure asm \"THROWARGIF\";\n\n() dump_stack() impure asm \"DUMPSTK\";\n\ncell get_data() asm \"c4 PUSH\";\n() set_data(cell c) impure asm \"c4 POP\";\ncont get_c3() impure asm \"c3 PUSH\";\n() set_c3(cont c) impure asm \"c3 POP\";\ncont bless(slice s) impure asm \"BLESS\";\n\n() accept_message() impure asm \"ACCEPT\";\n() set_gas_limit(int limit) impure asm \"SETGASLIMIT\";\n() commit() impure asm \"COMMIT\";\n() buy_gas(int gram) impure asm \"BUYGAS\";\n\nint min(int x, int y) asm \"MIN\";\nint max(int x, int y) asm \"MAX\";\n(int, int) minmax(int x, int y) asm \"MINMAX\";\nint abs(int x) asm \"ABS\";\n\nslice begin_parse(cell c) asm \"CTOS\";\n() end_parse(slice s) impure asm \"ENDS\";\n(slice, cell) load_ref(slice s) asm( -> 1 0) \"LDREF\";\ncell preload_ref(slice s) asm \"PLDREF\";\n;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) \"LDIX\";\n;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) \"LDUX\";\n;; int preload_int(slice s, int len) asm \"PLDIX\";\n;; int preload_uint(slice s, int len) asm \"PLDUX\";\n;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) \"LDSLICEX\";\n;; slice preload_bits(slice s, int len) asm \"PLDSLICEX\";\n(slice, int) load_grams(slice s) asm( -> 1 0) \"LDGRAMS\";\nslice skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\n(slice, ()) ~skip_bits(slice s, int len) asm \"SDSKIPFIRST\";\nslice first_bits(slice s, int len) asm \"SDCUTFIRST\";\nslice skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\n(slice, ()) ~skip_last_bits(slice s, int len) asm \"SDSKIPLAST\";\nslice slice_last(slice s, int len) asm \"SDCUTLAST\";\n(slice, cell) load_dict(slice s) asm( -> 1 0) \"LDDICT\";\ncell preload_dict(slice s) asm \"PLDDICT\";\nslice skip_dict(slice s) asm \"SKIPDICT\";\n\n(slice, cell) load_maybe_ref(slice s) asm( -> 1 0) \"LDOPTREF\";\ncell preload_maybe_ref(slice s) asm \"PLDOPTREF\";\nbuilder store_maybe_ref(builder b, cell c) asm(c b) \"STOPTREF\";\n\nint cell_depth(cell c) asm \"CDEPTH\";\n\nint slice_refs(slice s) asm \"SREFS\";\nint slice_bits(slice s) asm \"SBITS\";\n(int, int) slice_bits_refs(slice s) asm \"SBITREFS\";\nint slice_empty?(slice s) asm \"SEMPTY\";\nint slice_data_empty?(slice s) asm \"SDEMPTY\";\nint slice_refs_empty?(slice s) asm \"SREMPTY\";\nint slice_depth(slice s) asm \"SDEPTH\";\n\nint builder_refs(builder b) asm \"BREFS\";\nint builder_bits(builder b) asm \"BBITS\";\nint builder_depth(builder b) asm \"BDEPTH\";\n\nbuilder begin_cell() asm \"NEWC\";\ncell end_cell(builder b) asm \"ENDC\";\nbuilder store_ref(builder b, cell c) asm(c b) \"STREF\";\n;; builder store_uint(builder b, int x, int len) asm(x b len) \"STUX\";\n;; builder store_int(builder b, int x, int len) asm(x b len) \"STIX\";\nbuilder store_slice(builder b, slice s) asm \"STSLICER\";\nbuilder store_grams(builder b, int x) asm \"STGRAMS\";\nbuilder store_dict(builder b, cell c) asm(c b) \"STDICT\";\n\n(slice, slice) load_msg_addr(slice s) asm( -> 1 0) \"LDMSGADDR\";\ntuple parse_addr(slice s) asm \"PARSEMSGADDR\";\n(int, int) parse_std_addr(slice s) asm \"REWRITESTDADDR\";\n(int, slice) parse_var_addr(slice s) asm \"REWRITEVARADDR\";\n\ncell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\n(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETREF\";\ncell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\n(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETREF\";\ncell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETOPTREF\";\n(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGETREF\" \"NULLSWAPIFNOT\";\n(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGETREF\" \"NULLSWAPIFNOT\";\n(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTISETGETOPTREF\";\n(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) \"DICTUSETGETOPTREF\";\n(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDEL\";\n(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDEL\";\n(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIGET\" \"NULLSWAPIFNOT\";\n(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTIDELGET\" \"NULLSWAPIFNOT\";\n(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) \"DICTUDELGET\" \"NULLSWAPIFNOT\";\ncell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\n(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUSET\";\ncell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\n(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTISET\";\ncell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) \"DICTSET\";\n(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUADD\";\n(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTUREPLACE\";\n(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIADD\";\n(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) \"DICTIREPLACE\";\ncell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\n(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUSETB\";\ncell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\n(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTISETB\";\ncell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) \"DICTSETB\";\n(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUADDB\";\n(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTUREPLACEB\";\n(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIADDB\";\n(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) \"DICTIREPLACEB\";\n(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMIN\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTUREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTIREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) \"DICTREMMAX\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTUMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMIN\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAX\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMINREF\" \"NULLSWAPIFNOT2\";\n(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) \"DICTIMAXREF\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTUGETPREVEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXT\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETNEXTEQ\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREV\" \"NULLSWAPIFNOT2\";\n(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) \"DICTIGETPREVEQ\" \"NULLSWAPIFNOT2\";\ncell new_dict() asm \"NEWDICT\";\nint dict_empty?(cell c) asm \"DICTEMPTY\";\n\n(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTGETQ\" \"NULLSWAPIFNOT2\";\n(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) \"PFXDICTSET\";\n(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) \"PFXDICTDEL\";\n\ncell config_param(int x) asm \"CONFIGOPTPARAM\";\nint cell_null?(cell c) asm \"ISNULL\";\n\n() raw_reserve(int amount, int mode) impure asm \"RAWRESERVE\";\n() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm \"RAWRESERVEX\";\n() send_raw_message(cell msg, int mode) impure asm \"SENDRAWMSG\";\n() set_code(cell new_code) impure asm \"SETCODE\";\n\nint random() impure asm \"RANDU256\";\nint rand(int range) impure asm \"RAND\";\nint get_seed() impure asm \"RANDSEED\";\n() set_seed(int) impure asm \"SETRAND\";\n() randomize(int x) impure asm \"ADDRAND\";\n() randomize_lt() impure asm \"LTIME\" \"ADDRAND\";\n\nbuilder store_coins(builder b, int x) asm \"STVARUINT16\";\n(slice, int) load_coins(slice s) asm( -> 1 0) \"LDVARUINT16\";\n\nint equal_slices (slice a, slice b) asm \"SDEQ\";\nint builder_null?(builder b) asm \"ISNULL\";\nbuilder store_builder(builder to, builder from) asm \"STBR\";\n",
        "is_entrypoint": false,
        "is_std_lib": true,
        "include_in_command": true
      },
      {
        "name": "op-codes.fc",
        "content": ";; Jettons\n\nconst int op::transfer = 0xf8a7ea5;\nconst int op::transfer_notification = 0x7362d09c;\nconst int op::internal_transfer = 0x178d4519;\nconst int op::excesses = 0xd53276db;\nconst int op::burn = 0x595f07bc;\nconst int op::burn_notification = 0x7bdd97de;\n\n;; Minter\nconst int op::mint = 21;\n\n;; Bridge\n\nconst int op::execute_voting = 4;\nconst int op::execute_voting::swap = 0;\nconst int op::execute_voting::get_reward = 5;\nconst int op::execute_voting::change_collector = 7;\n\nconst int op::pay_swap = 8;\n\n(slice, int) ~load_op(slice s) inline { return s.load_uint(32); }\n(slice, int) ~load_query_id(slice s) inline { return s.load_uint(64); }\n(slice, (int, int)) ~load_body_header(slice s) inline {\n  int op = s~load_uint(32);\n  int query_id = s~load_uint(64);\n  return (s, (op, query_id));\n}\nbuilder store_op(builder b, int op) inline { return b.store_uint(op, 32); }\nbuilder store_query_id(builder b, int query_id) inline { return b.store_uint(query_id, 64); }\nbuilder store_body_header(builder b, int op, int query_id) inline {\n  return b.store_uint(op, 32)\n          .store_uint(query_id, 64);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      },
      {
        "name": "messages.fc",
        "content": "const int BOUNCEABLE = 0x18;\nconst int NON_BOUNCEABLE = 0x10;\n\nconst int SEND_MODE_REGULAR = 0;\nconst int SEND_MODE_PAY_FEES_SEPARETELY = 1;\nconst int SEND_MODE_IGNORE_ERRORS = 2;\nconst int SEND_MODE_DESTROY = 32;\nconst int SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;\nconst int SEND_MODE_CARRY_ALL_BALANCE = 128;\n\nbuilder store_msg_flags(builder b, int msg_flag) inline { return b.store_uint(msg_flag, 6); }\n\n{-\n  Helpers below fill in default/overwritten values of message layout:\n  Relevant part of TL-B schema:\n  ... other:ExtraCurrencyCollection ihr_fee:Grams fwd_fee:Grams created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;\n  bits      1                               4             4                64                32                            \n  ... init:(Maybe (Either StateInit ^StateInit))  body:(Either X ^X) = Message X;\n  bits      1      1(if prev is true)                   1\n\n-}\n\nbuilder store_msgbody_prefix_stateinit(builder b) inline { \n  return b.store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1);\n}\nbuilder store_msgbody_prefix_slice(builder b) inline { \n  return b.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n}\nbuilder store_msgbody_prefix_ref(builder b) inline { \n  return b.store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1);\n}\n\n{-\n\naddr_std$10 anycast:(Maybe Anycast) \n   workchain_id:int8 address:bits256  = MsgAddressInt;\n-}\n\nbuilder store_masterchain_address(builder b, int address_hash) inline {\n  return b.store_uint(4, 3).store_int(-1, 8).store_uint(address_hash, 256);\n}\n",
        "is_entrypoint": false,
        "is_std_lib": false,
        "include_in_command": true
      }
    ]
  }
}